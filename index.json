[{"content":"//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 // // 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 // // 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ // // // // 网格中的障碍物和空位置分别用 1 和 0 来表示。 // // // // 示例 1： // // //输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] //输出：2 //解释： //3x3 网格的正中间有一个障碍物。 //从左上角到右下角一共有 2 条不同的路径： //1. 向右 -\u0026gt; 向右 -\u0026gt; 向下 -\u0026gt; 向下 //2. 向下 -\u0026gt; 向下 -\u0026gt; 向右 -\u0026gt; 向右 // // // 示例 2： // // //输入：obstacleGrid = [[0,1],[0,0]] //输出：1 // // // // // 提示： // // // m == obstacleGrid.length // n == obstacleGrid[i].length // 1 \u0026lt;= m, n \u0026lt;= 100 // obstacleGrid[i][j] 为 0 或 1 // // Related Topics 数组 动态规划 // 👍 567 👎 0 /* * 63 不同路径 II * 2021-06-14 14:13:48 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int uniquePathsWithObstacles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; obstacleGrid) { int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m+1, vector\u0026lt;int\u0026gt;(n+1, 0)); dp[1][1] = 1; for(int i = 1;i \u0026lt;= m;i++){ for(int j = 1;j \u0026lt;= n;j++){ if(obstacleGrid[i-1][j-1] == 1){ dp[i][j] = 0; }else{ dp[i][j] += dp[i-1][j] + dp[i][j-1]; } } } return dp[m][n]; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/dp/63%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-ii-/","summary":"//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 // // 机器人每次只能向下或者向右移动一步。机器人试图达到网格的","title":"[63]不同路径 II"},{"content":"//给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 // // // // 示例 1： // // //输入：n = 3 //输出：5 // // // 示例 2： // // //输入：n = 1 //输出：1 // // // // // 提示： // // // 1 \u0026lt;= n \u0026lt;= 19 // // Related Topics 树 动态规划 // 👍 1190 👎 0 /* * 96 不同的二叉搜索树 * 2021-06-14 14:03:03 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int numTrees(int n) { vector\u0026lt;int\u0026gt; dp(n+1); dp[0] = 1; for(int i = 1;i \u0026lt;= n;i++){ dp[i] = 0; for(int j = 1;j \u0026lt;= i;j++){ dp[i] += dp[j-1] * dp[i - j]; } } return dp.back(); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/dp/96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-/","summary":"//给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 // // // // 示例 1： // // //","title":"[96]不同的二叉搜索树"},{"content":"//给你一个由 \u0026#39;1\u0026#39;（陆地）和 \u0026#39;0\u0026#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 // // 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 // // 此外，你可以假设该网格的四条边均被水包围。 // // // // 示例 1： // // //输入：grid = [ // [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], // [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], // [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], // [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;] //] //输出：1 // // // 示例 2： // // //输入：grid = [ // [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], // [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], // [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], // [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;] //] //输出：3 // // // // // 提示： // // // m == grid.length // n == grid[i].length // 1 \u0026lt;= m, n \u0026lt;= 300 // grid[i][j] 的值为 \u0026#39;0\u0026#39; 或 \u0026#39;1\u0026#39; // // Related Topics 深度优先搜索 广度优先搜索 并查集 // 👍 1191 👎 0 /* * 200 岛屿数量 * 2021-06-14 13:07:54 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size(); int n = grid[0].size(); int res = 0; for(int i = 0;i \u0026lt; m;i++){ for(int j = 0;j \u0026lt; n;j++){ if(grid[i][j] == \u0026#39;1\u0026#39;){ dfs(grid, i, j); res++; } } } return res; } int dx[4] = {-1, 0, 1, 0}; int dy[4] = {0, 1, 0, -1}; void dfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, int x,int y){ grid[x][y] = \u0026#39;0\u0026#39;; for(int i = 0;i \u0026lt; 4;i++){ int a = dx[i] + x; int b = dy[i] + y; if(a \u0026lt; 0 || a \u0026gt;= grid.size() || b \u0026lt; 0 || b \u0026gt;= grid[0].size() || grid[a][b] == \u0026#39;0\u0026#39;) continue; dfs(grid, a, b); } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/dfs/200%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-/","summary":"//给你一个由 \u0026#39;1\u0026#39;（陆地）和 \u0026#39;0\u0026#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 // // 岛屿总是被水包围，","title":"[200]岛屿数量"},{"content":"注： size()、empty()是所有容器都有的，时间复杂度为 O(1)，并不是结果并非遍历得到，而是原本就有个变 量来存size，直接访问该变量即可\n注：系统为某一程序分配空间时，所需时间与空间大小无关，而是与申请次数有关\u0026mdash;倍增思想的原理\nvector 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 即和数组一样，支持随机寻址 支持比较运算，按字典排序: vector \u0026lt;int\u0026gt; a(3, 5), b(5,3); if(a \u0026gt; b) cout \u0026lt;\u0026lt; \u0026#34; a \u0026gt; b \u0026#34;; 遍历方式： //遍历方法一 for(auto x:a) cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#39; \u0026#39;; //遍历方法二 迭代器可以看成是指针 for(int i = 0; i \u0026lt; a.size(); i ++) cout \u0026lt;\u0026lt; a[i] \u0026lt;\u0026lt; \u0026#39; \u0026#39;; //遍历方法三 迭代器可以看成是指针 for(vector \u0026lt;int\u0026gt; :: iterator i = a.begin(); i != a.end(); i ++) cout \u0026lt;\u0026lt; *i \u0026lt;\u0026lt; \u0026#39; \u0026#39;; pair pair \u0026lt;int, int\u0026gt; first 第一个元素 second 第二个元素 支持比较运算， 以第一个为第一关键字， 第二个为第二关键字（字典序)---可用于按某一属性排序，将待排属性放 在第一个元素位置 pair 初始化方式： pair \u0026lt;string , int\u0026gt; p; p = {\u0026#34;hello\u0026#34;, 20} p = make_pair(\u0026#34;hello\u0026#34;, 20); cout \u0026lt;\u0026lt; p.first \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; p.second ; 也可以用pair存储两个以上的属性，如：pair(int ,pair\u0026lt;int, int\u0026gt;); string 字符串 基本操作 substr(), c_str() //c_str() 返回 const 类型的指针 size()/length() 返回字符串长度 empty() clear()//清空整个字符串 erase() //erase(1,2) 删除以1为索引，长度为2的字符串 [] 支持比较运算，按字典序进行比较 a \u0026lt; \u0026#34;hello\u0026#34; 或 a.compare(\u0026#34;hello\u0026#34;);//a.compare() 返回具体的比较值 字符串变量和字符数组之间的转化： char ch[] = \u0026#34;hello\u0026#34;; string str = \u0026#34;world\u0026#34;; ch[] -\u0026gt; str : str = ch; str -\u0026gt; ch[] : strcpy(ch,str.c_str()); string 初始化: string a(\u0026#34;hello\u0026#34;); string a = \u0026#34;hello\u0026#34;; 取子串：//很常用 a.substr(1,3);//返回下标从1开始且长度为3的子串，包括左端点 拼接字符串： a += \u0026#34;world\u0026#34;;//新增字符串 a.append(\u0026#34; world\u0026#34;);//新增字符串 a.push_back(\u0026#39;.\u0026#39;);//在字符串末新增单个字符 在字符串指定位置添加字符串 a.insert(3,\u0026#34;world\u0026#34;); 访问字符串：string str; cout \u0026lt;\u0026lt; str[2];//以下标方式访问 cout \u0026lt;\u0026lt; str.at(2);//通过at()方法访问 getline(cin,str );;//读取一行字符赋值给str getline(cin, str,\u0026#39;!\u0026#39;);//读取一行字符赋值给str,以！结束 字符串排序： sort(str.begin(),str.end());//需要包含头文件algorithm 可以使用STL接口，可以理解为一个特殊的容器，容器里装的是的字符 a.push_back(\u0026#39;.\u0026#39;);//在字符串末新增单个字符 a.pop_back(); 字符串变量的交换和取代： a.swap(str);//str 为字符串变量 a.replace(1,2,str2) //用字符串str2取代字符串a下标为1长度为2的子串 deque 双端队列 缺点：慢，但用的不是很多，因为它要比一般的数组慢好几倍\nsize() empty() clear() front() / back() push_back() / pop_back() push_front() / pop_front() begin() / end() [] 容器适配器 C++ 提供了三种容器适配器(contain adapter): stack, queue, priority_queue。\nstack和queue基于deque实现 priority_queue基于vector实现 容器适配器的作用大概类似于电源适配器，将标准电压转化成各种需要的电压。\n你完全可以在deque上按照stack的方式工作，但是deque太强大了，它提供了远超stack的操作所需的各种接口 但凡你有一个失误，创建的栈就毁了。\nqueue 队列 size() empty() push() //向队尾插入一个元素 front() //返回对头元素 pop() //弹出对头元素 back() //返回队尾元素 priority_queue 优先队列 priority_queue\u0026lt;Type, Container, Functional\u0026gt; 如果不写后两个参数，那么容器默认用的是vector，比较方式默认用operator\u0026lt;，也就是优先队列是大顶堆，队头元素最大。\nType为数据类型， Container为保存数据的容器，Functional为元素比较方式。\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;queue\u0026gt; using namespace std; int main(){ priority_queue\u0026lt;int\u0026gt; p; p.push(1); p.push(2); p.push(8); p.push(5); p.push(43); for(int i=0;i\u0026lt;5;i++){ cout\u0026lt;\u0026lt;p.top()\u0026lt;\u0026lt;\u0026#34; \u0026#34;; p.pop(); } return 0; } // 43 8 5 2 1 //升序队列 priority_queue \u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt; \u0026gt; q; //降序队列 priority_queue \u0026lt;int,vector\u0026lt;int\u0026gt;,less\u0026lt;int\u0026gt; \u0026gt;q; //greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了） 其实就是堆，默认是大根堆 push() //插入一个元素 top() // 返回堆顶元素 pop() //弹出堆顶元素 将小根堆转化为大根堆： 方法1： priority_queue\u0026lt;int,vector\u0026lt;int\u0026gt;,greater\u0026lt;int\u0026gt;\u0026gt; heap; //定义一个小根堆heap; 方法2： 以负数来存 stack 栈 size() empty() push() //向栈顶插入一个元素 top() //返回栈顶元素 pop() //弹出栈顶元素 set, map, multiset, multimap 基于平衡二叉树（红黑树）， 动态维护有序序列\nset 与 multiset 的区别：set 里面不可以有重复元素，而multiset 可以有 size() empty() clear() begin() / end() ++, -- 返回前驱和后继， 时间复杂度： O(logn) set/multiset 集合 insert() 插入一个数 find() 查找一个数 count() 返回某个数的个数 erase() 注意：(1)(2)在set中无区别，但在multiset里有区别 (1) 输入是一个整数x, 删除所有x 时间复发度： O(k + logn) //k是所有元素的个数 (2) 输入一个迭代器， 删除这个迭代器 注意： lower_bound()/upper_bound() ----- 核心操作 lower_bound(x) 返回大于等于x的最小的数的迭代器 upper_bound(x) 返回大于x的最小的数的迭代器 map/multimap 哈希表 insert() 插入的一个数是一个pair 用的不多 erase() 输入的参数是pair 或 是迭代器 用的较多 find() [] 时间复杂度： O(logn) 最主要的操作 lower_bound()/upper_bound() unordered_set/map/multiset/multimap 哈希表 和上面类似，增、删、改、查的时间复杂度是 O(1) \u0026mdash; 优势 和上面的区别：凡是和排序有关的操作都是不支持的,如：不支持 lower_bound()/upper_bound() 迭代器的++，\u0026ndash; 等\nbitset 压位, 存储相同的数据量，存储空间仅占bool变量的 1/8\n定义变量： bitset\u0026lt;10000\u0026gt; s //注意\u0026lt;\u0026gt;中存的不是类型，而是个数 ~,\u0026amp;, |, ^ \u0026gt;\u0026gt; , \u0026lt;\u0026lt; == , != [] count() 返回有多少个1 any() 判断是否至少有一个1 none() 判断是否全为0 set() 把所有位置为1 set(k, v) 把第k位置为1 reset() 把所有位置为0 flip() 等价于~ flip(k) 把第k位取反 ","permalink":"https://oxygenbytes.github.io/posts/cplus/c++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93stl/","summary":"注： size()、empty()是所有容器都有的，时间复杂度为 O(1)，并不是结果并非遍历得到，而是原本就有个变 量来存size，直接访问该变","title":"C++标准模板库STL"},{"content":"bool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质 else l = mid + 1; } return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } ","permalink":"https://oxygenbytes.github.io/posts/template/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/","summary":"bool check(int x) {/* ... */} // 检查x是否满足某种性质 // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if","title":"整数二分算法模板"},{"content":"void merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i \u0026lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j \u0026lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i \u0026lt;= r; i ++, j ++ ) q[i] = tmp[j]; } ","permalink":"https://oxygenbytes.github.io/posts/template/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/","summary":"void merge_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int mid = l + r \u0026gt;\u0026gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= r) if (q[i] \u0026lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i","title":"归并排序模板"},{"content":"void quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } ","permalink":"https://oxygenbytes.github.io/posts/template/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/","summary":"void quick_sort(int q[], int l, int r) { if (l \u0026gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r \u0026gt;\u0026gt; 1]; while (i \u0026lt; j) { do i ++ ; while (q[i] \u0026lt; x); do j -- ; while (q[j] \u0026gt; x); if (i \u0026lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); }","title":"快速排序模板"},{"content":"求 $ m^k \\bmod p $\nint qmi(int m, int k, int p) { int res = 1 % p, t = m; while (k) { if (k\u0026amp;1) res = res * t % p; t = t * t % p; k \u0026gt;\u0026gt;= 1; } return res; } ","permalink":"https://oxygenbytes.github.io/posts/template/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%A8%A1%E6%9D%BF/","summary":"求 $ m^k \\bmod p $ int qmi(int m, int k, int p) { int res = 1 % p, t = m; while (k) { if (k\u0026amp;1) res = res * t % p; t = t * t % p; k \u0026gt;\u0026gt;= 1; } return res; }","title":"快速幂模板"},{"content":"//给定一个整数数组 asteroids，表示在同一行的行星。 // // 对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表示向右移动，负表示向左移动）。每一颗行星以相同的速度移动。 // // 找出碰撞后剩下的所有行星。碰撞规则：两个行星相互碰撞，较小的行星会爆炸。如果两颗行星大小相同，则两颗行星都会爆炸。两颗移动方向相同的行星，永远不会发生碰撞 //。 // // // // 示例 1： // // //输入：asteroids = [5,10,-5] //输出：[5,10] //解释：10 和 -5 碰撞后只剩下 10 。 5 和 10 永远不会发生碰撞。 // // 示例 2： // // //输入：asteroids = [8,-8] //输出：[] //解释：8 和 -8 碰撞后，两者都发生爆炸。 // // 示例 3： // // //输入：asteroids = [10,2,-5] //输出：[10] //解释：2 和 -5 发生碰撞后剩下 -5 。10 和 -5 发生碰撞后剩下 10 。 // // 示例 4： // // //输入：asteroids = [-2,-1,1,2] //输出：[-2,-1,1,2] //解释：-2 和 -1 向左移动，而 1 和 2 向右移动。 由于移动方向相同的行星不会发生碰撞，所以最终没有行星发生碰撞。 // // // // 提示： // // // 2 \u0026lt;= asteroids.length \u0026lt;= 104 // -1000 \u0026lt;= asteroids[i] \u0026lt;= 1000 // asteroids[i] != 0 // // Related Topics 栈 // 👍 151 👎 0 /* * 735 行星碰撞 * 2021-06-13 18:37:15 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;int\u0026gt; asteroidCollision(vector\u0026lt;int\u0026gt;\u0026amp; asteroids) { if(asteroids.empty()) return {}; vector\u0026lt;int\u0026gt; ans; stack\u0026lt;int\u0026gt; stk; for(auto aster : asteroids){ if(aster \u0026lt; 0){ while(!stk.empty() \u0026amp;\u0026amp; stk.top() \u0026lt; -aster) stk.pop(); if(stk.empty()) ans.push_back(aster); else{ if(stk.top() == -aster){ stk.pop(); } } }else{ stk.push(aster); } } vector\u0026lt;int\u0026gt; temp; while(!stk.empty()){ temp.push_back(stk.top()); stk.pop(); } for(auto it = temp.rbegin(); it != temp.rend(); it++){ ans.push_back(*it); } return ans; } }; class Solution2{ public: vector\u0026lt;int\u0026gt; asteroidCollision(vector\u0026lt;int\u0026gt;\u0026amp; asteroids) { vector\u0026lt;int\u0026gt; ans; for(auto x : asteroids){ if(x \u0026gt; 0) ans.push_back(x); else{ while(ans.size() \u0026amp;\u0026amp; ans.back() \u0026gt; 0 \u0026amp;\u0026amp; ans.back() \u0026lt; -x) ans.pop_back(); if(ans.size() \u0026amp;\u0026amp; ans.back() \u0026lt; 0) ans.push_back(x); else if(ans.empty() || ans.back() \u0026lt; 0) ans.push_back(x); } } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/stack/735%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E-/","summary":"//给定一个整数数组 asteroids，表示在同一行的行星。 // // 对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表","title":"[735]行星碰撞"},{"content":"//请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。 // // // 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2 //, 1, 1, 0, 0]。 // // 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 // Related Topics 栈 哈希表 // 👍 776 👎 0 /* * 739 每日温度 * 2021-06-13 18:08:44 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;int\u0026gt; dailyTemperatures(vector\u0026lt;int\u0026gt;\u0026amp; temperatures) { int n = temperatures.size(); vector\u0026lt;int\u0026gt; ans(n); stack\u0026lt;int\u0026gt; stk; for(int i = n - 1;i \u0026gt;= 0;i--){ while(!stk.empty() \u0026amp;\u0026amp; temperatures[i] \u0026gt;= temperatures[stk.top()]) stk.pop(); if(stk.empty()) ans[i] = 0; else ans[i] = stk.top() - i; stk.push(i); } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/stack/739%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-/","summary":"//请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置","title":"[739]每日温度"},{"content":"//整数数组 nums 按升序排列，数组中的值 互不相同 。 // // 在传递给函数之前，nums 在预先未知的某个下标 k（0 \u0026lt;= k \u0026lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[ //k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2 //,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 // // 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 // // // // 示例 1： // // //输入：nums = [4,5,6,7,0,1,2], target = 0 //输出：4 // // // 示例 2： // // //输入：nums = [4,5,6,7,0,1,2], target = 3 //输出：-1 // // 示例 3： // // //输入：nums = [1], target = 0 //输出：-1 // // // // // 提示： // // // 1 \u0026lt;= nums.length \u0026lt;= 5000 // -10^4 \u0026lt;= nums[i] \u0026lt;= 10^4 // nums 中的每个值都 独一无二 // 题目数据保证 nums 在预先未知的某个下标上进行了旋转 // -10^4 \u0026lt;= target \u0026lt;= 10^4 // // // // // 进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？ // Related Topics 数组 二分查找 // 👍 1399 👎 0 /* * 33 搜索旋转排序数组 * 2021-06-12 19:49:19 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { if(nums.empty()) return -1; int l = 0, r = nums.size() - 1; while(l \u0026lt; r){ int mid = l + r \u0026gt;\u0026gt; 1; if(nums[mid] \u0026lt;= nums.back()) r = mid; else l = mid + 1; } if(target \u0026lt;= nums.back()) r = nums.size() - 1; else l = 0, r--; while(l \u0026lt; r){ int mid = l + r \u0026gt;\u0026gt; 1; if(nums[mid] \u0026gt;= target) r = mid; else l = mid + 1; } if(nums[l] == target) return l; return -1; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/binarysearch/33-ii%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-/","summary":"//整数数组 nums 按升序排列，数组中的值 互不相同 。 // // 在传递给函数之前，nums 在预先未知的某个下标 k（0 \u0026lt;= k \u0026lt; nums.length）上进行了","title":"[33]搜索旋转排序数组"},{"content":"//已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变 //化后可能得到： // // 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] // 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7] // // // 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], //..., a[n-2]] 。 // // 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。 // // // // 示例 1： // // //输入：nums = [3,4,5,1,2] //输出：1 //解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。 // // // 示例 2： // // //输入：nums = [4,5,6,7,0,1,2] //输出：0 //解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。 // // // 示例 3： // // //输入：nums = [11,13,15,17] //输出：11 //解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。 // // // // // 提示： // // // n == nums.length // 1 \u0026lt;= n \u0026lt;= 5000 // -5000 \u0026lt;= nums[i] \u0026lt;= 5000 // nums 中的所有整数 互不相同 // nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 // // Related Topics 数组 二分查找 // 👍 493 👎 0 /* * 153 寻找旋转排序数组中的最小值 * 2021-06-12 19:39:39 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: // 这个题是找最小值，而不是找旋转数组转折点 int findMin(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int left = 0, right = nums.size() - 1; while(left \u0026lt; right){ int mid = left + right \u0026gt;\u0026gt; 1; if(nums[mid] \u0026lt;= nums.back()) right = mid; else left = mid + 1; } return nums[left]; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/binarysearch/153-ii%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-/","summary":"//已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变 //化后可能得到： // // 若旋转 4 次，则可","title":"[153]寻找旋转排序数组中的最小值"},{"content":"//给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 // // 如果数组中不存在目标值 target，返回 [-1, -1]。 // // 进阶： // // // 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ // // // // // 示例 1： // // //输入：nums = [5,7,7,8,8,10], target = 8 //输出：[3,4] // // 示例 2： // // //输入：nums = [5,7,7,8,8,10], target = 6 //输出：[-1,-1] // // 示例 3： // // //输入：nums = [], target = 0 //输出：[-1,-1] // // // // 提示： // // // 0 \u0026lt;= nums.length \u0026lt;= 105 // -109 \u0026lt;= nums[i] \u0026lt;= 109 // nums 是一个非递减数组 // -109 \u0026lt;= target \u0026lt;= 109 // // Related Topics 数组 二分查找 // 👍 1052 👎 0 /* * 34 在排序数组中查找元素的第一个和最后一个位置 * 2021-06-12 19:26:39 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;int\u0026gt; searchRange(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0, right = nums.size() - 1; while(left \u0026lt; right){ int mid = left + right + 1\u0026gt;\u0026gt; 1; if(nums[mid] \u0026lt;= target) left = mid; else right = mid - 1; } int temp = left; if(nums[temp] != target) return vector\u0026lt;int\u0026gt;{-1, -1}; left = 0, right = nums.size() - 1; while(left \u0026lt; right){ int mid = left + right \u0026gt;\u0026gt; 1; if(nums[mid] \u0026gt;= target) right = mid; else left = mid + 1; } return vector\u0026lt;int\u0026gt;{left, temp}; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/binarysearch/34-ii%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-/","summary":"//给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 // // 如果数组中不存在目标值","title":"[34]在排序数组中查找元素的第一个和最后一个位置"},{"content":"//给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 // // 你可以假设数组中无重复元素。 // // 示例 1: // // 输入: [1,3,5,6], 5 //输出: 2 // // // 示例 2: // // 输入: [1,3,5,6], 2 //输出: 1 // // // 示例 3: // // 输入: [1,3,5,6], 7 //输出: 4 // // // 示例 4: // // 输入: [1,3,5,6], 0 //输出: 0 // // Related Topics 数组 二分查找 // 👍 936 👎 0 /* * 35 搜索插入位置 * 2021-06-12 19:20:09 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int searchInsert(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { if(nums.empty() || nums.back() \u0026lt; target) return nums.size(); int left = 0, right = nums.size() - 1; // oooooov......... // 左(侧最)右(节点)加一 // .......vooooooo // 右(侧最)左(节点)不变 while(left \u0026lt; right){ int mid = left + right \u0026gt;\u0026gt; 1; if(nums[mid] \u0026gt;= target) right = mid; else left = mid + 1; } return left; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/binarysearch/35-ii%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-/","summary":"//给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 // // 你可以假设数","title":"[35]搜索插入位置"},{"content":"//实现 int sqrt(int x) 函数。 // // 计算并返回 x 的平方根，其中 x 是非负整数。 // // 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 // // 示例 1: // // 输入: 4 //输出: 2 // // // 示例 2: // // 输入: 8 //输出: 2 //说明: 8 的平方根是 2.82842..., // 由于返回类型是整数，小数部分将被舍去。 // // Related Topics 数学 二分查找 // 👍 692 👎 0 /* * 69 x 的平方根 * 2021-06-12 19:07:35 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int mySqrt(int x) { int left = 0, right = x; while(left \u0026lt; right){ int mid = left + right + 1\u0026gt;\u0026gt; 1; if(mid \u0026lt;= x / mid) left = mid; else right = mid - 1; } return left; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/binarysearch/69-iix-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-/","summary":"//实现 int sqrt(int x) 函数。 // // 计算并返回 x 的平方根，其中 x 是非负整数。 // // 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 // // 示例 1: //","title":"[69]x 的平方根"},{"content":"//给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。 // // 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 // // // // 说明： // // 为什么返回数值是整数，但输出的答案是数组呢？ // // 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 // // 你可以想象内部操作如下: // // //// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 //int len = removeDuplicates(nums); // //// 在函数里修改输入数组对于调用者是可见的。 //// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 //for (int i = 0; i \u0026lt; len; i++) { // print(nums[i]); //} // // // // // 示例 1： // // //输入：nums = [1,1,1,2,2,3] //输出：5, nums = [1,1,2,2,3] //解释：函数应返回新长度 length = 5, 并且原数组的前五个元素被修改为 1, 1, 2, 2, 3 。 不需要考虑数组中超出新长度后面的元素。 // // // 示例 2： // // //输入：nums = [0,0,1,1,1,1,2,3,3] //输出：7, nums = [0,0,1,1,2,3,3] //解释：函数应返回新长度 length = 7, 并且原数组的前五个元素被修改为 0, 0, 1, 1, 2, 3, 3 。 不需要考虑数组中超出新长度后面的 //元素。 // // // // // 提示： // // // 1 \u0026lt;= nums.length \u0026lt;= 3 * 104 // -104 \u0026lt;= nums[i] \u0026lt;= 104 // nums 已按升序排列 // // Related Topics 数组 双指针 // 👍 531 👎 0 /* * 80 删除有序数组中的重复项 II * 2021-06-12 14:44:00 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int i = 0, j = 0; while(j \u0026lt; nums.size()){ if(i \u0026lt; 2 || (nums[j] != nums[i-1] || nums[j] != nums[i-2])) nums[i++] = nums[j++]; else j++; } return i; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/stack/80%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-ii-/","summary":"//给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。 // // 不要使用额外的数组空间，你必须在 原地","title":"[80]删除有序数组中的重复项 II"},{"content":"//给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 // // 示例: // // 输入: [0,1,0,3,12] //输出: [1,3,12,0,0] // // 说明: // // // 必须在原数组上操作，不能拷贝额外的数组。 // 尽量减少操作次数。 // // Related Topics 数组 双指针 // 👍 1081 👎 0 /* * 283 移动零 * 2021-06-12 14:43:50 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: void moveZeroes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int j = 0; for(int i = 0;i \u0026lt; n;i++){ if(nums[i] != 0) nums[j++] = nums[i]; } for(;j \u0026lt; nums.size();j++){ nums[j] = 0; } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/doublepointers/283-ii%E7%A7%BB%E5%8A%A8%E9%9B%B6-/","summary":"//给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 // // 示例: // // 输入: [0,1,0,3,12] //输出: [1,3,12,0,0] // // 说明: // //","title":"[283]移动零"},{"content":"//给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 // // // // 示例 1： // // // // //输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] //输出：6 //解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 // // // 示例 2： // // //输入：height = [4,2,0,3,2,5] //输出：9 // // // // // 提示： // // // n == height.length // 0 \u0026lt;= n \u0026lt;= 3 * 104 // 0 \u0026lt;= height[i] \u0026lt;= 105 // // Related Topics 栈 数组 双指针 动态规划 // 👍 2406 👎 0 /* * 42 接雨水 * 2021-06-12 14:43:45 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) // [ref]:https://www.acwing.com/solution/content/121/ class Solution { public: int trap(vector\u0026lt;int\u0026gt;\u0026amp; height) { int n = height.size(); int ans = 0; stack\u0026lt;int\u0026gt; stk; for(int i = 0;i \u0026lt; n;i++){ // 单减栈 while(!stk.empty() \u0026amp;\u0026amp; height[stk.top()] \u0026lt;= height[i]){ int top = stk.top(); stk.pop(); if(stk.empty()) break; ans += (i - stk.top() - 1) * (min(height[stk.top()], height[i]) - height[top]); } stk.push(i); } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/doublepointers/42-ii%E6%8E%A5%E9%9B%A8%E6%B0%B4-/","summary":"//给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 // // // // 示例 1： // // // // //输入：height","title":"[42]接雨水"},{"content":"//给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, //ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 // // 说明：你不能倾斜容器。 // // // // 示例 1： // // // // //输入：[1,8,6,2,5,4,8,3,7] //输出：49 //解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 // // 示例 2： // // //输入：height = [1,1] //输出：1 // // // 示例 3： // // //输入：height = [4,3,2,1,4] //输出：16 // // // 示例 4： // // //输入：height = [1,2,1] //输出：2 // // // // // 提示： // // // n = height.length // 2 \u0026lt;= n \u0026lt;= 3 * 104 // 0 \u0026lt;= height[i] \u0026lt;= 3 * 104 // // Related Topics 数组 双指针 // 👍 2532 👎 0 /* * 11 盛最多水的容器 * 2021-06-12 14:43:40 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int ans = 0, i = 0, j = height.size() - 1; while(i \u0026lt; j){ ans = max(ans, min(height[i], height[j]) * (j - i)); height[i] \u0026lt; height[j] ? i++ : j--; } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/doublepointers/11-ii%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-/","summary":"//给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, //ai) 和 (i, 0) 。找出其","title":"[11]盛最多水的容器"},{"content":"//给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 // // 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 // // // // 说明: // // 为什么返回数值是整数，但输出的答案是数组呢? // // 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 // // 你可以想象内部操作如下: // // //// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 //int len = removeDuplicates(nums); // //// 在函数里修改输入数组对于调用者是可见的。 //// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。 //for (int i = 0; i \u0026lt; len; i++) { // print(nums[i]); //} // // // // 示例 1： // // //输入：nums = [1,1,2] //输出：2, nums = [1,2] //解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。 // // // 示例 2： // // //输入：nums = [0,0,1,1,1,2,2,3,3,4] //输出：5, nums = [0,1,2,3,4] //解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。 // // // // // 提示： // // // 0 \u0026lt;= nums.length \u0026lt;= 3 * 104 // -104 \u0026lt;= nums[i] \u0026lt;= 104 // nums 已按升序排列 // // // // Related Topics 数组 双指针 // 👍 2092 👎 0 /* * 26 删除有序数组中的重复项 * 2021-06-12 14:34:45 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.empty()) return 0; int i = 0, j = 0; while(j \u0026lt; nums.size()){ if(i == 0 || nums[j] != nums[i-1]){ nums[i++] = nums[j++]; }else j++; } return i; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/doublepointers/26-ii%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-/","summary":"//给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 // // 不要使用额外的数组空间，你必须在 原地 修","title":"[26]删除有序数组中的重复项"},{"content":"//编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 // // 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 // // 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 // // // // 示例 1： // // 输入：[\u0026#34;h\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;o\u0026#34;] //输出：[\u0026#34;o\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;l\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;h\u0026#34;] // // // 示例 2： // // 输入：[\u0026#34;H\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;h\u0026#34;] //输出：[\u0026#34;h\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;n\u0026#34;,\u0026#34;a\u0026#34;,\u0026#34;H\u0026#34;] // Related Topics 双指针 字符串 // 👍 415 👎 0 /* * 344 反转字符串 * 2021-06-12 14:31:58 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: void reverseString(vector\u0026lt;char\u0026gt;\u0026amp; s) { int i = 0; int j = s.size() - 1; while(i \u0026lt; j){ swap(s[i++], s[j--]); } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/doublepointers/344%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-/","summary":"//编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 // // 不要给另外的数组分配额外的空间，你必须原地修改输入数","title":"[344]反转字符串"},{"content":"//给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 // // 求在该柱状图中，能够勾勒出来的矩形的最大面积。 // // // // // // 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 // // // // // // 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 // // // // 示例: // // 输入: [2,1,5,6,2,3] //输出: 10 // Related Topics 栈 数组 // 👍 1397 👎 0 /* * 84 柱状图中最大的矩形 * 2021-06-11 21:17:57 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int largestRectangleArea(vector\u0026lt;int\u0026gt;\u0026amp; heights) { int ans = INT_MIN; int n = heights.size(); heights.push_back(-1); stack\u0026lt;int\u0026gt; stk; for(int i = 0;i \u0026lt;= n;i++){ while(!stk.empty() \u0026amp;\u0026amp; heights[i] \u0026lt; heights[stk.top()]){ int cur = stk.top(); stk.pop(); if(stk.empty()) ans = max(ans, heights[cur] * i); else ans = max(ans, heights[cur] * (i - stk.top() - 1)); } stk.push(i); } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/stack/84%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-/","summary":"//给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 // // 求在该柱状图中，能够勾勒出来的矩形的最大面积。 // // //","title":"[84]柱状图中最大的矩形"},{"content":"//给你二叉树的根结点 root ，请你将它展开为一个单链表： // // // 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。 // 展开后的单链表应该与二叉树 先序遍历 顺序相同。 // // // // // 示例 1： // // //输入：root = [1,2,5,3,4,null,6] //输出：[1,null,2,null,3,null,4,null,5,null,6] // // // 示例 2： // // //输入：root = [] //输出：[] // // // 示例 3： // // //输入：root = [0] //输出：[0] // // // // // 提示： // // // 树中结点数在范围 [0, 2000] 内 // -100 \u0026lt;= Node.val \u0026lt;= 100 // // // // // 进阶：你可以使用原地算法（O(1) 额外空间）展开这棵树吗？ // Related Topics 树 深度优先搜索 // 👍 824 👎 0 /* * 114 二叉树展开为链表 * 2021-06-11 21:08:58 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ /* 1. 1 / \\ 2 5 / \\ \\ 3 4 6 2. 1 \\ 2 / \\ 3 4 \\ 5 \\ 6 3. 1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 */ class Solution { public: void flatten(TreeNode* root) { auto now = root; while(now){ if(now-\u0026gt;left){ TreeNode* p = now-\u0026gt;left; while(p-\u0026gt;right) p = p-\u0026gt;right; p-\u0026gt;right = now-\u0026gt;right; now-\u0026gt;right = now-\u0026gt;left; now-\u0026gt;left = nullptr; } now = now-\u0026gt;right; } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/114%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8-/","summary":"//给你二叉树的根结点 root ，请你将它展开为一个单链表： // // // 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null","title":"[114]二叉树展开为链表"},{"content":"//给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 // // 说明： // // // 拆分时可以重复使用字典中的单词。 // 你可以假设字典中没有重复的单词。 // // // 示例 1： // // 输入: s = \u0026#34;leetcode\u0026#34;, wordDict = [\u0026#34;leet\u0026#34;, \u0026#34;code\u0026#34;] //输出: true //解释: 返回 true 因为 \u0026#34;leetcode\u0026#34; 可以被拆分成 \u0026#34;leet code\u0026#34;。 // // // 示例 2： // // 输入: s = \u0026#34;applepenapple\u0026#34;, wordDict = [\u0026#34;apple\u0026#34;, \u0026#34;pen\u0026#34;] //输出: true //解释: 返回 true 因为 \u0026#34;applepenapple\u0026#34; 可以被拆分成 \u0026#34;apple pen apple\u0026#34;。 // 注意你可以重复使用字典中的单词。 // // // 示例 3： // // 输入: s = \u0026#34;catsandog\u0026#34;, wordDict = [\u0026#34;cats\u0026#34;, \u0026#34;dog\u0026#34;, \u0026#34;sand\u0026#34;, \u0026#34;and\u0026#34;, \u0026#34;cat\u0026#34;] //输出: false // // Related Topics 动态规划 // 👍 1016 👎 0 /* * 139 单词拆分 * 2021-06-11 20:47:22 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { unordered_set\u0026lt;string\u0026gt; us(wordDict.begin(), wordDict.end()); vector\u0026lt;bool\u0026gt; dp(s.size() + 1, false); dp[0] = true; for(int i = 1;i \u0026lt;= s.size();i++){ for(int j = i;j \u0026gt;= 0;j--){ if(us.find(s.substr(j, i - j)) != us.end() \u0026amp;\u0026amp; dp[j]){ dp[i] = true; break; } } } return dp[s.size()]; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/139-ii%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-/","summary":"//给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 // // 说明： // // // 拆","title":"[139]单词拆分"},{"content":"//给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 // // 此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。 // // // // // // // 示例 1： // // //输入：nums = [2,0,2,1,1,0] //输出：[0,0,1,1,2,2] // // // 示例 2： // // //输入：nums = [2,0,1] //输出：[0,1,2] // // // 示例 3： // // //输入：nums = [0] //输出：[0] // // // 示例 4： // // //输入：nums = [1] //输出：[1] // // // // // 提示： // // // n == nums.length // 1 \u0026lt;= n \u0026lt;= 300 // nums[i] 为 0、1 或 2 // // // // // 进阶： // // // 你可以不使用代码库中的排序函数来解决这道题吗？ // 你能想出一个仅使用常数空间的一趟扫描算法吗？ // // Related Topics 排序 数组 双指针 // 👍 913 👎 0 /* * 75 颜色分类 * 2021-06-11 20:37:01 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: void sortColors(vector\u0026lt;int\u0026gt;\u0026amp; nums) { for(int i = 0, j = 0, k = nums.size() - 1;i \u0026lt;= k;){ if(nums[i] == 1) i++; else if(nums[i] == 2) swap(nums[i], nums[k--]); else swap(nums[i++], nums[j++]); } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/75%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-/","summary":"//给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 // // 此题中","title":"[75]颜色分类"},{"content":"//已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。 // // 不要使用系统的 Math.random() 方法。 // // // // // // // 示例 1: // // //输入: 1 //输出: [7] // // // 示例 2: // // //输入: 2 //输出: [8,4] // // // 示例 3: // // //输入: 3 //输出: [8,1,10] // // // // // 提示: // // // rand7 已定义。 // 传入参数: n 表示 rand10 的调用次数。 // // // // // 进阶: // // // rand7()调用次数的 期望值 是多少 ? // 你能否尽量少调用 rand7() ? // // Related Topics Random Rejection Sampling // 👍 196 👎 0 /* * 470 用 Rand7() 实现 Rand10() * 2021-06-11 20:19:42 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) // The rand7() API is already defined for you. // int rand7(); // @return a random integer in the range 1 to 7 int rand7(); class Solution { public: int rand10() { while(true){ int t = (rand7() - 1) * 7 + rand7(); // 1-49 if(t \u0026lt;= 40) return t % 10 + 1; } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/470-ii%E7%94%A8-rand7-%E5%AE%9E%E7%8E%B0-rand10-/","summary":"//已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。 // // 不要使用系统的 Math.random() 方法。 // // // // // // // 示例 1:","title":"[470]用 Rand7() 实现 Rand10()"},{"content":"//给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 // // 示例 1: // // //输入: \u0026#34;abab\u0026#34; // //输出: True // //解释: 可由子字符串 \u0026#34;ab\u0026#34; 重复两次构成。 // // // 示例 2: // // //输入: \u0026#34;aba\u0026#34; // //输出: False // // // 示例 3: // // //输入: \u0026#34;abcabcabcabc\u0026#34; // //输出: True // //解释: 可由子字符串 \u0026#34;abc\u0026#34; 重复四次构成。 (或者子字符串 \u0026#34;abcabc\u0026#34; 重复两次构成。) // // Related Topics 字符串 // 👍 499 👎 0 /* * 459 重复的子字符串 * 2021-06-11 19:57:37 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: bool repeatedSubstringPattern(string s) { int n = s.size(); // next数组 vector\u0026lt;int\u0026gt; next(n); next[0] = -1; int j = -1; // 注意i从1开始 for(int i = 1;i \u0026lt; n;i++){ while(j \u0026gt; -1 \u0026amp;\u0026amp; s[i] != s[j+1]) j = next[j]; if(s[i] == s[j+1]) j++; next[i] = j; } // next[n-1] - 1 减1是因为从-1开始计算 return next[n-1] != -1 \u0026amp;\u0026amp; n % (n - next[n-1] - 1) == 0; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/459%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2-/","summary":"//给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 // // 示例 1: // //","title":"[459]重复的子字符串"},{"content":"//实现 strStr() 函数。 // // 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如 //果不存在，则返回 -1 。 // // // // 说明： // // 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 // // 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 // // // // 示例 1： // // //输入：haystack = \u0026#34;hello\u0026#34;, needle = \u0026#34;ll\u0026#34; //输出：2 // // // 示例 2： // // //输入：haystack = \u0026#34;aaaaa\u0026#34;, needle = \u0026#34;bba\u0026#34; //输出：-1 // // // 示例 3： // // //输入：haystack = \u0026#34;\u0026#34;, needle = \u0026#34;\u0026#34; //输出：0 // // // // // 提示： // // // 0 \u0026lt;= haystack.length, needle.length \u0026lt;= 5 * 104 // haystack 和 needle 仅由小写英文字符组成 // // Related Topics 双指针 字符串 // 👍 932 👎 0 /* * 28 实现 strStr() * 2021-06-11 17:48:58 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int strStr(string haystack, string needle) { int m = haystack.size(); int n = needle.size(); if(!n) return 0; vector\u0026lt;int\u0026gt; next(n); next[0] = -1; int j = -1; // next[i]是子串s[0..i]的最长相等前后缀的前缀最后一位的坐标 for (int i = 1; i \u0026lt; n; i++) { while (j \u0026gt; -1 \u0026amp;\u0026amp; needle[i] != needle[j + 1]) j = next[j]; if (needle[i] == needle[j + 1]) j++; next[i] = j; } j = -1; for(int i = 0;i \u0026lt; m;i++){ while(j \u0026gt; -1 \u0026amp;\u0026amp; haystack[i] != needle[j+1]) j = next[j]; if(haystack[i] == needle[j+1]) j++; if(j == n - 1) return i - n + 1; } return -1; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/28%E5%AE%9E%E7%8E%B0-strstr-/","summary":"//实现 strStr() 函数。 // // 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如 //果不存在，则返回 -1 。 // // // // 说","title":"[28]实现 strStr()"},{"content":"//给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 \u0026#39;.\u0026#39; 和 \u0026#39;*\u0026#39; 的正则表达式匹配。 // // // \u0026#39;.\u0026#39; 匹配任意单个字符 // \u0026#39;*\u0026#39; 匹配零个或多个前面的那一个元素 // // // 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 // // // 示例 1： // // //输入：s = \u0026#34;aa\u0026#34; p = \u0026#34;a\u0026#34; //输出：false //解释：\u0026#34;a\u0026#34; 无法匹配 \u0026#34;aa\u0026#34; 整个字符串。 // // // 示例 2: // // //输入：s = \u0026#34;aa\u0026#34; p = \u0026#34;a*\u0026#34; //输出：true //解释：因为 \u0026#39;*\u0026#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 \u0026#39;a\u0026#39;。因此，字符串 \u0026#34;aa\u0026#34; 可被视为 \u0026#39;a\u0026#39; 重复了一次。 // // // 示例 3： // // //输入：s = \u0026#34;ab\u0026#34; p = \u0026#34;.*\u0026#34; //输出：true //解释：\u0026#34;.*\u0026#34; 表示可匹配零个或多个（\u0026#39;*\u0026#39;）任意字符（\u0026#39;.\u0026#39;）。 // // // 示例 4： // // //输入：s = \u0026#34;aab\u0026#34; p = \u0026#34;c*a*b\u0026#34; //输出：true //解释：因为 \u0026#39;*\u0026#39; 表示零个或多个，这里 \u0026#39;c\u0026#39; 为 0 个, \u0026#39;a\u0026#39; 被重复一次。因此可以匹配字符串 \u0026#34;aab\u0026#34;。 // // // 示例 5： // // //输入：s = \u0026#34;mississippi\u0026#34; p = \u0026#34;mis*is*p*.\u0026#34; //输出：false // // // // 提示： // // // 0 \u0026lt;= s.length \u0026lt;= 20 // 0 \u0026lt;= p.length \u0026lt;= 30 // s 可能为空，且只包含从 a-z 的小写字母。 // p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 // 保证每次出现字符 * 时，前面都匹配到有效的字符 // // Related Topics 字符串 动态规划 回溯算法 // 👍 2173 👎 0 /* * 10 正则表达式匹配 * 2021-06-11 17:07:58 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: bool isMatch(string s, string p) { int m = s.size(); int n = p.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m+1, vector\u0026lt;int\u0026gt;(n+1, false)); // dp[i][j] = dp[i-1][j-1] if(p[j-1] != \u0026#39;*\u0026#39; \u0026amp;\u0026amp; s[i-1] == p[j-1] || p[j-1] == \u0026#39;.\u0026#39;) // dp[i][j] = dp[i-1][j] if(p[j-1] == \u0026#39;*\u0026#39; \u0026amp;\u0026amp; (s[i-1] == p[j-2] || p[j-2] == \u0026#39;.\u0026#39;) // dp[i][j] == dp[i][j-2] if(p[i-1] == \u0026#39;*\u0026#39; and repeat 0 times) dp[0][0] = true; for(int i = 0;i \u0026lt;= m;i++){ for(int j = 1;j \u0026lt;= n;j++){ if(j \u0026gt; 1 \u0026amp;\u0026amp; p[j-1] == \u0026#39;*\u0026#39;){ bool a = dp[i][j-2]; bool b = i \u0026gt; 0 \u0026amp;\u0026amp; dp[i-1][j] \u0026amp;\u0026amp; (s[i-1] == p[j-2] || p[j-2] == \u0026#39;.\u0026#39;); dp[i][j] = a || b; }else{ dp[i][j] = i \u0026gt; 0 \u0026amp;\u0026amp; dp[i-1][j-1] \u0026amp;\u0026amp; (s[i-1] == p[j-1] || p[j-1] == \u0026#39;.\u0026#39;); } } } return dp[m][n]; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/10%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-/","summary":"//给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 \u0026#39;.\u0026#39; 和 \u0026#39;*\u0026#39; 的正则表达式匹配。 // // // \u0026#39;.\u0026#39; 匹配任意单个字符 // \u0026#39;*\u0026#39; 匹配零个或多个前面的那一个元素 //","title":"[10]正则表达式匹配"},{"content":"//给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 // // 给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。 // // 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 // // // // // 示例 1： // // //输入：n = 12 //输出：3 //解释：12 = 4 + 4 + 4 // // 示例 2： // // //输入：n = 13 //输出：2 //解释：13 = 4 + 9 // // // 提示： // // // 1 \u0026lt;= n \u0026lt;= 104 // // Related Topics 广度优先搜索 数学 动态规划 // 👍 949 👎 0 /* * 279 完全平方数 * 2021-06-11 16:14:31 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int numSquares(int n) { vector\u0026lt;int\u0026gt; dp(n+1, n); // max value // dp[i]就是n == i对应的结果 dp[0] = 0; for(int i = 1;i \u0026lt;= n;i++){ for(int j = 1;j * j \u0026lt;= i; j++){ dp[i] = min(dp[i], dp[i - j * j] + 1); } } return dp[n]; } }; class Solution2{ public: int numSquares(int n) { queue\u0026lt;int\u0026gt; q; q.push(0); vector\u0026lt;int\u0026gt; dist(n+1, INT_MAX); dist[0] = 0; while(q.size()){ auto t = q.front(); q.pop(); if(n == t) return dist[n]; for(int i = 1;i * i + t \u0026lt;= n;i++){ int cur = i * i + t; if(dist[cur] \u0026gt; dist[t] + 1){ dist[cur] = dist[t] + 1; q.push(cur); } } } return 0; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/279-ii%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-/","summary":"//给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 // // 给你一个整数 n ，返","title":"[279]完全平方数"},{"content":"笔试 忘了，似乎是五道题，有一道最长递增子序列没做出来（因为还让打印出序列），后来还被面试官拿出来鞭尸。。。其他简单题都做出来了\n时间比较久了，重点记一下算法题和答的不好的问题\n一面 select, poll, epoll，答的不好，因为没实际用过 算法题：求字符串的最长回文序列，秒了 二面 算法题：在增序链表中插入一个节点，参数为二级指针 算法题: 写一个二分搜索 三面 算法题：二位数组，从左到右，从上到下升序，查找某个值是不是在数组中，秒了 ","permalink":"https://oxygenbytes.github.io/posts/interview/%E9%AB%98%E9%80%94%E8%B7%9F%E8%B0%81%E5%AD%A6%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/","summary":"笔试 忘了，似乎是五道题，有一道最长递增子序列没做出来（因为还让打印出序列），后来还被面试官拿出来鞭尸。。。其他简单题都做出来了 时间比较久了，","title":"高途跟谁学面试复盘"},{"content":"时间比较久了，重点记一下算法题和答的不好的问题\n笔试 忘记了，大概是4道编程题，全是ACM类型的题目，最后做出来1.4道，进面试了\n一面 介绍自己 讲一下虚拟内存的工作原理，印象里只有这个面试官问过 算法题：连续子数组的最大和，秒了 反问了一下，常用C++，对java不太熟，而美团以java为主，会不会有影响 二面（2021-03-02 15:00，1小时30分钟） 介绍自己 说一下sql优化方法，我。。。 算法题：找出字符串中最长的回文串，秒了，用了O（n^2）的方法 反问一下工作内容和工作时间 ","permalink":"https://oxygenbytes.github.io/posts/interview/%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/","summary":"时间比较久了，重点记一下算法题和答的不好的问题 笔试 忘记了，大概是4道编程题，全是ACM类型的题目，最后做出来1.4道，进面试了 一面 介绍自己 讲","title":"美团优选面试复盘"},{"content":"投递之后一直无消息，后来被华为财经部门捞了，面试的职位是 财经数字化工程师，凭印象简单写写\n笔试（2021.03.24） 3道算法题, 第一题AC， 第二题70%， 第三题太长看晕了，直接提交了\n一面(2021.03.29) 自我介绍 简单讲讲项目，项目的难点是什么，怎么解决的 一些基础知识 算法题：最接近目标的三数之和，用了双指针，写的死循环了，本来还想调一下的，但是面试官说思路可以，就走了，真的很忙 二面（2021.03.29,接着一面继续） 介绍项目 学过什么课程 进程和线程，进程通讯方式 C++ STL里面的数据结构 大学里面专业课成绩怎么样？最好的是什么课？算法设计与分析 谈谈递归，深搜，广搜，动态规划 算法题：全排列，说说思路就可以，还谈到子集，组合问题，最后说到这几个问题和树的关系，如何从树的角度去理解这几个问题 主管面（2021.04.02） 我是哈工程的，面试官说自己对哈工程还算了解，因为他是哈工大的。。。\n大学经历 在学校的成绩 为什么没有实习 疫情对你的影响，因为疫情的感悟 为什么写博客，最大的收获是什么 做算法题最大的收获是什么？ 答：依然很菜，但是逐步消除了对代码的陌生感 对华为的看法和印象 对华为财经的看法，从华为最近拿到支付牌照聊了一下 为什么有些面试者对面向企业内部的软件开发业务不太感兴趣 如果同时拿到华为和互联网的offer，会怎么选择？ 谈一下自己的优缺点 期望薪资 反问了一下本科生在华为的发展和晋升问题 ","permalink":"https://oxygenbytes.github.io/posts/interview/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/","summary":"投递之后一直无消息，后来被华为财经部门捞了，面试的职位是 财经数字化工程师，凭印象简单写写 笔试（2021.03.24） 3道算法题, 第一题AC，","title":"华为面试复盘"},{"content":"笔试（2021.03.10） 笔试应该是春招最早的几批，当天Shoppe的笔试平台还崩掉了，在牛客网上还有不少吐嘈，不过不久就恢复正常了，有一说一Shoppe的这个笔试系统还是不错的 笔试是一部分选择 + 3道编程题，选择题目已经记不住了，时间很久了 三道编程题目分别是(之所以能记住是因为有个小伙伴问过)：\n字符串abc abcabcabc判断第一个串重复n次能不能得到第二个，使用暴力递归处理 通过70% 归并数组 AC 正则表达式匹配， leetcode原题， AC 两轮面试的题目我凭印象大概写写吧\n一面(2021.03.14) 时间也很久了，问的比较基础，是一个小姐姐\n重点是计算机网络，操作系统，数据库 白盒测试，黑盒测试 算法题：给定数组，将数组元素按出现次数排序并打印 算法题有点简单 SQL题：根据给定的条件写建表语句 差点栽了，因为我自己确实很少写SQL，勉强写了一个 反问 二面（2021.03.20） 介绍项目，项目中的难点 测试预约餐厅小程序的功能，角度尽可能全面，答的一般 算法题目，给定一个字符串，计算字符串中回文串的个数，给出测试用例，还要生成随机字符串来进行验证 分析时间复杂度，有没有更好的办法，答暴力法时间复杂度O(N^3), 还可以使用DP打表计算 如果一个字符串长为100万呢？ 答C++一秒大概执行10^7到10^8, 10^18次方要跑很久很久 wget用过没？ 答可以用来看google有没有连好。。。聊DNS污染，VPN的工作原理，聊网络知识 聊几个Linux命令，问为什么用Linux做桌面系统。。。 反问 HR面（2021.03.26） 经历 考研情况 城市意向 Offer情况 期望薪资 反问 收到意向书（2021年4月2日） 整体来说，整个流程比较常规，二面面试官问的点比较新鲜，面试官态度都很好\n","permalink":"https://oxygenbytes.github.io/posts/interview/shoppe%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/","summary":"笔试（2021.03.10） 笔试应该是春招最早的几批，当天Shoppe的笔试平台还崩掉了，在牛客网上还有不少吐嘈，不过不久就恢复正常了，有一","title":"Shoppe面试复盘"},{"content":"//如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。 // // 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7, //4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 // // 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。 // // 示例 1: // // 输入: [1,7,4,9,2,5] //输出: 6 //解释: 整个序列均为摆动序列。 // // // 示例 2: // // 输入: [1,17,5,10,13,15,10,5,16,8] //输出: 7 //解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。 // // 示例 3: // // 输入: [1,2,3,4,5,6,7,8,9] //输出: 2 // // 进阶: //你能否用 O(n) 时间复杂度完成此题? // Related Topics 贪心算法 动态规划 // 👍 414 👎 0 /* * 376 摆动序列 * 2021-03-19 13:36:27 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int wiggleMaxLength(vector\u0026lt;int\u0026gt;\u0026amp; nums) { nums.erase(unique(nums.begin(), nums.end()), nums.end()); if(nums.size() \u0026lt;= 2) return nums.size(); int res = 2; // 首尾 for(int i = 1; i + 1 \u0026lt; nums.size();i++){ int a = nums[i-1], b = nums[i], c = nums[i+1]; if(a \u0026lt; b \u0026amp;\u0026amp; b \u0026gt; c) res ++; else if(a \u0026gt; b \u0026amp;\u0026amp; b \u0026lt; c) res ++; } return res; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/376%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/","summary":"//如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是","title":"[376]摆动序列"},{"content":"//给定一个非负整数数组，你最初位于数组的第一个位置。 // // 数组中的每个元素代表你在该位置可以跳跃的最大长度。 // // 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 // // 示例: // // 输入: [2,3,1,1,4] //输出: 2 //解释: 跳到最后一个位置的最小跳跃数是 2。 // 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 // // // 说明: // // 假设你总是可以到达数组的最后一个位置。 // Related Topics 贪心算法 数组 // 👍 865 👎 0 /* * 45 跳跃游戏 II * 2021-03-18 13:54:50 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int jump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.size() == 1) return 0; int l = 0, r = 0, step = 0; while(l \u0026lt;= r){ int max_r = 0; for(int i = l;i \u0026lt;= r;i++){ max_r = max(max_r, i + nums[i]); } l = r + 1, r = max_r; step++; // cout\u0026lt;\u0026lt;0u - 1\u0026lt;\u0026lt;endl; 4294967295 // cout\u0026lt;\u0026lt;(int)(0u-1)\u0026lt;\u0026lt;endl; if(r \u0026gt;= (int)nums.size() - 1) break; // 默认转型 int -\u0026gt; unsigned int } return step; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/45%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii/","summary":"//给定一个非负整数数组，你最初位于数组的第一个位置。 // // 数组中的每个元素代表你在该位置可以跳跃的最大长度。 // // 你的目标是使用最少的跳跃次数","title":"[45]跳跃游戏 II"},{"content":"//给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 // // 数组中的每个元素代表你在该位置可以跳跃的最大长度。 // // 判断你是否能够到达最后一个下标。 // // // // 示例 1： // // //输入：nums = [2,3,1,1,4] //输出：true //解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 // // // 示例 2： // // //输入：nums = [3,2,1,0,4] //输出：false //解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 // // // // // 提示： // // // 1 \u0026lt;= nums.length \u0026lt;= 3 * 104 // 0 \u0026lt;= nums[i] \u0026lt;= 105 // // Related Topics 贪心算法 数组 // 👍 1089 👎 0 /* * 55 跳跃游戏 * 2021-03-18 13:49:38 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: bool canJump(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int dist = 0; // 目前可以跳到的最远值 for(int i = 0;i \u0026lt; nums.size() \u0026amp;\u0026amp; i \u0026lt;= dist;i++){ dist = max(dist, nums[i] + i); // 遍历中不断更新dist } return dist \u0026gt;= nums.size() - 1; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/","summary":"//给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 // // 数组中的每个元素代表你在该位置可以跳跃的最大长度。 // // 判断你是否能够到达最后一个","title":"[55]跳跃游戏"},{"content":"//假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 // // 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] \u0026gt;= g[i //]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 // // // 示例 1: // // //输入: g = [1,2,3], s = [1,1] //输出: 1 //解释: //你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 //虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 //所以你应该输出1。 // // // 示例 2: // // //输入: g = [1,2], s = [1,2,3] //输出: 2 //解释: //你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 //你拥有的饼干数量和尺寸都足以让所有孩子满足。 //所以你应该输出2. // // // // // 提示： // // // 1 \u0026lt;= g.length \u0026lt;= 3 * 104 // 0 \u0026lt;= s.length \u0026lt;= 3 * 104 // 1 \u0026lt;= g[i], s[j] \u0026lt;= 231 - 1 // // Related Topics 贪心算法 // 👍 309 👎 0 /* * 455 分发饼干 * 2021-03-18 13:45:28 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int findContentChildren(vector\u0026lt;int\u0026gt;\u0026amp; g, vector\u0026lt;int\u0026gt;\u0026amp; s) { sort(g.begin(), g.end()); sort(s.begin(), s.end()); int i = 0, j = 0, res = 0; for(int i = 0;i \u0026lt; g.size();i++){ while(j \u0026lt; s.size() \u0026amp;\u0026amp; s[j] \u0026lt; g[i]) j++; if(j \u0026lt; s.size()) res++, j++; } return res; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/455%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/","summary":"//假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 // // 对每个孩子 i，都有一个胃口值 g[i]，这是能让","title":"[455]分发饼干"},{"content":"//给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 // // 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\u0026#34;ace\u0026#34;是\u0026#34;abcde\u0026#34;的一个子序列，而\u0026#34;ae //c\u0026#34;不是）。 // // 进阶： // // 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k \u0026gt;= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代 //码？ // // 致谢： // // 特别感谢 @pbrother 添加此问题并且创建所有测试用例。 // // // // 示例 1： // // //输入：s = \u0026#34;abc\u0026#34;, t = \u0026#34;ahbgdc\u0026#34; //输出：true // // // 示例 2： // // //输入：s = \u0026#34;axc\u0026#34;, t = \u0026#34;ahbgdc\u0026#34; //输出：false // // // // // 提示： // // // 0 \u0026lt;= s.length \u0026lt;= 100 // 0 \u0026lt;= t.length \u0026lt;= 10^4 // 两个字符串都只由小写字符组成。 // // Related Topics 贪心算法 二分查找 动态规划 // 👍 409 👎 0 /* * 392 判断子序列 * 2021-03-18 13:36:21 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: bool isSubsequence(string s, string t) { int k = 0; for(int i = 0;i \u0026lt; t.size() \u0026amp;\u0026amp; k \u0026lt; s.size();i++){ if(t[i] == s[k]) k++; } return k == s.size(); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/392%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/","summary":"//给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 // // 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新","title":"[392]判断子序列"},{"content":"//在柠檬水摊上，每一杯柠檬水的售价为 5 美元。 // // 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 // // 每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。 // // 注意，一开始你手头没有任何零钱。 // // 如果你能给每位顾客正确找零，返回 true ，否则返回 false 。 // // 示例 1： // // 输入：[5,5,5,10,20] //输出：true //解释： //前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。 //第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。 //第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。 //由于所有客户都得到了正确的找零，所以我们输出 true。 // // // 示例 2： // // 输入：[5,5,10] //输出：true // // // 示例 3： // // 输入：[10,10] //输出：false // // // 示例 4： // // 输入：[5,5,10,10,20] //输出：false //解释： //前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。 //对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。 //对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。 //由于不是每位顾客都得到了正确的找零，所以答案是 false。 // // // // // 提示： // // // 0 \u0026lt;= bills.length \u0026lt;= 10000 // bills[i] 不是 5 就是 10 或是 20 // // Related Topics 贪心算法 // 👍 216 👎 0 /* * 860 柠檬水找零 * 2021-03-18 13:26:44 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: bool lemonadeChange(vector\u0026lt;int\u0026gt;\u0026amp; bills) { int fives = 0, tens = 0; for(auto b : bills){ if(b == 5) fives++; else if(b == 10){ if(fives) fives--; else return false; tens++; }else{ int t = 15; if(tens){ t -= 10; tens--; } while(t \u0026amp;\u0026amp; fives){ t -= 5; fives--; } if(t) return false; } return true; } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/860%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/","summary":"//在柠檬水摊上，每一杯柠檬水的售价为 5 美元。 // // 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 // // 每位顾客只买一杯柠檬水，然后","title":"[860]柠檬水找零"},{"content":"//给你一个 m x n 的矩阵 board ，由若干字符 \u0026#39;X\u0026#39; 和 \u0026#39;O\u0026#39; ，找到所有被 \u0026#39;X\u0026#39; 围绕的区域，并将这些区域里所有的 \u0026#39;O\u0026#39; 用 \u0026#39;X\u0026#39; 填充 //。 // // // // // 示例 1： // // //输入：board = [[\u0026#34;X\u0026#34;,\u0026#34;X\u0026#34;,\u0026#34;X\u0026#34;,\u0026#34;X\u0026#34;],[\u0026#34;X\u0026#34;,\u0026#34;O\u0026#34;,\u0026#34;O\u0026#34;,\u0026#34;X\u0026#34;],[\u0026#34;X\u0026#34;,\u0026#34;X\u0026#34;,\u0026#34;O\u0026#34;,\u0026#34;X\u0026#34;],[\u0026#34;X\u0026#34;,\u0026#34;O\u0026#34;,\u0026#34;X\u0026#34; //,\u0026#34;X\u0026#34;]] //输出：[[\u0026#34;X\u0026#34;,\u0026#34;X\u0026#34;,\u0026#34;X\u0026#34;,\u0026#34;X\u0026#34;],[\u0026#34;X\u0026#34;,\u0026#34;X\u0026#34;,\u0026#34;X\u0026#34;,\u0026#34;X\u0026#34;],[\u0026#34;X\u0026#34;,\u0026#34;X\u0026#34;,\u0026#34;X\u0026#34;,\u0026#34;X\u0026#34;],[\u0026#34;X\u0026#34;,\u0026#34;O\u0026#34;,\u0026#34;X\u0026#34;,\u0026#34;X\u0026#34;]] //解释：被围绕的区间不会存在于边界上，换句话说，任何边界上的 \u0026#39;O\u0026#39; 都不会被填充为 \u0026#39;X\u0026#39;。 任何不在边界上，或不与边界上的 \u0026#39;O\u0026#39; 相连的 \u0026#39;O\u0026#39; 最终都 //会被填充为 \u0026#39;X\u0026#39;。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。 // // // 示例 2： // // //输入：board = [[\u0026#34;X\u0026#34;]] //输出：[[\u0026#34;X\u0026#34;]] // // // // // 提示： // // // m == board.length // n == board[i].length // 1 \u0026lt;= m, n \u0026lt;= 200 // board[i][j] 为 \u0026#39;X\u0026#39; 或 \u0026#39;O\u0026#39; // // // // Related Topics 深度优先搜索 广度优先搜索 并查集 // 👍 489 👎 0 /* * 130 被围绕的区域 * 2021-03-16 18:49:31 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int m, n; int dx[4] = {-1, 0, 1, 0}; int dy[4] = {0, 1, 0, -1}; void solve(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board) { if(board.empty() || board[0].empty()) return ; m = board.size(); n = board.size(); for(int i = 0;i \u0026lt; n;i++){ if(board[i][0] == \u0026#39;O\u0026#39;) dfs(board, i, 0); if(board[i][m-1] == \u0026#39;O\u0026#39;) dfs(board, i, m - 1); } for(int j = 0;j \u0026lt; m;j++){ if(board[0][j] == \u0026#39;O\u0026#39;) dfs(board, 0, j); if(board[n-1][j] == \u0026#39;O\u0026#39;) dfs(board, n-1,j); } for(int i = 0;i \u0026lt; m;i++){ for(int j = 0;j \u0026lt; n;j++){ if(board[i][j] == \u0026#39;S\u0026#39;){ board[i][j] = \u0026#39;O\u0026#39;; }else if(board[i][j] == \u0026#39;O\u0026#39;) board[i][j] = \u0026#39;X\u0026#39;; } } } void dfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, int x, int y){ if(x \u0026gt;= 0 \u0026amp;\u0026amp; y \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; m \u0026amp;\u0026amp; y \u0026lt; n){ if(board[x][y] == \u0026#39;O\u0026#39;){ board[x][y] = \u0026#39;S\u0026#39;; for(int i = 0;i \u0026lt; 4;i++){ dfs(board, x + dx[i], y + dy[i]); } } } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/130%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/","summary":"//给你一个 m x n 的矩阵 board ，由若干字符 \u0026#39;X\u0026#39; 和 \u0026#39;O\u0026#39; ，找到所有被 \u0026#39;X\u0026#39; 围绕的区域，并将这些区域里所有的 \u0026#39;O\u0026#39; 用 \u0026#39;X\u0026#39; 填充 //。 // // // // // 示例 1： // // //输入：b","title":"[130]被围绕的区域"},{"content":"//有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。 // // 给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。 // // 为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方 //向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。 // // 最后返回经过上色渲染后的图像。 // // 示例 1: // // //输入: //image = [[1,1,1],[1,1,0],[1,0,1]] //sr = 1, sc = 1, newColor = 2 //输出: [[2,2,2],[2,2,0],[2,0,1]] //解析: //在图像的正中间，(坐标(sr,sc)=(1,1)), //在路径上所有符合条件的像素点的颜色都被更改成2。 //注意，右下角的像素没有更改为2， //因为它不是在上下左右四个方向上与初始点相连的像素点。 // // // 注意: // // // image 和 image[0] 的长度在范围 [1, 50] 内。 // 给出的初始点将满足 0 \u0026lt;= sr \u0026lt; image.length 和 0 \u0026lt;= sc \u0026lt; image[0].length。 // image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。 // // Related Topics 深度优先搜索 // 👍 169 👎 0 /* * 733 图像渲染 * 2021-03-16 18:36:49 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int dx[4] = {-1, 0, 1, 0}; int dy[4] = {0, 1, 0, -1}; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; floodFill(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; image, int sr, int sc, int newColor) { if(image.empty() || image[0].empty()) return image; int oldColor = image[sr][sr]; image[sr][sr] = newColor; if(oldColor == newColor) return image; for(int i = 0;i \u0026lt; 4;i++){ int x = sr + dx[i]; int y = sr + dy[i]; if(x \u0026gt;= 0 \u0026amp;\u0026amp; x \u0026lt; image.size() \u0026amp;\u0026amp; y \u0026lt; image[0].size() \u0026amp;\u0026amp; image[x][y] == oldColor){ floodFill(image, x, y, newColor); } return image; } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/","summary":"//有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。 // // 给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列","title":"[733]图像渲染"},{"content":"//给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 // // 给你一个整数 n ，返回和为 n 的完全平方数的 最少数量 。 // // 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 // // // // // 示例 1： // // //输入：n = 12 //输出：3 //解释：12 = 4 + 4 + 4 // // 示例 2： // // //输入：n = 13 //输出：2 //解释：13 = 4 + 9 // // // 提示： // // // 1 \u0026lt;= n \u0026lt;= 104 // // Related Topics 广度优先搜索 数学 动态规划 // 👍 793 👎 0 /* * 279 完全平方数 * 2021-03-12 15:54:53 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: /*本质上就是宽搜求最短路径 * 0-\u0026gt;1 * -\u0026gt; 1 * -\u0026gt; 4 * -\u0026gt; 9 * -\u0026gt; 16 * -\u0026gt;4 * -\u0026gt; 1 * -\u0026gt; 4 * -\u0026gt; 9 * -\u0026gt; 16 * -\u0026gt;9 * -\u0026gt; 1 * -\u0026gt; 4 * -\u0026gt; 9 * -\u0026gt; 16 * -\u0026gt;16 * -\u0026gt; 1 * -\u0026gt; 4 * -\u0026gt; 9 * -\u0026gt; 16 */ int numSquares(int n) { queue\u0026lt;int\u0026gt; q; vector\u0026lt;int\u0026gt; dist(n+1, INT_MAX); q.push(0); // 从0到n的最短距离 dist[0] = 0; while(q.size()){ auto t = q.front(); q.pop(); if(t == n) return dist[t]; for(int i = 1;i * i + t \u0026lt;= n;i++){ int j = t + i * i; if(dist[j] \u0026gt; dist[t] + 1){ dist[j] = dist[t] + 1; q.push(j); } } } return 0; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/279%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/","summary":"//给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 // // 给你一个整数 n ，返","title":"[279]完全平方数"},{"content":"//给定一个二叉树，找出其最小深度。 // // 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 // // 说明：叶子节点是指没有子节点的节点。 // // // // 示例 1： // // //输入：root = [3,9,20,null,null,15,7] //输出：2 // // // 示例 2： // // //输入：root = [2,null,3,null,4,null,5,null,6] //输出：5 // // // // // 提示： // // // 树中节点数的范围在 [0, 105] 内 // -1000 \u0026lt;= Node.val \u0026lt;= 1000 // // Related Topics 树 深度优先搜索 广度优先搜索 // 👍 468 👎 0 /* * 111 二叉树的最小深度 * 2021-03-12 15:30:40 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution2 { public: int minDepth(TreeNode* root) { if(!root) return 0; int ans = INT_MAX; dfs(root, 1, ans); return ans; } void dfs(TreeNode* root, int depth, int\u0026amp; ans){ if(!root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right){ if(depth \u0026lt; ans){ ans = depth; return ; } } if(root-\u0026gt;left) dfs(root-\u0026gt;left, depth+1, ans); if(root-\u0026gt;right) dfs(root-\u0026gt;right, depth+1, ans); } }; class Solution{ public: int minDepth(TreeNode* root){ if(!root) return 0; int left = minDepth(root-\u0026gt;left); int right = minDepth(root-\u0026gt;right); // 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 if(!left || !right) return left + right + 1; return min(left, right) + 1; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/111-ii%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/","summary":"//给定一个二叉树，找出其最小深度。 // // 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 // // 说明：叶子节点是指没有子节点的节点。 // //","title":"[111]二叉树的最小深度"},{"content":"//不使用运算符 + 和 - ，计算两整数 a 、b 之和。 // // 示例 1: // // 输入: a = 1, b = 2 //输出: 3 // // // 示例 2: // // 输入: a = -2, b = 3 //输出: 1 // Related Topics 位运算 // 👍 379 👎 0 /* * 371 两整数之和 * 2021-03-12 15:09:49 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int getSum(int a, int b) { if(!b) return a; // 每轮循环b最后一位都会多一个0,最多循环32轮 int sum = a ^ b, carry = (unsigned int)(a \u0026amp; b) \u0026lt;\u0026lt; 1; return getSum(sum, carry); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/371%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"//不使用运算符 + 和 - ，计算两整数 a 、b 之和。 // // 示例 1: // // 输入: a = 1, b = 2 //输出: 3 // // // 示例 2: // // 输入: a = -2, b = 3 //输出: 1 // Related","title":"[371]两整数之和"},{"content":"//给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。 // // // // 进阶：你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？ // // // // 示例 1： // // //输入：nums = [1,2,1,3,2,5] //输出：[3,5] //解释：[5, 3] 也是有效的答案。 // // // 示例 2： // // //输入：nums = [-1,0] //输出：[-1,0] // // // 示例 3： // // //输入：nums = [0,1] //输出：[1,0] // // // 提示： // // // 2 \u0026lt;= nums.length \u0026lt;= 3 * 104 // -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 // 除两个只出现一次的整数外，nums 中的其他数字都出现两次 // // Related Topics 位运算 // 👍 365 👎 0 /* * 260 只出现一次的数字 III * 2021-03-12 15:01:34 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;int\u0026gt; singleNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int s = 0; // if target is a \u0026amp;\u0026amp; b for(auto x : nums) s ^= x; // now s = a ^ b; int k = 0; while(!(s \u0026gt;\u0026gt; k \u0026amp; 1)) k++; // mark the pos where bit == 1 // divide by the bit=1 int s2 = 0; for(auto x : nums) if(x \u0026gt;\u0026gt; k \u0026amp; 1) s2 ^= x; return {s2, s2 ^ s}; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/260%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-iii/","summary":"//给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。 //","title":"[260]只出现一次的数字 III"},{"content":"//给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 // // 说明： // // 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ // // 示例 1: // // 输入: [2,2,3,2] //输出: 3 // // // 示例 2: // // 输入: [0,1,0,1,0,1,99] //输出: 99 // Related Topics 位运算 // 👍 522 👎 0 /* * 137 只出现一次的数字 II * 2021-03-12 14:52:10 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int singleNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { long long int ans = 0; for(int i = 31;i \u0026gt;= 0;i--){ int cnt = 0; for(auto num : nums) cnt += num \u0026gt;\u0026gt; i \u0026amp; 1; if(cnt % 3 == 1) ans = ans * 2 + 1; if(cnt % 3 == 0) ans = ans * 2; } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/137%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-ii/","summary":"//给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 // // 说明： // // 你的算法应该具有线","title":"[137]只出现一次的数字 II"},{"content":"//给你一个 正 整数 num ，输出它的补数。补数是对该数的二进制表示取反。 // // // // // // // 示例 1： // // //输入：num = 5 //输出：2 //解释：5 的二进制表示为 101（没有前导零位），其补数为 010。所以你需要输出 2 。 // // // 示例 2： // // //输入：num = 1 //输出：0 //解释：1 的二进制表示为 1（没有前导零位），其补数为 0。所以你需要输出 0 。 // // // // // 提示： // // // 给定的整数 num 保证在 32 位带符号整数的范围内。 // num \u0026gt;= 1 // 你可以假定二进制数不包含前导零位。 // 本题与 1009 https://leetcode-cn.com/problems/complement-of-base-10-integer/ 相同 // // Related Topics 位运算 // 👍 202 👎 0 /* * 476 数字的补数 * 2021-03-12 14:47:01 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int findComplement(int num) { int res = 0; int t = 0; /* * !是逻辑运算符(与||，\u0026amp;\u0026amp;是一类符号)，表示逻辑取反，可以把非0值变成0，把0值变为1 * ~是位运算符（与|，\u0026amp;是一类符号），表示按位取反，在数值的二进制表示上，将0变为1，将1变为0 */ while(num){ res += ( !(num \u0026amp; 1) ) \u0026lt;\u0026lt; t; num \u0026gt;\u0026gt;= 1; t++; } return res; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/476%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/","summary":"//给你一个 正 整数 num ，输出它的补数。补数是对该数的二进制表示取反。 // // // // // // // 示例 1： // // //输入：num = 5 //输出：2 //解释：5 的二","title":"[476]数字的补数"},{"content":"//给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 // // 说明： // // 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ // // 示例 1: // // 输入: [2,2,1] //输出: 1 // // // 示例 2: // // 输入: [4,1,2,1,2] //输出: 4 // Related Topics 位运算 哈希表 // 👍 1745 👎 0 /* * 136 只出现一次的数字 * 2021-03-12 14:41:42 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int singleNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { // a ^ a = 0 // a ^ 0 = a int res = 0; for(auto x : nums) res ^= x; return res; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/136%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/","summary":"//给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 // // 说明： // // 你的算法应该具有线性","title":"[136]只出现一次的数字"},{"content":"//给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。 // // （注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示 10101 有 3 个计算置位。还有，1 不是质数。） // // 示例 1: // // //输入: L = 6, R = 10 //输出: 4 //解释: //6 -\u0026gt; 110 (2 个计算置位，2 是质数) //7 -\u0026gt; 111 (3 个计算置位，3 是质数) //9 -\u0026gt; 1001 (2 个计算置位，2 是质数) //10-\u0026gt; 1010 (2 个计算置位，2 是质数) // // // 示例 2: // // //输入: L = 10, R = 15 //输出: 5 //解释: //10 -\u0026gt; 1010 (2 个计算置位, 2 是质数) //11 -\u0026gt; 1011 (3 个计算置位, 3 是质数) //12 -\u0026gt; 1100 (2 个计算置位, 2 是质数) //13 -\u0026gt; 1101 (3 个计算置位, 3 是质数) //14 -\u0026gt; 1110 (3 个计算置位, 3 是质数) //15 -\u0026gt; 1111 (4 个计算置位, 4 不是质数) // // // 注意: // // // L, R 是 L \u0026lt;= R 且在 [1, 10^6] 中的整数。 // R - L 的最大值为 10000。 // // Related Topics 位运算 // 👍 52 👎 0 /* * 762 二进制表示中质数个计算置位 * 2021-03-12 14:37:03 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int countPrimeSetBits(int L, int R) { // 10^6 ==\u0026gt; (0, 2^20) unordered_set\u0026lt;int\u0026gt; prime({2, 3, 5, 7, 11, 13, 17, 19}); int res = 0; for(int i = L;i \u0026lt;= R;i++){ int s = 0; for(int k = i; k;k \u0026gt;\u0026gt;= 1) s += k \u0026amp; 1; if(prime.count(s)) res++; } return res; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/762%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E8%B4%A8%E6%95%B0%E4%B8%AA%E8%AE%A1%E7%AE%97%E7%BD%AE%E4%BD%8D/","summary":"//给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。 // // （注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示","title":"[762]二进制表示中质数个计算置位"},{"content":"//给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 // // 示例 1: // // 输入: 1 //输出: true //解释: 20 = 1 // // 示例 2: // // 输入: 16 //输出: true //解释: 24 = 16 // // 示例 3: // // 输入: 218 //输出: false // Related Topics 位运算 数学 // 👍 290 👎 0 /* * 231 2的幂 * 2021-03-12 14:05:09 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution2 { public: bool isPowerOfTwo(int n) { return n \u0026gt; 0 \u0026amp;\u0026amp; (1 \u0026lt;\u0026lt; 30) % n == 0; } }; class Solution{ public: bool isPowerOfTwo(int n){ return n \u0026gt; 0 \u0026amp; (n \u0026amp; -n) == n; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/2312%E7%9A%84%E5%B9%82/","summary":"//给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 // // 示例 1: // // 输入: 1 //输出: true //解释: 20 = 1 // // 示例 2: // // 输入: 16 //输出: true","title":"[231]2的幂"},{"content":"一面（2021-02-24 18:00，1小时10分钟） 介绍自己 介绍项目，针对项目细节进行提问 浏览器输入一个地址，后面发生了什么？ 进程间通讯方式有哪些？ 死锁，原因与解除 const关键字和static关键字 define和const的区别 STL容器，vector, list, map, unordered_map, set效率及对应的底层结构 Redis与MySQL的区别 TCP的拥塞控制，流量控制，滑动窗口 如果当前面试界面崩溃了，如何排查问题 面向对象的三大特性 考研情况与意向城市 算法题：二叉树的镜像 反问 二面（2021-03-02 15:00，1小时30分钟） 介绍自己 介绍项目，介绍了很久 登录界面如何实现，如何测试 SQL注入 数据库中的表是如何组织的 为什么选用python 消息通知机制是如何实现的，如何改进 毕业设计题目，进度 C++语法，虚函数，虚函数表 深拷贝和浅拷贝，代码如何实现 引用和指针 分析结构体的内存对齐问题 malloc和free, new和delete，C++内存模型 迭代器失效的问题 C++程序的编译过程 计算机网络，DNS，HTTP，ARP，NAT，TCP, ICMP 上线的项目用户报告有问题，如何排查，如何定位问题 代码题：手写一个单例模式 是否了解其他设计模式 算法题：一个二位矩阵，矩阵中每个位置有不一样高的柱子，小球只能往高度相同的柱子或者更低的柱子滚动，判断一个小球能否滚落出矩阵 反问 三面（2021-03-08 11:00, 50分钟） 考研情况 去年面试字节的情况 介绍项目,前端，后端，数据库 用过抖音吗？在抖音买过东西吗？（没\u0026hellip;） 最常用的软件是什么？ （chrome） 如何对搜索引擎的搜索框进行测试 对搜索引擎技术还有那些了解 OSI模型和TCP/IP模型 算法题 给定一个字符串s，和字符串字典strDict，使用strDict中的字符串来组成s，并用|分割 代码写的很快，平时写代码多吗？是不是刷过很多题？为什么刷题？有哪些收获？ 谈到个人博客，为什么写博客？为什么博客打不开？（在github page上, 需要魔法。。） 考研不打算调剂吗？ 反问 HR面（2021-03-09 17:00，10分钟） 面试体验，对前面几位面试官的评价 为什么选择字节？ 为什么选测试开发 offer情况,态度最差的HR，问完之后说我没什么大厂offer，我当时刚开始春招，肯定没offer 城市意向 反问 ","permalink":"https://oxygenbytes.github.io/posts/interview/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/","summary":"一面（2021-02-24 18:00，1小时10分钟） 介绍自己 介绍项目，针对项目细节进行提问 浏览器输入一个地址，后面发生了什么？ 进程间通讯方","title":"字节跳动面试复盘"},{"content":"//给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 // // 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。 // // // // 示例 1： // // //输入：x = 121 //输出：true // // // 示例 2： // // //输入：x = -121 //输出：false //解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 // // // 示例 3： // // //输入：x = 10 //输出：false //解释：从右向左读, 为 01 。因此它不是一个回文数。 // // // 示例 4： // // //输入：x = -101 //输出：false // // // // // 提示： // // // -231 \u0026lt;= x \u0026lt;= 231 - 1 // // // // // 进阶：你能不将整数转为字符串来解决这个问题吗？ // Related Topics 数学 // 👍 1413 👎 0 /* * 9 回文数 * 2021-03-08 18:38:42 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: bool isPalindrome(int x) { if(x \u0026lt; 0) return false; return (long long)x == helper(x); } long long int helper(int x){ long long int ans = 0; while(x){ ans = ans * 10 + x % 10; x /= 10; } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/9%E5%9B%9E%E6%96%87%E6%95%B0/","summary":"//给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 // // 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，12","title":"[9]回文数"},{"content":"//给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 // // // // 进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？ // // // // 示例 1： // // //输入：nums = [100,4,200,1,3,2] //输出：4 //解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 // // 示例 2： // // //输入：nums = [0,3,7,2,5,8,4,6,0,1] //输出：9 // // // // // 提示： // // // 0 \u0026lt;= nums.length \u0026lt;= 104 // -109 \u0026lt;= nums[i] \u0026lt;= 109 // // Related Topics 并查集 数组 // 👍 706 👎 0 /* * 128 最长连续序列 * 2021-03-08 16:44:02 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int longestConsecutive(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.empty()) return 0; int ans = 0; unordered_set\u0026lt;int\u0026gt; us(nums.begin(), nums.end()); for(int i = 0; i \u0026lt; nums.size();i++){ if(!us.count(nums[i])) continue; us.erase(nums[i]); int pre = nums[i] - 1, next = nums[i] + 1; while(us.count(pre)) us.erase(pre--); while(us.count(next)) us.erase(next++); ans = max(ans, next - pre - 1); } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/128%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/","summary":"//给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 // // // // 进阶：你可以设计并实现时间复杂度为 O(n) 的","title":"[128]最长连续序列"},{"content":"//给你一个只包含 \u0026#39;(\u0026#39; 和 \u0026#39;)\u0026#39; 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 // // // // // // 示例 1： // // //输入：s = \u0026#34;(()\u0026#34; //输出：2 //解释：最长有效括号子串是 \u0026#34;()\u0026#34; // // // 示例 2： // // //输入：s = \u0026#34;)()())\u0026#34; //输出：4 //解释：最长有效括号子串是 \u0026#34;()()\u0026#34; // // // 示例 3： // // //输入：s = \u0026#34;\u0026#34; //输出：0 // // // // // 提示： // // // 0 \u0026lt;= s.length \u0026lt;= 3 * 104 // s[i] 为 \u0026#39;(\u0026#39; 或 \u0026#39;)\u0026#39; // // // // Related Topics 字符串 动态规划 // 👍 1197 👎 0 /* * 32 最长有效括号 * 2021-03-07 20:40:55 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /* * 具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」 * 这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标： 对于遇到的每个 (，我们将它的下标放入栈中 对于遇到的每个 )，我们先弹出栈顶元素表示匹配了当前右括号： 如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」 如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」 */ class Solution { public: int longestValidParentheses(string s) { int ans = 0; int start = 0; int n = s.size(); stack\u0026lt;int\u0026gt; stk; stk.push(-1); for(int i = 0; i \u0026lt; s.size();i++) { if (s[i] == \u0026#39;(\u0026#39;) stk.push(i); else if (s[i] == \u0026#39;)\u0026#39;) { stk.pop(); // 说明栈底存的是最后一个没有被匹配的右括号的下标，不可用来匹配 if (stk.empty()) stk.push(i); else ans = max(ans, i - stk.top()); } } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/32%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/","summary":"//给你一个只包含 \u0026#39;(\u0026#39; 和 \u0026#39;)\u0026#39; 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 // // // // // // 示例 1： // // //输入：s = \u0026#34;(()\u0026#34; //输出：2 //解释","title":"[32]最长有效括号"},{"content":"//你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上 //被小偷闯入，系统会自动报警。 // // 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 // // // // 示例 1： // // 输入：[1,2,3,1] //输出：4 //解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 // 偷窃到的最高金额 = 1 + 3 = 4 。 // // 示例 2： // // 输入：[2,7,9,3,1] //输出：12 //解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 // 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 // // // // // 提示： // // // 0 \u0026lt;= nums.length \u0026lt;= 100 // 0 \u0026lt;= nums[i] \u0026lt;= 400 // // Related Topics 动态规划 // 👍 1307 👎 0 /* * 198 打家劫舍 * 2021-03-07 20:36:42 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int rob(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.empty()) return 0; if(nums.size() == 1) return nums[0]; if(nums.size() == 2) return max(nums[0], nums[1]); // 内存可以优化，但是当前版本思路更清晰 vector\u0026lt;int\u0026gt; dp(nums.size(), 0); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for(int i = 2;i \u0026lt; nums.size();i++){ dp[i] = max(dp[i-1], dp[i-2] + nums[i]); } return dp.back(); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/","summary":"//你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间","title":"[198]打家劫舍"},{"content":"//编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： // // // 每行的元素从左到右升序排列。 // 每列的元素从上到下升序排列。 // // // // // 示例 1： // // //输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21 //,23,26,30]], target = 5 //输出：true // // // 示例 2： // // //输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21 //,23,26,30]], target = 20 //输出：false // // // // // 提示： // // // m == matrix.length // n == matrix[i].length // 1 \u0026lt;= n, m \u0026lt;= 300 // -109 \u0026lt;= matix[i][j] \u0026lt;= 109 // 每行的所有元素从左到右升序排列 // 每列的所有元素从上到下升序排列 // -109 \u0026lt;= target \u0026lt;= 109 // // Related Topics 二分查找 分治算法 // 👍 557 👎 0 /* * 240 搜索二维矩阵 II * 2021-03-07 20:25:20 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { int m = matrix.size(); if(!m) return false; int n = matrix[0].size(); if(!n) return false; int i = 0, j = n - 1; while(i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0){ if(target == matrix[i][j]) return true; else if(target \u0026lt; matrix[i][j]) j--; else i++; } return false; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-ii/","summary":"//编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： // // // 每行的元素从左到右升序排列。 // 每列的元素从上到下升序排列","title":"[240]搜索二维矩阵 II"},{"content":"//峰值元素是指其值大于左右相邻值的元素。 // // 给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。 // // 你可以假设 nums[-1] = nums[n] = -∞ 。 // // // // 示例 1： // // //输入：nums = [1,2,3,1] //输出：2 //解释：3 是峰值元素，你的函数应该返回其索引 2。 // // 示例 2： // // //输入：nums = [1,2,1,3,5,6,4] //输出：1 或 5 //解释：你的函数可以返回索引 1，其峰值元素为 2； // 或者返回索引 5， 其峰值元素为 6。 // // // // // 提示： // // // 1 \u0026lt;= nums.length \u0026lt;= 1000 // -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 // 对于所有有效的 i 都有 nums[i] != nums[i + 1] // // // // // 进阶：你可以实现时间复杂度为 O(logN) 的解决方案吗？ // Related Topics 数组 二分查找 // 👍 387 👎 0 /* * 162 寻找峰值 * 2021-03-07 19:36:51 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int findPeakElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.size() == 1) return 0; nums.insert(nums.begin(), INT_MIN); nums.push_back(INT_MIN); for(int i = 1;i \u0026lt; nums.size() - 1;i ++){ if(nums[i] \u0026gt; nums[i-1] \u0026amp;\u0026amp; nums[i] \u0026gt; nums[i+1]) return i - 1; // front of nums insert INT_MAX } return -1; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/162%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/","summary":"//峰值元素是指其值大于左右相邻值的元素。 // // 给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任","title":"[162]寻找峰值"},{"content":"//实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 // // 如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。 // // 必须 原地 修改，只允许使用额外常数空间。 // // // // 示例 1： // // //输入：nums = [1,2,3] //输出：[1,3,2] // // // 示例 2： // // //输入：nums = [3,2,1] //输出：[1,2,3] // // // 示例 3： // // //输入：nums = [1,1,5] //输出：[1,5,1] // // // 示例 4： // // //输入：nums = [1] //输出：[1] // // // // // 提示： // // // 1 \u0026lt;= nums.length \u0026lt;= 100 // 0 \u0026lt;= nums[i] \u0026lt;= 100 // // Related Topics 数组 // 👍 984 👎 0 /* * 31 下一个排列 * 2021-03-07 10:34:32 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /* * 那么是如何得到的呢，我们通过观察原数组可以发现 * 如果从末尾往前看，数字逐渐变大，到了2时才减小的，然后再从后往前找第一个比2大的数字，是3 * 那么我们交换2和3，再把此时3后面的所有数字转置一下即可，步骤如下： 1　2　7　4　3　1 1　2　7　4　3　1 1　3　7　4　2　1 1　3　1　2　4　7 */ class Solution { public: void nextPermutation(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if(n \u0026lt;= 1) return ; int i = n - 2; int j = n - 1; while(i \u0026gt;= 0 \u0026amp;\u0026amp; nums[i] \u0026gt;= nums[i+1]) i--; if(i \u0026gt;= 0){ while(nums[j] \u0026lt;= nums[i]) --j; swap(nums[i], nums[j]); } reverse(nums.begin() + i + 1, nums.end()); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/31%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/","summary":"//实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 // // 如果不存在下一个更大的排列，则将数字重新排列成最","title":"[31]下一个排列"},{"content":"//给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 // // 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 // // 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 // // // // 示例 1: // // 输入: [7,1,5,3,6,4] //输出: 7 //解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 // 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 // // // 示例 2: // // 输入: [1,2,3,4,5] //输出: 4 //解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 // 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 // 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 // // // 示例 3: // // 输入: [7,6,4,3,1] //输出: 0 //解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 // // // // 提示： // // // 1 \u0026lt;= prices.length \u0026lt;= 3 * 10 ^ 4 // 0 \u0026lt;= prices[i] \u0026lt;= 10 ^ 4 // // Related Topics 贪心算法 数组 // 👍 1121 👎 0 /* * 122 买卖股票的最佳时机 II * 2021-03-06 20:51:12 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { if(prices.size() \u0026lt;= 1) return 0; int total = 0; for(int i = 1;i \u0026lt; prices.size();i++){ if(prices[i] \u0026gt; prices[i-1]) total += prices[i] - prices[i-1]; } return total; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/122%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii/","summary":"//给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 // // 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买","title":"[122]买卖股票的最佳时机 II"},{"content":"//给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 // // candidates 中的数字可以无限制重复被选取。 // // 说明： // // // 所有数字（包括 target）都是正整数。 // 解集不能包含重复的组合。 // // // 示例 1： // // 输入：candidates = [2,3,6,7], target = 7, //所求解集为： //[ // [7], // [2,2,3] //] // // // 示例 2： // // 输入：candidates = [2,3,5], target = 8, //所求解集为： //[ // [2,2,2,2], // [2,3,3], // [3,5] //] // // // // 提示： // // // 1 \u0026lt;= candidates.length \u0026lt;= 30 // 1 \u0026lt;= candidates[i] \u0026lt;= 200 // candidate 中的每个元素都是独一无二的。 // 1 \u0026lt;= target \u0026lt;= 500 // // Related Topics 数组 回溯算法 // 👍 1200 👎 0 /* * 39 组合总和 * 2021-03-06 19:59:10 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; path; set\u0026lt;int\u0026gt; s; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combinationSum(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target) { if(candidates.empty()) return {}; dfs(candidates, target, 0); return ans; } void dfs(vector\u0026lt;int\u0026gt;\u0026amp; candidates, int target, int start){ if(target \u0026lt; 0) return ; if(target == 0){ ans.push_back(path); return ; } for(int i = start;i \u0026lt; candidates.size();i++){ path.push_back(candidates[i]); dfs(candidates, target - candidates[i], i); path.pop_back(); } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/","summary":"//给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 // // candidates 中的数字可以无限制重复被选取。 // // 说明： // // // 所有数","title":"[39]组合总和"},{"content":"//给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 // // // // 示例 1： // // //输入：nums1 = [1,3], nums2 = [2] //输出：2.00000 //解释：合并数组 = [1,2,3] ，中位数 2 // // // 示例 2： // // //输入：nums1 = [1,2], nums2 = [3,4] //输出：2.50000 //解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 // // // 示例 3： // // //输入：nums1 = [0,0], nums2 = [0,0] //输出：0.00000 // // // 示例 4： // // //输入：nums1 = [], nums2 = [1] //输出：1.00000 // // // 示例 5： // // //输入：nums1 = [2], nums2 = [] //输出：2.00000 // // // // // 提示： // // // nums1.length == m // nums2.length == n // 0 \u0026lt;= m \u0026lt;= 1000 // 0 \u0026lt;= n \u0026lt;= 1000 // 1 \u0026lt;= m + n \u0026lt;= 2000 // -106 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 106 // // // // // 进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？ // Related Topics 数组 二分查找 分治算法 // 👍 3768 👎 0 /* * 4 寻找两个正序数组的中位数 * 2021-03-06 11:42:51 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) // [ref]:https://zxi.mytechroad.com/blog/algorithms/binary-search/leetcode-4-median-of-two-sorted-arrays/ class Solution { public: double findMedianSortedArrays(vector\u0026lt;int\u0026gt;\u0026amp; nums1, vector\u0026lt;int\u0026gt;\u0026amp; nums2) { int m = nums1.size(); int n = nums2.size(); if(m \u0026gt; n) return findMedianSortedArrays(nums2, nums1); const int k = (n + m + 1) / 2; // 左中位数 int l = 0;int r = m; while(l \u0026lt; r){ const int a = l + (r - l) / 2; const int b = k - a; if(nums1[a] \u0026lt; nums2[b-1]){ l = a + 1; }else r = a; } const int a = l; const int b = k - l; const int c = max(a \u0026lt;= 0 ? INT_MIN : nums1[a-1], b \u0026lt;= 0 ? INT_MIN : nums2[b-1]); if((m + n) % 2 == 1) return c; const int d = min(a \u0026gt;= m ? INT_MAX : nums1[a], b \u0026gt;= n ? INT_MAX : nums2[b]); return (c + d) * 0.5; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/4%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","summary":"//给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 // // // // 示例 1： // // //输入：num","title":"[4]寻找两个正序数组的中位数"},{"content":"//给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 // // 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要 使用另一个矩阵来旋转图像。 // // // // 示例 1： // // //输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] //输出：[[7,4,1],[8,5,2],[9,6,3]] // // // 示例 2： // // //输入：matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] //输出：[[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] // // // 示例 3： // // //输入：matrix = [[1]] //输出：[[1]] // // // 示例 4： // // //输入：matrix = [[1,2],[3,4]] //输出：[[3,1],[4,2]] // // // // // 提示： // // // matrix.length == n // matrix[i].length == n // 1 \u0026lt;= n \u0026lt;= 20 // -1000 \u0026lt;= matrix[i][j] \u0026lt;= 1000 // // Related Topics 数组 // 👍 806 👎 0 /* * 48 旋转图像 * 2021-03-06 11:35:24 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: void rotate(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int n = matrix.size(); for(int i = 0;i \u0026lt; n;i++){ for(int j = i + 1;j \u0026lt; n;j++){ swap(matrix[i][j], matrix[j][i]); } reverse(matrix[i].begin(), matrix[i].end()); } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/48%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/","summary":"//给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 // // 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要","title":"[48]旋转图像"},{"content":"//给定一个字符串，逐个翻转字符串中的每个单词。 // // 说明： // // // 无空格字符构成一个 单词 。 // 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 // 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 // // // // // 示例 1： // // 输入：\u0026#34;the sky is blue\u0026#34; //输出：\u0026#34;blue is sky the\u0026#34; // // // 示例 2： // // 输入：\u0026#34; hello world! \u0026#34; //输出：\u0026#34;world! hello\u0026#34; //解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 // // // 示例 3： // // 输入：\u0026#34;a good example\u0026#34; //输出：\u0026#34;example good a\u0026#34; //解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 // // // 示例 4： // // 输入：s = \u0026#34; Bob Loves Alice \u0026#34; //输出：\u0026#34;Alice Loves Bob\u0026#34; // // // 示例 5： // // 输入：s = \u0026#34;Alice does not even like bob\u0026#34; //输出：\u0026#34;bob like even not does Alice\u0026#34; // // // // // 提示： // // // 1 \u0026lt;= s.length \u0026lt;= 104 // s 包含英文大小写字母、数字和空格 \u0026#39; \u0026#39; // s 中 至少存在一个 单词 // // // // // // // // 进阶： // // // 请尝试使用 O(1) 额外空间复杂度的原地解法。 // // Related Topics 字符串 // 👍 288 👎 0 /* * 151 翻转字符串里的单词 * 2021-03-06 11:18:50 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: string reverseWords(string s) { int k = 0; for(int i = 0;i \u0026lt; s.size();i++){ while(i \u0026lt; s.size() \u0026amp;\u0026amp; s[i] == \u0026#39; \u0026#39;) i ++ ; // find word begin == i if(i == s.size()) break; int j = i; while(j \u0026lt; s.size() \u0026amp;\u0026amp; s[j] != \u0026#39; \u0026#39;) j ++; // find word end == j reverse(s.begin() + i, s.begin() + j); // reverse if(k) s[k++] = \u0026#39; \u0026#39;; // skip head \u0026#39; \u0026#39; while(i \u0026lt; j) s[k++] = s[i++]; // copy } s.erase(s.begin() + k, s.end()); // erase end of them reverse(s.begin(), s.end()); // reverse return s; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/151-ii%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/","summary":"//给定一个字符串，逐个翻转字符串中的每个单词。 // // 说明： // // // 无空格字符构成一个 单词 。 // 输入字符串可以在前面或者后面包含多余的空格，但是反","title":"[151]翻转字符串里的单词"},{"content":"//给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 // // 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序 //列。 // // // 示例 1： // // //输入：nums = [10,9,2,5,3,7,101,18] //输出：4 //解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 // // // 示例 2： // // //输入：nums = [0,1,0,3,2,3] //输出：4 // // // 示例 3： // // //输入：nums = [7,7,7,7,7,7,7] //输出：1 // // // // // 提示： // // // 1 \u0026lt;= nums.length \u0026lt;= 2500 // -104 \u0026lt;= nums[i] \u0026lt;= 104 // // // // // 进阶： // // // 你可以设计时间复杂度为 O(n2) 的解决方案吗？ // 你能将算法的时间复杂度降低到 O(n log(n)) 吗? // // Related Topics 二分查找 动态规划 // 👍 1404 👎 0 /* * 300 最长递增子序列 * 2021-03-04 19:43:09 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if(n == 0) return 0; // 以nums[i]结尾的的最长上升子序列 vector\u0026lt;int\u0026gt; dp(n, 1); for(int i = 0;i \u0026lt; n;i++){ for(int j = 0;j \u0026lt; i;j++){ if(nums[j] \u0026lt; nums[i]){ dp[i] = max(dp[i],dp[j]+1); } } } return *max_element(dp.begin(), dp.end()); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/300-ii%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/","summary":"//给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 // // 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺","title":"[300]最长递增子序列"},{"content":"//给定一个二叉树，返回它的 后序 遍历。 // // 示例: // // 输入: [1,null,2,3] // 1 // \\ // 2 // / // 3 // //输出: [3,2,1] // // 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ // Related Topics 栈 树 // 👍 534 👎 0 /* * 145 二叉树的后序遍历 * 2021-03-04 19:32:32 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { if(!root) return {}; stack\u0026lt;pair\u0026lt;TreeNode*,bool\u0026gt;\u0026gt; stk; auto ptr = root; vector\u0026lt;int\u0026gt; ans; while(stk.size() || ptr){ if(ptr){ // get into left stk.push(make_pair(ptr, false)); ptr = ptr-\u0026gt;left; }else{ auto now = stk.top();stk.pop(); if(now.second){ // back from right ans.push_back(now.first-\u0026gt;val); }else{ // go to right stk.push(make_pair(now.first, true)); ptr = now.first-\u0026gt;right; } } } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/","summary":"//给定一个二叉树，返回它的 后序 遍历。 // // 示例: // // 输入: [1,null,2,3] // 1 // \\ // 2 // / // 3 // //输出: [3,2,1] // // 进阶: 递归算法很简单，你可以通过迭代算法完","title":"[145]二叉树的后序遍历"},{"content":"//给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 // // 说明： // // // 拆分时可以重复使用字典中的单词。 // 你可以假设字典中没有重复的单词。 // // // 示例 1： // // 输入: s = \u0026#34;leetcode\u0026#34;, wordDict = [\u0026#34;leet\u0026#34;, \u0026#34;code\u0026#34;] //输出: true //解释: 返回 true 因为 \u0026#34;leetcode\u0026#34; 可以被拆分成 \u0026#34;leet code\u0026#34;。 // // // 示例 2： // // 输入: s = \u0026#34;applepenapple\u0026#34;, wordDict = [\u0026#34;apple\u0026#34;, \u0026#34;pen\u0026#34;] //输出: true //解释: 返回 true 因为 \u0026#34;applepenapple\u0026#34; 可以被拆分成 \u0026#34;apple pen apple\u0026#34;。 // 注意你可以重复使用字典中的单词。 // // // 示例 3： // // 输入: s = \u0026#34;catsandog\u0026#34;, wordDict = [\u0026#34;cats\u0026#34;, \u0026#34;dog\u0026#34;, \u0026#34;sand\u0026#34;, \u0026#34;and\u0026#34;, \u0026#34;cat\u0026#34;] //输出: false // // Related Topics 动态规划 // 👍 854 👎 0 /* * 139 单词拆分 * 2021-03-04 19:11:28 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: unordered_set\u0026lt;string\u0026gt; us; unordered_map\u0026lt;string, bool\u0026gt; exist; bool wordBreak(string s, vector\u0026lt;string\u0026gt;\u0026amp; wordDict) { us = unordered_set\u0026lt;string\u0026gt;(wordDict.begin(), wordDict.end()); return dfs(s); } bool dfs(string s){ if(exist.count(s)) return exist[s]; if(us.count(s)) return exist[s] = true; for(int i = 0;i \u0026lt; s.size();i++){ string temp = s.substr(0, i); if(us.count(temp)){ if(dfs(s.substr(i))) return exist[s] = true; } } return exist[s] = false; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/139%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/","summary":"//给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 // // 说明： // // // 拆","title":"[139]单词拆分"},{"content":"//给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。 // // 返回移除了所有不包含 1 的子树的原二叉树。 // // ( 节点 X 的子树为 X 本身，以及所有 X 的后代。) // // //示例1: //输入: [1,null,0,0,1] //输出: [1,null,0,null,1] // //解释: //只有红色节点满足条件“所有不包含 1 的子树”。 //右图为返回的答案。 // // // // // //示例2: //输入: [1,0,1,0,0,0,1] //输出: [1,null,1,null,1] // // // // // // //示例3: //输入: [1,1,0,1,1,0,1,0] //输出: [1,1,0,1,1,null,1] // // // // // // 说明: // // // 给定的二叉树最多有 100 个节点。 // 每个节点的值只会为 0 或 1 。 // // Related Topics 树 // 👍 143 👎 0 /* * 814 二叉树剪枝 * 2021-03-04 19:05:13 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* pruneTree(TreeNode* root) { if(!root) return root; root-\u0026gt;left = pruneTree(root-\u0026gt;left); root-\u0026gt;right = pruneTree(root-\u0026gt;right); return (!root-\u0026gt;val \u0026amp;\u0026amp; !root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right) ? nullptr : root; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/814%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/","summary":"//给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。 // // 返回移除了所有不包含 1 的子树的原二叉树。 // // ( 节点 X 的子树为 X 本身，以及","title":"[814]二叉树剪枝"},{"content":"//给定一个单链表 L：L0→L1→…→Ln-1→Ln ， //将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… // // 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 // // 示例 1: // // 给定链表 1-\u0026gt;2-\u0026gt;3-\u0026gt;4, 重新排列为 1-\u0026gt;4-\u0026gt;2-\u0026gt;3. // // 示例 2: // // 给定链表 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, 重新排列为 1-\u0026gt;5-\u0026gt;2-\u0026gt;4-\u0026gt;3. // Related Topics 链表 // 👍 525 👎 0 /* * 143 重排链表 * 2021-03-04 16:04:59 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: //1. 使用快慢指针来找到链表的中点，并将链表从中点处断开，形成两个独立的链表。 //2. 将第二个链翻转。 //3. 将第二个链表的元素间隔地插入第一个链表中。 void reorderList(ListNode* head) { if (!head || !head-\u0026gt;next || !head-\u0026gt;next-\u0026gt;next) return; ListNode *fast = head, *slow = head; while (fast-\u0026gt;next \u0026amp;\u0026amp; fast-\u0026gt;next-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } ListNode *mid = slow-\u0026gt;next; slow-\u0026gt;next = nullptr; ListNode *last = mid, *pre = nullptr; while (last) { ListNode *next = last-\u0026gt;next; last-\u0026gt;next = pre; pre = last; last = next; } while (head \u0026amp;\u0026amp; pre) { ListNode *next = head-\u0026gt;next; head-\u0026gt;next = pre; pre = pre-\u0026gt;next; head-\u0026gt;next-\u0026gt;next = next; head = next; } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/143%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/","summary":"//给定一个单链表 L：L0→L1→…→Ln-1→Ln ， //将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… // // 你不能只是单","title":"[143]重排链表"},{"content":"//以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返 //回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。 // // // // 示例 1： // // //输入：intervals = [[1,3],[2,6],[8,10],[15,18]] //输出：[[1,6],[8,10],[15,18]] //解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. // // // 示例 2： // // //输入：intervals = [[1,4],[4,5]] //输出：[[1,5]] //解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 // // // // 提示： // // // 1 \u0026lt;= intervals.length \u0026lt;= 104 // intervals[i].length == 2 // 0 \u0026lt;= starti \u0026lt;= endi \u0026lt;= 104 // // Related Topics 排序 数组 // 👍 822 👎 0 /* * 56 合并区间 * 2021-03-04 15:53:46 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: static bool cmp(vector\u0026lt;int\u0026gt;\u0026amp; a ,vector\u0026lt;int\u0026gt;\u0026amp; b){ return a[0] \u0026lt; b[0]; } vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; merge(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; intervals) { if(intervals.empty()) return {}; sort(intervals.begin(), intervals.end(), cmp); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; ans.push_back(intervals[0]); for(int i = 1;i \u0026lt; intervals.size();i++){ auto cur = intervals[i]; auto \u0026amp;last = ans.back(); // 这里使用引用 if(cur[0] \u0026lt;= last[1]) last[1] = max(last[1], cur[1]), cout\u0026lt;\u0026lt;last[1]\u0026lt;\u0026lt;endl; else ans.push_back(cur); } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/56%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/","summary":"//以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返 //回一个不重叠的区间数组，该数组需恰好覆盖输入中的所","title":"[56]合并区间"},{"content":"//给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 // // 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序 //列。 // // // 示例 1： // // //输入：nums = [10,9,2,5,3,7,101,18] //输出：4 //解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 // // // 示例 2： // // //输入：nums = [0,1,0,3,2,3] //输出：4 // // // 示例 3： // // //输入：nums = [7,7,7,7,7,7,7] //输出：1 // // // // // 提示： // // // 1 \u0026lt;= nums.length \u0026lt;= 2500 // -104 \u0026lt;= nums[i] \u0026lt;= 104 // // // // // 进阶： // // // 你可以设计时间复杂度为 O(n2) 的解决方案吗？ // 你能将算法的时间复杂度降低到 O(n log(n)) 吗? // // Related Topics 二分查找 动态规划 // 👍 1393 👎 0 /* * 300 最长递增子序列 * 2021-03-04 14:25:33 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int lengthOfLIS(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; dp(nums.size(), 1); int ans = 0; for(int i = 0;i \u0026lt; nums.size();i++){ for(int j = 0; j \u0026lt; i;j++){ if(nums[i] \u0026gt; nums[j]) dp[i] = max(dp[i], dp[j] + 1); } ans = max(ans, dp[i]); } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/300%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/","summary":"//给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 // // 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺","title":"[300]最长递增子序列"},{"content":"//给定一个二叉树，确定它是否是一个完全二叉树。 // // 百度百科中对完全二叉树的定义如下： // // 若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注： //第 h 层可能包含 1~ 2h 个节点。） // // // // 示例 1： // // // // 输入：[1,2,3,4,5,6] //输出：true //解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。 // // // 示例 2： // // // // 输入：[1,2,3,4,5,null,7] //输出：false //解释：值为 7 的结点没有尽可能靠向左侧。 // // // // // 提示： // // // 树中将会有 1 到 100 个结点。 // // Related Topics 树 // 👍 108 👎 0 /* * 958 二叉树的完全性检验 * 2021-03-04 14:11:13 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isCompleteTree(TreeNode* root) { queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); while(q.front() != nullptr){ auto cur = q.front();q.pop(); q.push(cur-\u0026gt;left); q.push(cur-\u0026gt;right); } while(q.size() \u0026amp;\u0026amp; q.front() == nullptr) q.pop(); return q.empty(); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/958%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%8C%E5%85%A8%E6%80%A7%E6%A3%80%E9%AA%8C/","summary":"//给定一个二叉树，确定它是否是一个完全二叉树。 // // 百度百科中对完全二叉树的定义如下： // // 若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h","title":"[958]二叉树的完全性检验"},{"content":"//给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 // // 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，po //s 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 // // 说明：不允许修改给定的链表。 // // 进阶： // // // 你是否可以使用 O(1) 空间解决此题？ // // // // // 示例 1： // // // // //输入：head = [3,2,0,-4], pos = 1 //输出：返回索引为 1 的链表节点 //解释：链表中有一个环，其尾部连接到第二个节点。 // // // 示例 2： // // // // //输入：head = [1,2], pos = 0 //输出：返回索引为 0 的链表节点 //解释：链表中有一个环，其尾部连接到第一个节点。 // // // 示例 3： // // // // //输入：head = [1], pos = -1 //输出：返回 null //解释：链表中没有环。 // // // // // 提示： // // // 链表中节点的数目范围在范围 [0, 104] 内 // -105 \u0026lt;= Node.val \u0026lt;= 105 // pos 的值为 -1 或者链表中的一个有效索引 // // Related Topics 链表 双指针 // 👍 888 👎 0 /* * 142 环形链表 II * 2021-03-04 13:46:32 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ /* f=2s （快指针每次2步，路程刚好2倍） f = s + nb (相遇时，刚好多走了n圈） 推出：s = nb 从head结点走到入环点需要走 ： a + nb， 而slow已经走了nb，那么slow再走a步就是入环点了。 如何知道slow刚好走了a步？ 从head开始，和slow指针一起走，相遇时刚好就是a步 走a+nb步一定是在环入口 第一次相遇时慢指针已经走了nb步 */ class Solution { public: ListNode *detectCycle(ListNode *head) { ListNode *slow = head, *fast = head; while (fast \u0026amp;\u0026amp; fast-\u0026gt;next) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; if (slow == fast) break; } if(!fast || !fast-\u0026gt;next) return nullptr; slow = head; while (slow != fast) { slow = slow-\u0026gt;next; fast = fast-\u0026gt;next; } return fast; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/142-ii%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii/","summary":"//给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 // // 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链","title":"[142]环形链表 II"},{"content":"//路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不 //一定经过根节点。 // // 路径和 是路径中各节点值的总和。 // // 给你一个二叉树的根节点 root ，返回其 最大路径和 。 // // // // 示例 1： // // //输入：root = [1,2,3] //输出：6 //解释：最优路径是 2 -\u0026gt; 1 -\u0026gt; 3 ，路径和为 2 + 1 + 3 = 6 // // 示例 2： // // //输入：root = [-10,9,20,null,null,15,7] //输出：42 //解释：最优路径是 15 -\u0026gt; 20 -\u0026gt; 7 ，路径和为 15 + 20 + 7 = 42 // // // // // 提示： // // // 树中节点数目范围是 [1, 3 * 104] // -1000 \u0026lt;= Node.val \u0026lt;= 1000 // // Related Topics 树 深度优先搜索 递归 // 👍 912 👎 0 /* * 124 二叉树中的最大路径和 * 2021-03-04 13:43:32 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int ans = INT_MIN; int maxPathSum(TreeNode* root) { dfs(root); return ans; } int dfs(TreeNode* root){ if(!root) return 0; int left = max(dfs(root-\u0026gt;left), 0); int right = max(dfs(root-\u0026gt;right), 0); ans = max(ans, left + right + root-\u0026gt;val); return max(left, right) + root-\u0026gt;val; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/124%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/","summary":"//路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个","title":"[124]二叉树中的最大路径和"},{"content":"//请判断一个链表是否为回文链表。 // // 示例 1: // // 输入: 1-\u0026gt;2 //输出: false // // 示例 2: // // 输入: 1-\u0026gt;2-\u0026gt;2-\u0026gt;1 //输出: true // // // 进阶： //你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？ // Related Topics 链表 双指针 // 👍 879 👎 0 /* * 234 回文链表 * 2021-03-04 12:48:36 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution2 { public: bool isPalindrome(ListNode* head) { if(!head || !head-\u0026gt;next) return true; stack\u0026lt;int\u0026gt; stk; auto ptr = head; while(ptr){ stk.push(ptr-\u0026gt;val); ptr = ptr-\u0026gt;next; } while(head){ if(head-\u0026gt;val == stk.top()) head = head-\u0026gt;next, stk.pop(); else return false; } return true; } }; class Solution { public: bool isPalindrome(ListNode* head) { if(!head || !head-\u0026gt;next) return false; auto slow = head, fast = head; while(fast-\u0026gt;next \u0026amp;\u0026amp; fast-\u0026gt;next-\u0026gt;next){ slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } auto last = slow-\u0026gt;next , pre = head; while(last-\u0026gt;next){ auto temp = last-\u0026gt;next; last-\u0026gt;next = temp-\u0026gt;next; temp-\u0026gt;next = slow-\u0026gt;next; slow-\u0026gt;next = temp; } while(slow-\u0026gt;next){ slow = slow-\u0026gt;next; if(pre-\u0026gt;val != slow-\u0026gt;val) return false; pre = pre-\u0026gt;next; } return true; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/","summary":"//请判断一个链表是否为回文链表。 // // 示例 1: // // 输入: 1-\u0026gt;2 //输出: false // // 示例 2: // // 输入: 1-\u0026gt;2-\u0026gt;2-\u0026gt;1 //输出: true // // // 进阶： //你能否用 O(n) 时间复杂度和","title":"[234]回文链表"},{"content":"//给你一个由 \u0026#39;1\u0026#39;（陆地）和 \u0026#39;0\u0026#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 // // 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。 // // 此外，你可以假设该网格的四条边均被水包围。 // // // // 示例 1： // // //输入：grid = [ // [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], // [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], // [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], // [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;] //] //输出：1 // // // 示例 2： // // //输入：grid = [ // [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], // [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], // [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], // [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;] //] //输出：3 // // // // // 提示： // // // m == grid.length // n == grid[i].length // 1 \u0026lt;= m, n \u0026lt;= 300 // grid[i][j] 的值为 \u0026#39;0\u0026#39; 或 \u0026#39;1\u0026#39; // // Related Topics 深度优先搜索 广度优先搜索 并查集 // 👍 1007 👎 0 /* * 200 岛屿数量 * 2021-03-04 12:40:11 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { if (grid.empty() || grid[0].empty()) return 0; int m = grid.size(), n = grid[0].size(), res = 0; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(m, vector\u0026lt;bool\u0026gt;(n)); for (int i = 0; i \u0026lt; m; ++i) { for (int j = 0; j \u0026lt; n; ++j) { if (grid[i][j] == \u0026#39;0\u0026#39; || visited[i][j]) continue; helper(grid, visited, i, j); ++res; } } return res; } int dx[4] = {-1, 0, 1, 0}; int dy[4] = {0, 1, 0, -1}; void helper(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;\u0026amp; visited, int x, int y) { if (x \u0026lt; 0 || x \u0026gt;= grid.size() || y \u0026lt; 0 || y \u0026gt;= grid[0].size() || grid[x][y] == \u0026#39;0\u0026#39; || visited[x][y]) return; visited[x][y] = true; for(int i = 0; i \u0026lt; 4;i++){ helper(grid, visited, x + dx[i], y + dy[i]); } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/200%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/","summary":"//给你一个由 \u0026#39;1\u0026#39;（陆地）和 \u0026#39;0\u0026#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 // // 岛屿总是被水包围，","title":"[200]岛屿数量"},{"content":"//给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 // // // // 进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案吗？ // // // // 示例 1： // // //输入：nums = [1,2,0] //输出：3 // // // 示例 2： // // //输入：nums = [3,4,-1,1] //输出：2 // // // 示例 3： // // //输入：nums = [7,8,9,11,12] //输出：1 // // // // // 提示： // // // 0 \u0026lt;= nums.length \u0026lt;= 300 // -231 \u0026lt;= nums[i] \u0026lt;= 231 - 1 // // Related Topics 数组 // 👍 976 👎 0 /* * 41 缺失的第一个正数 * 2021-03-04 12:17:27 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int firstMissingPositive(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); // result must be in [1...n] // if(the node k belong to [1..n], then places it at position k - 1 for(int i = 0;i \u0026lt; n;i++){ while(nums[i] \u0026gt; 0 \u0026amp;\u0026amp; nums[i] \u0026lt;= n \u0026amp;\u0026amp; nums[nums[i] - 1] != nums[i]) swap(nums[i], nums[nums[i] - 1]); } for(int i = 0;i \u0026lt; n;i++){ if(nums[i] != i + 1) return i + 1; } return n + 1; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/41%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/","summary":"//给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 // // // // 进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方","title":"[41]缺失的第一个正数"},{"content":"//给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 // // 叶子节点 是指没有子节点的节点。 // // // // // // 示例 1： // // //输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22 //输出：[[5,4,11,2],[5,8,4,5]] // // // 示例 2： // // //输入：root = [1,2,3], targetSum = 5 //输出：[] // // // 示例 3： // // //输入：root = [1,2], targetSum = 0 //输出：[] // // // // // 提示： // // // 树中节点总数在范围 [0, 5000] 内 // -1000 \u0026lt;= Node.val \u0026lt;= 1000 // -1000 \u0026lt;= targetSum \u0026lt;= 1000 // // // // Related Topics 树 深度优先搜索 // 👍 435 👎 0 /* * 113 路径总和 II * 2021-03-04 12:04:31 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; path; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pathSum(TreeNode* root, int targetSum) { if(!root) return ans; dfs(root, targetSum); return ans; } void dfs(TreeNode* root, int targetSum){ if(!root) return ; targetSum -= root-\u0026gt;val; path.push_back(root-\u0026gt;val); if(!root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right \u0026amp;\u0026amp; targetSum == 0){ ans.push_back(path); } dfs(root-\u0026gt;left, targetSum); dfs(root-\u0026gt;right ,targetSum); path.pop_back(); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-ii/","summary":"//给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 // // 叶子节点 是指没有子节点的节点。 // // //","title":"[113]路径总和 II"},{"content":"冒泡排序 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void bubblesort(vector\u0026lt;int\u0026gt;\u0026amp; nums){ int n = nums.size(); for(int i = n - 1;i \u0026gt; 0;i--){ for(int j = 0;j \u0026lt; i;j++){ if(nums[j] \u0026gt; nums[j+1]) swap(nums[j], nums[j+1]); } } } int main(){ vector\u0026lt;int\u0026gt; nums(10); srand(unsigned(time(0))); // srand((unsigned)time(NULL)) 也可以 for(int i = 0;i \u0026lt; 10;i++){ nums[i] = rand() % 20; cout\u0026lt;\u0026lt;nums[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; bubblesort(nums); for(auto x : nums) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; return 0; } 选择排序 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void selectsort(vector\u0026lt;int\u0026gt;\u0026amp; nums){ for(int i = 0;i \u0026lt; nums.size() - 1;i++){ int min = i; for(int j = i + 1;j \u0026lt; nums.size();j++){ if(nums[j] \u0026lt; nums[min]) min = j; } swap(nums[min], nums[i]); } } int main(){ vector\u0026lt;int\u0026gt; nums(10); srand(unsigned(time(0))); for(int i = 0;i \u0026lt; 10;i++){ nums[i] = rand() % 20; cout\u0026lt;\u0026lt;nums[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; selectsort(nums); for(auto x : nums) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; return 0; } 插入排序 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void insertsort(vector\u0026lt;int\u0026gt;\u0026amp; nums){ for(int i = 1;i \u0026lt; nums.size();i++){ int t = nums[i], j; for(j = i -1 ;j \u0026gt;= 0;j--){ if(nums[j] \u0026gt; t){ nums[j+1] = nums[j]; }else{ break; } } nums[j + 1] = t; } } int main(){ vector\u0026lt;int\u0026gt; nums(10); srand(unsigned(time(0))); for(int i = 0;i \u0026lt; 10;i++){ nums[i] = rand() % 20; cout\u0026lt;\u0026lt;nums[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; insertsort(nums); for(auto x : nums) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; return 0; } 希尔排序 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void shellsort(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int length = nums.size(); int h = 1; while (h \u0026lt; length / 3) { h = 3 * h + 1; } int cnt = 0; while (h \u0026gt;= 1) { // 希尔排序大的关键就是每次一个节点都向前移动h步长，这样可以更快的接近自己的目标位置，从而获得较好的时间复杂度 // 这里的i是[h...end], h是[j, i] for (int i = h; i \u0026lt; length; i++) { cout\u0026lt;\u0026lt;h\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;endl; for (int j = i; j \u0026gt;= h \u0026amp;\u0026amp; nums[j] \u0026lt; nums[j - h]; j -= h) { //cout\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j-h\u0026lt;\u0026lt;endl; cnt++; swap(nums[j], nums[j-h]); } } h = h / 3; } cout\u0026lt;\u0026lt;\u0026#34;Time O(\u0026#34;; cout\u0026lt;\u0026lt;((double)cnt / length )\u0026lt;\u0026lt;\u0026#34;)\u0026#34;\u0026lt;\u0026lt;endl; } int main(){ const int n = 100; vector\u0026lt;int\u0026gt; nums(n); srand(unsigned(time(0))); for(int i = 0;i \u0026lt; n;i++){ nums[i] = rand() % 20; cout\u0026lt;\u0026lt;nums[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; shellsort(nums); for(auto x : nums) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; return 0; } 归并排序 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int n = 10; int aux[n]; void merge(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int mid, int right){ int i = left, j = mid + 1; for(int k = left;k \u0026lt;= right;k++) aux[k] = nums[k]; for(int k = left;k \u0026lt;= right;k++){ if(i \u0026gt; mid) nums[k] = aux[j++]; else if(j \u0026gt; right) nums[k] = aux[i++]; // 互斥关系，必须使用else if else if(aux[i] \u0026gt; aux[j]) nums[k] = aux[j++]; else nums[k] = aux[i++]; } } void mergesort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right){ if(left \u0026gt;= right) return ; int mid = (right - left) / 2 + left; mergesort(nums, left, mid); mergesort(nums, mid + 1, right); merge(nums, left, mid, right); } int main(){ vector\u0026lt;int\u0026gt; nums(n); srand(unsigned(time(0))); for(int i = 0;i \u0026lt; n;i++){ nums[i] = rand() % 20; cout\u0026lt;\u0026lt;nums[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; mergesort(nums, 0, nums.size() - 1); for(auto x : nums) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; return 0; } 快速排序 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; const int n = 10; int partition(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right){ int pivot = left; int i = left; int j = right + 1; while(true){ while(nums[++i] \u0026lt; nums[pivot]) if(i == right) break; while(nums[--j] \u0026gt; nums[pivot]) if(j == left) break; if(i \u0026gt;= j) break; swap(nums[i], nums[j]); } swap(nums[pivot], nums[j]); return j; } void quicksort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right){ if(left \u0026gt;= right) return ; int j = partition(nums, left, right); quicksort(nums, left, j-1); quicksort(nums, j+1, right); } int main(){ vector\u0026lt;int\u0026gt; nums(n); srand(unsigned(time(0))); for(int i = 0;i \u0026lt; n;i++){ nums[i] = rand() % 20; cout\u0026lt;\u0026lt;nums[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; quicksort(nums, 0, nums.size() - 1); for(auto x : nums) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; return 0; } 堆排序 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void heapify(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right){ int dad = left; int son = dad * 2 + 1; while(son \u0026lt;= right){ if(son + 1 \u0026lt;= right \u0026amp;\u0026amp; nums[son + 1] \u0026gt; nums[son]){ son = son + 1; } if(nums[dad] \u0026gt; nums[son]){ return ; }else{ swap(nums[dad], nums[son]); dad = son; son = dad * 2 + 1; } } } void heapsort(vector\u0026lt;int\u0026gt;\u0026amp; nums, int left, int right){ for(int i = right / 2;i \u0026gt;= 0;i--){ heapify(nums, i, right); } for(int i = right;i \u0026gt;= 0;i--){ swap(nums[i], nums[0]); heapify(nums, 0, i - 1); } } int main(){ int n = 10; vector\u0026lt;int\u0026gt; nums(n); srand(unsigned(time(0))); for(int i = 0;i \u0026lt; n;i++){ nums[i] = rand() % 20; cout\u0026lt;\u0026lt;nums[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; heapsort(nums, 0, nums.size() - 1); for(auto x : nums) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;; cout\u0026lt;\u0026lt;endl; return 0; } ","permalink":"https://oxygenbytes.github.io/posts/algorithms/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","summary":"冒泡排序 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; void bubblesort(vector\u0026lt;int\u0026gt;\u0026amp; nums){ int n = nums.size(); for(int i = n - 1;i \u0026gt; 0;i--){ for(int j = 0;j \u0026lt; i;j++){ if(nums[j] \u0026gt; nums[j+1]) swap(nums[j], nums[j+1]); } } } int main(){ vector\u0026lt;int\u0026gt; nums(10); srand(unsigned(time(0))); // srand((unsigned)time(NULL)) 也可以 for(int i = 0;i \u0026lt; 10;i++){ nums[i] = rand() % 20; cout\u0026lt;\u0026lt;nums[i]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; bubblesort(nums); for(auto x : nums) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;;","title":"排序算法"},{"content":"时间比较久了，重点记一下算法题和答的不好的问题\n一面 算法题：实现整数的sqrt函数， 使用二分法做 二面 算法题：算法题找出一个数组中，出现次数最多的两个数 我最开始用unordered_map, 后来面试官说空间复杂度可以优化，时间复杂度也可以优化，最后尝试写了一个0（n）的算法\n2：问了一下http头部有什么字段，我只说了最常见的三五个，因为没仔细记忆过\n","permalink":"https://oxygenbytes.github.io/posts/interview/%E8%93%9D%E6%B9%96%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/","summary":"时间比较久了，重点记一下算法题和答的不好的问题 一面 算法题：实现整数的sqrt函数， 使用二分法做 二面 算法题：算法题找出一个数组中，出现次数最多","title":"蓝湖面试复盘"},{"content":"//给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 // // 不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。 // // // // 示例 1: // // 给定数组 nums = [1,1,2], // //函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 // //你不需要考虑数组中超出新长度后面的元素。 // // 示例 2: // // 给定 nums = [0,0,1,1,1,2,2,3,3,4], // //函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。 // //你不需要考虑数组中超出新长度后面的元素。 // // // // // 说明: // // 为什么返回数值是整数，但输出的答案是数组呢? // // 请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。 // // 你可以想象内部操作如下: // // // nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝 //int len = removeDuplicates(nums); // //// 在函数里修改输入数组对于调用者是可见的。 //// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。 //for (int i = 0; i \u0026lt; len; i++) { // print(nums[i]); //} // // Related Topics 数组 双指针 // 👍 1866 👎 0 /* * 26 删除排序数组中的重复项 * 2021-03-03 15:19:19 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution2 { public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { return unique(nums.begin(), nums.end()) - nums.begin(); } }; class Solution{ public: int removeDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums){ int n = nums.size(); int k = 1; for(int j = 1;j \u0026lt; nums.size();j++){ // 1* 1 2* 2 3* 3 3 4* 5* // 关注这些点的特征，这些点的共同特征就是nums[i] != nums[i-1] if(nums[j] != nums[j-1]){ nums[k++] = nums[j]; } } return k; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/26%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/","summary":"//给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 // // 不要使用额外的数组空间，你必须在 原","title":"[26]删除排序数组中的重复项"},{"content":"//给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 // // 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nu //ms2 的元素。 // // // // 示例 1： // // //输入：nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 //输出：[1,2,2,3,5,6] // // // 示例 2： // // //输入：nums1 = [1], m = 1, nums2 = [], n = 0 //输出：[1] // // // // // 提示： // // // nums1.length == m + n // nums2.length == n // 0 \u0026lt;= m, n \u0026lt;= 200 // 1 \u0026lt;= m + n \u0026lt;= 200 // -109 \u0026lt;= nums1[i], nums2[i] \u0026lt;= 109 // // Related Topics 数组 双指针 // 👍 785 👎 0 /* * 88 合并两个有序数组 * 2021-03-03 15:04:34 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: void merge(vector\u0026lt;int\u0026gt;\u0026amp; nums1, int m, vector\u0026lt;int\u0026gt;\u0026amp; nums2, int n) { int i = m - 1; int j = n - 1; int k = m + n - 1; while(i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0){ if(nums1[i] \u0026gt; nums2[j]){ nums1[k--] = nums1[i--]; }else{ nums1[k--] = nums2[j--]; } } while(j \u0026gt;= 0) nums1[k--] = nums2[j--]; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","summary":"//给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 // // 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间","title":"[88]合并两个有序数组"},{"content":"//给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 // // 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 \u0026lt;= answer[0] // \u0026lt; answer[1] \u0026lt;= numbers.length 。 // // 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。 // // // 示例 1： // // //输入：numbers = [2,7,11,15], target = 9 //输出：[1,2] //解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。 // // // 示例 2： // // //输入：numbers = [2,3,4], target = 6 //输出：[1,3] // // // 示例 3： // // //输入：numbers = [-1,0], target = -1 //输出：[1,2] // // // // // 提示： // // // 2 \u0026lt;= numbers.length \u0026lt;= 3 * 104 // -1000 \u0026lt;= numbers[i] \u0026lt;= 1000 // numbers 按 递增顺序 排列 // -1000 \u0026lt;= target \u0026lt;= 1000 // 仅存在一个有效答案 // // Related Topics 数组 双指针 二分查找 // 👍 483 👎 0 /* * 167 两数之和 II - 输入有序数组 * 2021-03-03 14:29:36 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; numbers, int target) { // i i\u0026#39; j\u0026#39; j 暴力 ==\u0026gt; 单调 ==\u0026gt; 双指针 for(int i = 0, j= numbers.size() - 1;i \u0026lt; numbers.size();i++){ while(j - 1 \u0026gt; i \u0026amp;\u0026amp; numbers[i] + numbers[j] \u0026gt; target) j--; if(numbers[i] + numbers[j] == target) return {i + 1, j + 1}; } return {-1, -1}; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/167%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-ii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/","summary":"//给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 // // 函数应该以长度为 2 的整数数组的形式返回这两个数的","title":"[167]两数之和 II - 输入有序数组"},{"content":"//给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, //ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 // // 说明：你不能倾斜容器。 // // // // 示例 1： // // // // //输入：[1,8,6,2,5,4,8,3,7] //输出：49 //解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 // // 示例 2： // // //输入：height = [1,1] //输出：1 // // // 示例 3： // // //输入：height = [4,3,2,1,4] //输出：16 // // // 示例 4： // // //输入：height = [1,2,1] //输出：2 // // // // // 提示： // // // n = height.length // 2 \u0026lt;= n \u0026lt;= 3 * 104 // 0 \u0026lt;= height[i] \u0026lt;= 3 * 104 // // Related Topics 数组 双指针 // 👍 2231 👎 0 /* * 11 盛最多水的容器 * 2021-03-02 09:07:12 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: // 一句话解释就是说矮柱子选取后如果移动高柱子的话面积是一定会减小的 // 因为长度距离在变小的时候，此时高度只能小于或等于矮的柱子。 // 因此只能移动矮的柱子这边才有可能使得高度比矮柱子大 int maxArea(vector\u0026lt;int\u0026gt;\u0026amp; height) { int ans = 0, i = 0, j = height.size() - 1; while(i \u0026lt; j){ // 双指针算法，暴力 ==\u0026gt; 单调性 ==\u0026gt; 优化 ans = max(ans, min(height[i], height[j]) * (j - i)); height[i] \u0026lt; height[j] ? i++ : j--; } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/11%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/","summary":"//给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, //ai) 和 (i, 0) 。找出其","title":"[11]盛最多水的容器"},{"content":"//给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 // // // // 示例 1： // // // // //输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] //输出：6 //解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 // // // 示例 2： // // //输入：height = [4,2,0,3,2,5] //输出：9 // // // // // 提示： // // // n == height.length // 0 \u0026lt;= n \u0026lt;= 3 * 104 // 0 \u0026lt;= height[i] \u0026lt;= 105 // // Related Topics 栈 数组 双指针 动态规划 // 👍 2081 👎 0 /* * 42 接雨水 * 2021-03-02 09:06:31 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int trap(vector\u0026lt;int\u0026gt;\u0026amp; height) { if(height.empty()) return 0; int n = height.size(); int left = 0, right = n - 1; int ans = 0; int l_max = height[0]; // height[0,,left] 最高柱子 int r_max = height[n-1]; // height[right,end] 最高柱子 while(left \u0026lt;= right){ l_max = max(l_max, height[left]); r_max = max(r_max, height[right]); if(l_max \u0026lt; r_max){ // 此时[right,end]的高度不是短板，不影响left处水的高度 ans += l_max - height[left]; left++; }else{ ans += r_max - height[right]; right--; } } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/42%E6%8E%A5%E9%9B%A8%E6%B0%B4/","summary":"//给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 // // // // 示例 1： // // // // //输入：height","title":"[42]接雨水"},{"content":"//给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 // // // // 示例 1： // // //输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] //输出：[1,2,3,6,9,8,7,4,5] // // // 示例 2： // // //输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] //输出：[1,2,3,4,8,12,11,10,9,5,6,7] // // // // // 提示： // // // m == matrix.length // n == matrix[i].length // 1 \u0026lt;= m, n \u0026lt;= 10 // -100 \u0026lt;= matrix[i][j] \u0026lt;= 100 // // Related Topics 数组 // 👍 620 👎 0 /* * 54 螺旋矩阵 * 2021-03-01 14:33:36 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;int\u0026gt; spiralOrder(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { if(matrix.empty() || matrix[0].empty()) return {}; int m = matrix.size(); int n = matrix[0].size(); vector\u0026lt;int\u0026gt; ans; int d = 1; int i = 0, j = 0; int dx[4] = {-1, 0, 1, 0}; int dy[4] = {0, 1, 0, -1}; for(int k = 0;k \u0026lt; m * n;k++){ ans.push_back(matrix[i][j]); matrix[i][j] = 0; int a = i + dx[d]; int b = j + dy[d]; if(a \u0026lt; 0 || a \u0026gt;= m || b \u0026lt; 0 || b \u0026gt;= n || matrix[a][b] == 0){ d = (d + 1) % 4; a = i + dx[d]; b = j + dy[d]; } i = a, j = b; } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/54%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/","summary":"//给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 // // // // 示例 1： // // //输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] //输出：[1,2,","title":"[54]螺旋矩阵"},{"content":"//给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 // // 示例: // // 输入: [1,2,3,null,5,null,4] //输出: [1, 3, 4] //解释: // // 1 \u0026lt;--- // / \\ //2 3 \u0026lt;--- // \\ \\ // 5 4 \u0026lt;--- // // Related Topics 树 深度优先搜索 广度优先搜索 递归 队列 // 👍 412 👎 0 /* * 199 二叉树的右视图 * 2021-03-01 14:17:44 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; rightSideView(TreeNode* root) { if(!root) return {}; queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); vector\u0026lt;int\u0026gt; ans; while(q.size()){ ans.push_back(q.back()-\u0026gt;val); int n = q.size(); for(int i = n - 1;i \u0026gt;= 0;i--){ auto ptr = q.front();q.pop(); if(ptr-\u0026gt;left) q.push(ptr-\u0026gt;left); if(ptr-\u0026gt;right) q.push(ptr-\u0026gt;right); } } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/199%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/","summary":"//给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 // // 示例: // // 输入: [1,2,3,null,5,null,4] //输出: [1, 3, 4] //解释","title":"[199]二叉树的右视图"},{"content":"//已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。 // // 不要使用系统的 Math.random() 方法。 // // // // // // // 示例 1: // // //输入: 1 //输出: [7] // // // 示例 2: // // //输入: 2 //输出: [8,4] // // // 示例 3: // // //输入: 3 //输出: [8,1,10] // // // // // 提示: // // // rand7 已定义。 // 传入参数: n 表示 rand10 的调用次数。 // // // // // 进阶: // // // rand7()调用次数的 期望值 是多少 ? // 你能否尽量少调用 rand7() ? // // Related Topics Random Rejection Sampling // 👍 153 👎 0 /* * 470 用 Rand7() 实现 Rand10() * 2021-03-01 14:00:36 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) // The rand7() API is already defined for you. // int rand7(); // @return a random integer in the range 1 to 7 int rand7(); class Solution { public: int rand10() { while(true){ int num = (rand7() - 1) * 7 + rand7(); if(num \u0026lt;= 40) return num % 10 + 1; } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/470%E7%94%A8-rand7-%E5%AE%9E%E7%8E%B0-rand10/","summary":"//已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。 // // 不要使用系统的 Math.random() 方法。 // // // // // // // 示例 1:","title":"[470]用 Rand7() 实现 Rand10()"},{"content":"//给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。 // // 找到所有出现两次的元素。 // // 你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？ // // 示例： // // //输入: //[4,3,2,7,8,2,3,1] // //输出: //[2,3] // // Related Topics 数组 // 👍 342 👎 0 /* * 442 数组中重复的数据 * 2021-03-01 13:20:20 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;int\u0026gt; findDuplicates(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.size() \u0026lt; 2) return {}; int n = nums.size(); vector\u0026lt;int\u0026gt; ans; // 使用数组进行原地hash for(int i = 0;i \u0026lt; nums.size();i++){ nums[(nums[i]- 1) % n] += n; } for(int i = 0;i \u0026lt; nums.size();i++){ if(nums[i] \u0026gt; 2 * n){ ans.push_back(i + 1); } } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/442%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE/","summary":"//给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。 // // 找到所有出现两次的元素。 // // 你可以不用到","title":"[442]数组中重复的数据"},{"content":"//给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。 // // 有效 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 \u0026#39;.\u0026#39; 分隔。 // // 例如：\u0026#34;0.1.2.201\u0026#34; 和 \u0026#34;192.168.1.1\u0026#34; 是 有效 IP 地址，但是 \u0026#34;0.011.255.245\u0026#34;、\u0026#34;192.168.1.312\u0026#34; //和 \u0026#34;192.168@1.1\u0026#34; 是 无效 IP 地址。 // // // // 示例 1： // // //输入：s = \u0026#34;25525511135\u0026#34; //输出：[\u0026#34;255.255.11.135\u0026#34;,\u0026#34;255.255.111.35\u0026#34;] // // // 示例 2： // // //输入：s = \u0026#34;0000\u0026#34; //输出：[\u0026#34;0.0.0.0\u0026#34;] // // // 示例 3： // // //输入：s = \u0026#34;1111\u0026#34; //输出：[\u0026#34;1.1.1.1\u0026#34;] // // // 示例 4： // // //输入：s = \u0026#34;010010\u0026#34; //输出：[\u0026#34;0.10.0.10\u0026#34;,\u0026#34;0.100.1.0\u0026#34;] // // // 示例 5： // // //输入：s = \u0026#34;101023\u0026#34; //输出：[\u0026#34;1.0.10.23\u0026#34;,\u0026#34;1.0.102.3\u0026#34;,\u0026#34;10.1.0.23\u0026#34;,\u0026#34;10.10.2.3\u0026#34;,\u0026#34;101.0.2.3\u0026#34;] // // // // // 提示： // // // 0 \u0026lt;= s.length \u0026lt;= 3000 // s 仅由数字组成 // // Related Topics 字符串 回溯算法 // 👍 511 👎 0 /* * 93 复原 IP 地址 * 2021-03-01 11:39:13 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;string\u0026gt; ans; string path; vector\u0026lt;string\u0026gt; restoreIpAddresses(string s) { if(s.empty() || s.size() \u0026gt; 12) return {}; dfs(s, 0, 0); return ans; } void dfs(string\u0026amp; s, int idx, int cnt){ if(cnt == 4 \u0026amp;\u0026amp; idx \u0026gt;= s.size()){ ans.push_back(path); return ; } for(int len = 1;len \u0026lt;= 3 \u0026amp;\u0026amp; idx + len \u0026lt;= s.size();len++){ string cur = s.substr(idx, len); if(cur.size() \u0026gt; 1 \u0026amp;\u0026amp; cur[0] == \u0026#39;0\u0026#39;) continue; // 一个0是可以的 int num = stoi(cur); if(num \u0026gt;= 0 \u0026amp;\u0026amp; num \u0026lt;= 255){ string temp = path; path += s.substr(idx, len); if(idx + len != s.size()) path += \u0026#39;.\u0026#39;; dfs(s, idx + len, cnt + 1); path = temp; } } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/93%E5%A4%8D%E5%8E%9F-ip-%E5%9C%B0%E5%9D%80/","summary":"//给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。 // // 有效 IP 地址 正好由四个整数","title":"[93]复原 IP 地址"},{"content":"//给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 // // 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 // // // // 示例 1： // // //输入：head = [1,2,3,4] //输出：[2,1,4,3] // // // 示例 2： // // //输入：head = [] //输出：[] // // // 示例 3： // // //输入：head = [1] //输出：[1] // // // // // 提示： // // // 链表中节点的数目在范围 [0, 100] 内 // 0 \u0026lt;= Node.val \u0026lt;= 100 // // // // // 进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。） // Related Topics 递归 链表 // 👍 832 👎 0 /* * 24 两两交换链表中的节点 * 2021-03-01 10:53:56 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { if(!head || !head-\u0026gt;next) return head; auto newHead = head-\u0026gt;next; head-\u0026gt;next = swapPairs(newHead-\u0026gt;next); newHead-\u0026gt;next = head; return newHead; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/24-ii%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","summary":"//给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 // // 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 // // // // 示例","title":"[24]两两交换链表中的节点"},{"content":"//运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。 // // // // 实现 LRUCache 类： // // // LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 // int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。 // void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上 //限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 // // // // // // // 进阶：你是否可以在 O(1) 时间复杂度内完成这两种操作？ // // // // 示例： // // //输入 //[\u0026#34;LRUCache\u0026#34;, \u0026#34;put\u0026#34;, \u0026#34;put\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;put\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;put\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;get\u0026#34;, \u0026#34;get\u0026#34;] //[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] //输出 //[null, null, null, 1, null, -1, null, -1, 3, 4] // //解释 //LRUCache lRUCache = new LRUCache(2); //lRUCache.put(1, 1); // 缓存是 {1=1} //lRUCache.put(2, 2); // 缓存是 {1=1, 2=2} //lRUCache.get(1); // 返回 1 //lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3} //lRUCache.get(2); // 返回 -1 (未找到) //lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3} //lRUCache.get(1); // 返回 -1 (未找到) //lRUCache.get(3); // 返回 3 //lRUCache.get(4); // 返回 4 // // // // // 提示： // // // 1 \u0026lt;= capacity \u0026lt;= 3000 // 0 \u0026lt;= key \u0026lt;= 3000 // 0 \u0026lt;= value \u0026lt;= 104 // 最多调用 3 * 104 次 get 和 put // // Related Topics 设计 // 👍 1200 👎 0 /* * 146 LRU 缓存机制 * 2021-03-01 10:50:42 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class LRUCache { public: LRUCache(int capacity) { this-\u0026gt;capacity = capacity; } int get(int key) { if(mp.find(key) == mp.end()) return -1; put(key, mp[key]-\u0026gt;second); return mp[key]-\u0026gt;second; } void put(int key, int value) { if(mp.find(key) != mp.end()){ recent.erase(mp[key]); }else if(capacity == mp.size()){ mp.erase(recent.back().first); recent.pop_back(); } recent.push_front(make_pair(key, value)); mp[key] = recent.begin(); } private: int capacity; list\u0026lt;pair\u0026lt;int, int\u0026gt;\u0026gt; recent; unordered_map\u0026lt;int, list\u0026lt;pair\u0026lt;int,int\u0026gt;\u0026gt;::iterator\u0026gt; mp; }; /** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-\u0026gt;get(key); * obj-\u0026gt;put(key,value); */ //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/146lru-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","summary":"//运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。 // // // // 实现 LRUCache 类： // // // LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 // int get(int key) 如果","title":"[146]LRU 缓存机制"},{"content":"//给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 // // 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 // // // // 示例 1： // // //输入：nums = [1,2,3] //输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] // // // 示例 2： // // //输入：nums = [0] //输出：[[],[0]] // // // // // 提示： // // // 1 \u0026lt;= nums.length \u0026lt;= 10 // -10 \u0026lt;= nums[i] \u0026lt;= 10 // nums 中的所有元素 互不相同 // // Related Topics 位运算 数组 回溯算法 // 👍 1020 👎 0 /* * 78 子集 * 2021-02-28 14:12:35 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; for(int i = 0;i \u0026lt; 1 \u0026lt;\u0026lt; nums.size();i++){ vector\u0026lt;int\u0026gt; now; for(int j = 0;j \u0026lt; nums.size();j++){ if(i \u0026gt;\u0026gt; j \u0026amp; 1){ now.push_back(nums[j]); } } ans.push_back(now); } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/78-ii%E5%AD%90%E9%9B%86/","summary":"//给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 // // 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 // // //","title":"[78]子集"},{"content":"//给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 // // // // 示例 1： // // //输入：nums = [1,1,2] //输出： //[[1,1,2], // [1,2,1], // [2,1,1]] // // // 示例 2： // // //输入：nums = [1,2,3] //输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] // // // // // 提示： // // // 1 \u0026lt;= nums.length \u0026lt;= 8 // -10 \u0026lt;= nums[i] \u0026lt;= 10 // // Related Topics 回溯算法 // 👍 609 👎 0 /* * 47 全排列 II * 2021-02-28 13:16:50 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; path; vector\u0026lt;bool\u0026gt; vis; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permuteUnique(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); sort(nums.begin(), nums.end()); vis = vector\u0026lt;bool\u0026gt;(n, false); dfs(nums, 0); return ans; } void dfs(const vector\u0026lt;int\u0026gt;\u0026amp; nums, int cur){ if(cur == nums.size()){ ans.push_back(path); return ; } // 例如[1 2 2‘]可能出现[1 2 2\u0026#39;] 和[1 2‘ 2] 的情况 如果“存在前一个相同元素” 且“未被使用过”, 当现有排列是[1 2\u0026#39;]时 // 原来的数组[1 2 2‘]中2’存在前一个元素2与其相同, 且此时2未被访问过，跳过。[1 2 2\u0026#39;]的排列先于[1 2\u0026#39; 2]存在，因此可以去除。 for(int i = 0;i \u0026lt; nums.size();i++){ if(!vis[i]){ vis[i] = true; path.push_back(nums[i]); dfs(nums, cur + 1); path.pop_back(); vis[i] = false; // [2,2\u0026#39;,3] if cur(0) == 2, then skip cur(1) while(i + 1\u0026lt; nums.size() \u0026amp;\u0026amp; nums[i] == nums[i+1]) i++; // here is while } } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/47%E5%85%A8%E6%8E%92%E5%88%97-ii/","summary":"//给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 // // // // 示例 1： // // //输入：nums = [1,1,2] //输出： //[[1,1,2], // [1,2,1], // [2,1,1]] // // // 示","title":"[47]全排列 II"},{"content":"//对链表进行插入排序。 // // //插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。 //每次迭代时，从输入数据中移除一个元素（用红色表示），并原地将其插入到已排好序的链表中。 // // // // 插入排序算法： // // // 插入排序是迭代的，每次只移动一个元素，直到所有元素可以形成一个有序的输出列表。 // 每次迭代中，插入排序只从输入数据中移除一个待排序的元素，找到它在序列中适当的位置，并将其插入。 // 重复直到所有输入数据插入完为止。 // // // // // 示例 1： // // 输入: 4-\u0026gt;2-\u0026gt;1-\u0026gt;3 //输出: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4 // // // 示例 2： // // 输入: -1-\u0026gt;5-\u0026gt;3-\u0026gt;4-\u0026gt;0 //输出: -1-\u0026gt;0-\u0026gt;3-\u0026gt;4-\u0026gt;5 // // Related Topics 排序 链表 // 👍 359 👎 0 /* * 147 对链表进行插入排序 * 2021-02-28 12:59:22 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* insertionSortList(ListNode* head) { if(!head || !head-\u0026gt;next) return head; auto dummy = new ListNode(-1); // 遍历n次，每次找到目标节点，并更新cur所在链表 auto pre = head; while(pre){ auto ptr = pre-\u0026gt;next; auto cur = dummy; while(cur-\u0026gt;next \u0026amp;\u0026amp; cur-\u0026gt;next-\u0026gt;val \u0026lt;= pre-\u0026gt;val){ cur = cur-\u0026gt;next; } pre-\u0026gt;next = cur-\u0026gt;next; cur-\u0026gt;next = pre; pre = ptr; } return dummy-\u0026gt;next; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/147%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/","summary":"//对链表进行插入排序。 // // //插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。 //每次迭代时，从输入","title":"[147]对链表进行插入排序"},{"content":"//给定一个二维网格和一个单词，找出该单词是否存在于网格中。 // // 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 // // // // 示例: // // board = //[ // [\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;E\u0026#39;], // [\u0026#39;S\u0026#39;,\u0026#39;F\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;S\u0026#39;], // [\u0026#39;A\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;E\u0026#39;,\u0026#39;E\u0026#39;] //] // //给定 word = \u0026#34;ABCCED\u0026#34;, 返回 true //给定 word = \u0026#34;SEE\u0026#34;, 返回 true //给定 word = \u0026#34;ABCB\u0026#34;, 返回 false // // // // 提示： // // // board 和 word 中只包含大写和小写英文字母。 // 1 \u0026lt;= board.length \u0026lt;= 200 // 1 \u0026lt;= board[i].length \u0026lt;= 200 // 1 \u0026lt;= word.length \u0026lt;= 10^3 // // Related Topics 数组 回溯算法 // 👍 796 👎 0 /* * 79 单词搜索 * 2021-02-28 11:18:06 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int n, m; bool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string word) { m = board.size(); n = board[0].size(); if(word.empty()) return true; if(board.empty() || board[0].empty()) return false; for(int i = 0;i \u0026lt; m;i++){ for(int j = 0; j \u0026lt; n;j++){ if(board[i][j] == word[0]){ if(dfs(board,word, i, j, 0)) return true; } } } return false; } bool dfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board,string\u0026amp; word, int x, int y, int cur){ if(board[x][y] != word[cur]) return false; // 比较最后一个字符后，再根据cur判断 if(cur == word.size() - 1) return true; int dx[4] = {-1, 0, 1, 0}; int dy[4] = {0, 1, 0, -1}; board[x][y] = \u0026#39;.\u0026#39;; // 不回溯 for(int i = 0;i \u0026lt; 4;i++){ int a = x + dx[i]; int b = y + dy[i]; if(a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; m \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; n){ if(dfs(board, word, a, b, cur + 1)){ return true; } } } board[x][y] = word[cur]; return false; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/79%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/","summary":"//给定一个二维网格和一个单词，找出该单词是否存在于网格中。 // // 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些","title":"[79]单词搜索"},{"content":"//给定一个字符串，逐个翻转字符串中的每个单词。 // // 说明： // // // 无空格字符构成一个 单词 。 // 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 // 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 // // // // // 示例 1： // // 输入：\u0026#34;the sky is blue\u0026#34; //输出：\u0026#34;blue is sky the\u0026#34; // // // 示例 2： // // 输入：\u0026#34; hello world! \u0026#34; //输出：\u0026#34;world! hello\u0026#34; //解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 // // // 示例 3： // // 输入：\u0026#34;a good example\u0026#34; //输出：\u0026#34;example good a\u0026#34; //解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 // // // 示例 4： // // 输入：s = \u0026#34; Bob Loves Alice \u0026#34; //输出：\u0026#34;Alice Loves Bob\u0026#34; // // // 示例 5： // // 输入：s = \u0026#34;Alice does not even like bob\u0026#34; //输出：\u0026#34;bob like even not does Alice\u0026#34; // // // // // 提示： // // // 1 \u0026lt;= s.length \u0026lt;= 104 // s 包含英文大小写字母、数字和空格 \u0026#39; \u0026#39; // s 中 至少存在一个 单词 // // // // // // // // 进阶： // // // 请尝试使用 O(1) 额外空间复杂度的原地解法。 // // Related Topics 字符串 // 👍 282 👎 0 /* * 151 翻转字符串里的单词 * 2021-02-27 15:59:32 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: string reverseWords(string s) { int k = 0; for(int i = 0;i \u0026lt; s.size();i++){ while(i \u0026lt; s.size() \u0026amp;\u0026amp; s[i] == \u0026#39; \u0026#39;) i ++; if(i == s.size()) break; int j = i; while(j \u0026lt; s.size() \u0026amp;\u0026amp; s[j] != \u0026#39; \u0026#39;) j++; reverse(s.begin() + i, s.begin() + j); if(k) s[k++] = \u0026#39; \u0026#39;; while(i \u0026lt; j) s[k ++] = s[i ++]; } s.erase(s.begin() + k, s.end()); reverse(s.begin(), s.end()); return s; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/151%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/","summary":"//给定一个字符串，逐个翻转字符串中的每个单词。 // // 说明： // // // 无空格字符构成一个 单词 。 // 输入字符串可以在前面或者后面包含多余的空格，但是反","title":"[151]翻转字符串里的单词"},{"content":"//给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 // // 示例: // // 输入: [\u0026#34;eat\u0026#34;, \u0026#34;tea\u0026#34;, \u0026#34;tan\u0026#34;, \u0026#34;ate\u0026#34;, \u0026#34;nat\u0026#34;, \u0026#34;bat\u0026#34;] //输出: //[ // [\u0026#34;ate\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;], // [\u0026#34;nat\u0026#34;,\u0026#34;tan\u0026#34;], // [\u0026#34;bat\u0026#34;] //] // // 说明： // // // 所有输入均为小写字母。 // 不考虑答案输出的顺序。 // // Related Topics 哈希表 字符串 // 👍 668 👎 0 /* * 49 字母异位词分组 * 2021-02-27 15:40:55 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; groupAnagrams(vector\u0026lt;string\u0026gt;\u0026amp; strs) { unordered_map\u0026lt;string, vector\u0026lt;string\u0026gt;\u0026gt; mp; for(int i = 0;i \u0026lt; strs.size();i++){ string str = strs[i]; sort(str.begin(), str.end()); mp[str].push_back(strs[i]); } vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; ans; for(auto item : mp) ans.push_back(item.second); return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/49%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/","summary":"//给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 // // 示例: // // 输入: [\u0026#34;eat\u0026#34;, \u0026#34;tea\u0026#34;, \u0026#34;tan\u0026#34;, \u0026#34;ate\u0026#34;, \u0026#34;nat\u0026#34;, \u0026#34;bat\u0026#34;] //输出: //[ // [\u0026#34;ate\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;], //","title":"[49]字母异位词分组"},{"content":"//给定一个正整数 n ，输出外观数列的第 n 项。 // // 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。 // // 你可以将其视作是由递归公式定义的数字字符串序列： // // // countAndSay(1) = \u0026#34;1\u0026#34; // countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。 // // // 前五项如下： // // //1. 1 //2. 11 //3. 21 //4. 1211 //5. 111221 //第一项是数字 1 //描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 \u0026#34;11\u0026#34; //描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 \u0026#34;21\u0026#34; //描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 \u0026#34;1211\u0026#34; //描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 \u0026#34;111221\u0026#34; // // // 要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成 //一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。 // // 例如，数字字符串 \u0026#34;3322251\u0026#34; 的描述如下图： // // // // // // // 示例 1： // // //输入：n = 1 //输出：\u0026#34;1\u0026#34; //解释：这是一个基本样例。 // // // 示例 2： // // //输入：n = 4 //输出：\u0026#34;1211\u0026#34; //解释： //countAndSay(1) = \u0026#34;1\u0026#34; //countAndSay(2) = 读 \u0026#34;1\u0026#34; = 一 个 1 = \u0026#34;11\u0026#34; //countAndSay(3) = 读 \u0026#34;11\u0026#34; = 二 个 1 = \u0026#34;21\u0026#34; //countAndSay(4) = 读 \u0026#34;21\u0026#34; = 一 个 2 + 一 个 1 = \u0026#34;12\u0026#34; + \u0026#34;11\u0026#34; = \u0026#34;1211\u0026#34; // // // // // 提示： // // // 1 \u0026lt;= n \u0026lt;= 30 // // Related Topics 字符串 // 👍 644 👎 0 /* * 38 外观数列 * 2021-02-27 15:19:34 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: string countAndSay(int n) { string s = \u0026#34;1\u0026#34;; for(int i = 0;i \u0026lt; n - 1;i++){ string temp; for(int j = 0;j \u0026lt; s.size();j++){ int k = j; while(k \u0026lt; s.size() \u0026amp;\u0026amp; s[k] == s[j]) k++; temp += to_string(k - j) + s[j]; j = k - 1; // after this line , will do i++ } s = temp; } return s; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/38%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/","summary":"//给定一个正整数 n ，输出外观数列的第 n 项。 // // 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。 // // 你可以将其视","title":"[38]外观数列"},{"content":"//数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 // // // // 示例 1： // // //输入：n = 3 //输出：[\u0026#34;((()))\u0026#34;,\u0026#34;(()())\u0026#34;,\u0026#34;(())()\u0026#34;,\u0026#34;()(())\u0026#34;,\u0026#34;()()()\u0026#34;] // // // 示例 2： // // //输入：n = 1 //输出：[\u0026#34;()\u0026#34;] // // // // // 提示： // // // 1 \u0026lt;= n \u0026lt;= 8 // // Related Topics 字符串 回溯算法 // 👍 1579 👎 0 /* * 22 括号生成 * 2021-02-27 14:54:20 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;string\u0026gt; ans; vector\u0026lt;string\u0026gt; generateParenthesis(int n) { dfs(n, n, \u0026#34;\u0026#34;); return ans; } void dfs(int left, int right, string s){ if(left \u0026gt; right) return ; // 是剩余数量 if(left == 0){ for(int i = 0;i \u0026lt; right;i++) s += \u0026#39;)\u0026#39;; ans.push_back(s); }else{ dfs(left -1, right, s + \u0026#39;(\u0026#39;); dfs(left, right - 1, s + \u0026#39;)\u0026#39;); } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/22%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/","summary":"//数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 // // // // 示例 1： // // //输入：n = 3 //输出：[\u0026","title":"[22]括号生成"},{"content":"//给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 // // // // 示例 : //给定二叉树 // // 1 // / \\ // 2 3 // / \\ // 4 5 // // // 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 // // // // 注意：两结点之间的路径长度是以它们之间边的数目表示。 // Related Topics 树 // 👍 621 👎 0 /* * 543 二叉树的直径 * 2021-02-27 12:08:51 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int ans = 0; int diameterOfBinaryTree(TreeNode* root) { dfs(root); return ans; } int dfs(TreeNode* root){ if(!root) return 0; int l = dfs(root-\u0026gt;left); int r = dfs(root-\u0026gt;right); ans = max(ans, l + r); return max(l, r) + 1; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/543-ii%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","summary":"//给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 // // //","title":"[543]二叉树的直径"},{"content":"//给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 // // 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（ //一个节点也可以是它自己的祖先）。” // // // // 示例 1： // // //输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 //输出：3 //解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 // // // 示例 2： // // //输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 //输出：5 //解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 // // // 示例 3： // // //输入：root = [1,2], p = 1, q = 2 //输出：1 // // // // // 提示： // // // 树中节点数目在范围 [2, 105] 内。 // -109 \u0026lt;= Node.val \u0026lt;= 109 // 所有 Node.val 互不相同 。 // p != q // p 和 q 均存在于给定的二叉树中。 // // Related Topics 树 // 👍 961 👎 0 /* * 236 二叉树的最近公共祖先 * 2021-02-27 11:56:09 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(!root || root == p || root == q) return root; auto left = lowestCommonAncestor(root-\u0026gt;left, p, q); auto right = lowestCommonAncestor(root-\u0026gt;right, p, q); if(!left) return right; // 左边空 if(!right) return left; // 左边不空右边空 return root; // 左右都不空 } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","summary":"//给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 // // 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表","title":"[236]二叉树的最近公共祖先"},{"content":"//根据一棵树的前序遍历与中序遍历构造二叉树。 // // 注意: //你可以假设树中没有重复的元素。 // // 例如，给出 // // 前序遍历 preorder = [3,9,20,15,7] //中序遍历 inorder = [9,3,15,20,7] // // 返回如下的二叉树： // // 3 // / \\ // 9 20 // / \\ // 15 7 // Related Topics 树 深度优先搜索 数组 // 👍 893 👎 0 /* * 105 从前序与中序遍历序列构造二叉树 * 2021-02-27 11:45:39 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: unordered_map\u0026lt;int, int\u0026gt; mp; TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder) { int n = preorder.size(); if(!n) return nullptr; for(int i = 0;i \u0026lt; inorder.size();i++) mp[inorder[i]] = i; return dfs(preorder, inorder, 0, n - 1, 0 ,n - 1); } TreeNode* dfs(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder, int pl, int pr, int il, int ir){ if (pl \u0026gt; pr) return nullptr; int val = preorder[pl]; int k = mp[val]; int len = k - il; auto root = new TreeNode(val); root-\u0026gt;left = dfs(preorder, inorder, pl + 1, pl + len, il, k - 1); root-\u0026gt;right = dfs(preorder, inorder, pl + len + 1, pr, k + 1, ir); return root; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"//根据一棵树的前序遍历与中序遍历构造二叉树。 // // 注意: //你可以假设树中没有重复的元素。 // // 例如，给出 // // 前序遍历 preorder = [3,9,20,15,7] //中序遍历 inorder = [9,3,15,20,7]","title":"[105]从前序与中序遍历序列构造二叉树"},{"content":"//给定一个二叉树，检查它是否是镜像对称的。 // // // // 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 // // 1 // / \\ // 2 2 // / \\ / \\ //3 4 4 3 // // // // // 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: // // 1 // / \\ // 2 2 // \\ \\ // 3 3 // // // // // 进阶： // // 你可以运用递归和迭代两种方法解决这个问题吗？ // Related Topics 树 深度优先搜索 广度优先搜索 // 👍 1255 👎 0 /* * 101 对称二叉树 * 2021-02-27 11:32:32 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isSymmetric(TreeNode* root) { if(!root) return true; if(!root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right) return true; if(!root-\u0026gt;left || !root-\u0026gt;right) return false; stack\u0026lt;TreeNode*\u0026gt; ls, rs; auto l = root-\u0026gt;left, r = root-\u0026gt;right; while(l || r || ls.size() || rs.size()){ while(l \u0026amp;\u0026amp; r){ ls.push(l); l = l-\u0026gt;left; rs.push(r); r = r-\u0026gt;right; } if(l || r) return false; l = ls.top();ls.pop(); r = rs.top();rs.pop(); if(l-\u0026gt;val != r-\u0026gt;val) return false; l = l-\u0026gt;right; r = r-\u0026gt;left; } return true; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/101-ii%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"//给定一个二叉树，检查它是否是镜像对称的。 // // // // 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 // // 1 // / \\ // 2 2 // / \\ / \\ //3 4 4 3 // // // // // 但是下面这个 [1,2,2,null,3,null,3] 则不","title":"[101]对称二叉树"},{"content":"//给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 // // 进阶： // // // 你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？ // // // // // 示例 1： // // //输入：head = [4,2,1,3] //输出：[1,2,3,4] // // // 示例 2： // // //输入：head = [-1,5,3,4,0] //输出：[-1,0,3,4,5] // // // 示例 3： // // //输入：head = [] //输出：[] // // // // // 提示： // // // 链表中节点的数目在范围 [0, 5 * 104] 内 // -105 \u0026lt;= Node.val \u0026lt;= 105 // // Related Topics 排序 链表 // 👍 1011 👎 0 /* * 148 排序链表 * 2021-02-27 10:22:35 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* sortList(ListNode* head) { int n = 0; for(auto p = head; p;p = p-\u0026gt;next) n++; auto dummy = new ListNode(-1); dummy-\u0026gt;next = head; for(int i = 1;i \u0026lt; n;i *= 2){ auto cur = dummy; for(int j = 0;i + j \u0026lt; n;j += i * 2){ auto first = cur-\u0026gt;next; auto second = first; for(int k = 0;k \u0026lt; i;k++) second = second-\u0026gt;next; int f = 0, s = 0; while(f \u0026lt; i \u0026amp;\u0026amp; s \u0026lt; i \u0026amp;\u0026amp; second){ if(first-\u0026gt;val \u0026lt;= second-\u0026gt;val){ cur-\u0026gt;next = first; cur = first; first = first-\u0026gt;next; f++; }else{ cur-\u0026gt;next = second; cur = second; second = second-\u0026gt;next; s++; } } while(f \u0026lt; i){ cur-\u0026gt;next = first; cur = first; first = first-\u0026gt;next; f++; } while(s \u0026lt; i \u0026amp;\u0026amp; right){ cur-\u0026gt;next = second; cur = second; second = second-\u0026gt;next; s++; } cur-\u0026gt;next = second; // after reverse second is the head } } return dummy-\u0026gt;next; } }; class Solution2 { public: ListNode* sortList(ListNode* head) { if(!head || !head-\u0026gt;next) return head; auto slow = head, fast = head; while(fast-\u0026gt;next \u0026amp;\u0026amp; fast-\u0026gt;next-\u0026gt;next){ slow = slow-\u0026gt;next; fast = fast-\u0026gt;next-\u0026gt;next; } auto newHead = slow-\u0026gt;next; slow-\u0026gt;next = nullptr; return merge(sortList(head), sortList(newHead)); } ListNode* merge(ListNode* a, ListNode* b){ auto dummy = new ListNode(-1); auto cur = dummy; while(a \u0026amp;\u0026amp; b){ if(a-\u0026gt;val \u0026lt; b-\u0026gt;val){ cur-\u0026gt;next = a; a = a-\u0026gt;next; }else{ cur-\u0026gt;next = b; b = b-\u0026gt;next; } cur = cur-\u0026gt;next; } if(a) cur-\u0026gt;next = a; if(b) cur-\u0026gt;next = b; return dummy-\u0026gt;next; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/148%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/","summary":"//给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 // // 进阶： // // // 你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？","title":"[148]排序链表"},{"content":"//给定一个链表，判断链表中是否有环。 // // 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的 //位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 // // 如果链表中存在环，则返回 true 。 否则，返回 false 。 // // // // 进阶： // // 你能用 O(1)（即，常量）内存解决此问题吗？ // // // // 示例 1： // // // // 输入：head = [3,2,0,-4], pos = 1 //输出：true //解释：链表中有一个环，其尾部连接到第二个节点。 // // // 示例 2： // // // // 输入：head = [1,2], pos = 0 //输出：true //解释：链表中有一个环，其尾部连接到第一个节点。 // // // 示例 3： // // // // 输入：head = [1], pos = -1 //输出：false //解释：链表中没有环。 // // // // // 提示： // // // 链表中节点的数目范围是 [0, 104] // -105 \u0026lt;= Node.val \u0026lt;= 105 // pos 为 -1 或者链表中的一个 有效索引 。 // // Related Topics 链表 双指针 // 👍 948 👎 0 /* * 141 环形链表 * 2021-02-27 09:51:50 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { auto fast = head; auto slow = head; // 判断是否存在环 while(fast){ if(!fast-\u0026gt;next) return false; fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; if(slow == fast) return true; } return false; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/141-ii%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","summary":"//给定一个链表，判断链表中是否有环。 // // 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们","title":"[141]环形链表"},{"content":"//给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 // // 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，po //s 仅仅是用于标识环的情况，并不会作为参数传递到函数中。 // // 说明：不允许修改给定的链表。 // // 进阶： // // // 你是否可以使用 O(1) 空间解决此题？ // // // // // 示例 1： // // // // //输入：head = [3,2,0,-4], pos = 1 //输出：返回索引为 1 的链表节点 //解释：链表中有一个环，其尾部连接到第二个节点。 // // // 示例 2： // // // // //输入：head = [1,2], pos = 0 //输出：返回索引为 0 的链表节点 //解释：链表中有一个环，其尾部连接到第一个节点。 // // // 示例 3： // // // // //输入：head = [1], pos = -1 //输出：返回 null //解释：链表中没有环。 // // // // // 提示： // // // 链表中节点的数目范围在范围 [0, 104] 内 // -105 \u0026lt;= Node.val \u0026lt;= 105 // pos 的值为 -1 或者链表中的一个有效索引 // // Related Topics 链表 双指针 // 👍 877 👎 0 /* * 142 环形链表 II * 2021-02-27 09:35:11 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: // 与141相比，这个题目是找到入环点，难度更大一点 ListNode *detectCycle(ListNode *head) { auto slow = head, fast = head; while(fast){ fast = fast-\u0026gt;next; slow = slow-\u0026gt;next; if(fast) fast = fast-\u0026gt;next; else break; if(fast == slow){ slow = head; while(slow != fast){ fast = fast-\u0026gt;next; slow = slow-\u0026gt;next; } return fast; } } return nullptr; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/142%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii/","summary":"//给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 // // 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链","title":"[142]环形链表 II"},{"content":"//编写一个程序，找到两个单链表相交的起始节点。 // // 如下面的两个链表： // // // // 在节点 c1 开始相交。 // // // // 示例 1： // // // // 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, s //kipB = 3 //输出：Reference of the node with value = 8 //输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1 //,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 // // // // // 示例 2： // // // // 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = // 1 //输出：Reference of the node with value = 2 //输入解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4 //]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 // // // // // 示例 3： // // // // 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 //输出：null //输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 // skipA 和 skipB 可以是任意值。 //解释：这两个链表不相交，因此返回 null。 // // // // // 注意： // // // 如果两个链表没有交点，返回 null. // 在返回结果后，两个链表仍须保持原有的结构。 // 可假定整个链表结构中没有循环。 // 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 // // Related Topics 链表 // 👍 995 👎 0 /* * 160 相交链表 * 2021-02-26 23:22:11 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) { auto p = headA, q = headB; // headA --\u0026gt; target = a // headB --\u0026gt; target = b // target --\u0026gt; end = c // when p goes a + b + c // when q goes a + b + c // p \u0026amp;\u0026amp; q will at target while(p != q){ if(p) p = p-\u0026gt;next; else p = headB; if(q) q = q-\u0026gt;next; else q = headA; } return p; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/","summary":"//编写一个程序，找到两个单链表相交的起始节点。 // // 如下面的两个链表： // // // // 在节点 c1 开始相交。 // // // // 示例 1： // // // // 输入：interse","title":"[160]相交链表"},{"content":"//反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 // // 说明: //1 ≤ m ≤ n ≤ 链表长度。 // // 示例: // // 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, m = 2, n = 4 //输出: 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5-\u0026gt;NULL // Related Topics 链表 // 👍 683 👎 0 /* * 92 反转链表 II * 2021-02-26 22:55:34 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseBetween(ListNode* head, int left, int right) { if(left == right) return head; ListNode dummy(-1); auto ptr = \u0026amp;dummy; ptr-\u0026gt;next = head; auto a = ptr, c = ptr; for(int i = 0;i \u0026lt; left - 1;i++) a = a-\u0026gt;next; for(int i = 0;i \u0026lt; right;i++) c = c-\u0026gt;next; auto b = a-\u0026gt;next, d = c-\u0026gt;next; // result a-\u0026gt;b .... c-\u0026gt;d // reverse list from b ... c for(auto p = b, q = b-\u0026gt;next; q != d;){ auto temp = q-\u0026gt;next; q-\u0026gt;next = p; p = q, q = temp; } b-\u0026gt;next = d; a-\u0026gt;next = c; return dummy.next; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-ii/","summary":"//反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 // // 说明: //1 ≤ m ≤ n ≤ 链表长度。 // // 示例: // // 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, m = 2, n = 4 //输出: 1-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;5-\u0026gt;NULL // Related Topics 链表","title":"[92]反转链表 II"},{"content":"//给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 // // 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 // // // // 示例 1： // // //输入：head = [1,2,3,4] //输出：[2,1,4,3] // // // 示例 2： // // //输入：head = [] //输出：[] // // // 示例 3： // // //输入：head = [1] //输出：[1] // // // // // 提示： // // // 链表中节点的数目在范围 [0, 100] 内 // 0 \u0026lt;= Node.val \u0026lt;= 100 // // // // // 进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。） // Related Topics 递归 链表 // 👍 828 👎 0 /* * 24 两两交换链表中的节点 * 2021-02-26 22:38:38 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { ListNode dummy(-1); auto ptr = \u0026amp;dummy; dummy.next = head; for(auto p = ptr;p-\u0026gt;next \u0026amp;\u0026amp; p-\u0026gt;next-\u0026gt;next;){ auto a = p-\u0026gt;next; auto b = p-\u0026gt;next-\u0026gt;next; p-\u0026gt;next = b; a-\u0026gt;next = b-\u0026gt;next; b-\u0026gt;next = a; p = a; } return dummy.next; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/24%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","summary":"//给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 // // 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 // // // // 示例","title":"[24]两两交换链表中的节点"},{"content":"//给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 // // 示例 1: // // 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, k = 2 //输出: 4-\u0026gt;5-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;NULL //解释: //向右旋转 1 步: 5-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;NULL //向右旋转 2 步: 4-\u0026gt;5-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;NULL // // // 示例 2: // // 输入: 0-\u0026gt;1-\u0026gt;2-\u0026gt;NULL, k = 4 //输出: 2-\u0026gt;0-\u0026gt;1-\u0026gt;NULL //解释: //向右旋转 1 步: 2-\u0026gt;0-\u0026gt;1-\u0026gt;NULL //向右旋转 2 步: 1-\u0026gt;2-\u0026gt;0-\u0026gt;NULL //向右旋转 3 步: 0-\u0026gt;1-\u0026gt;2-\u0026gt;NULL //向右旋转 4 步: 2-\u0026gt;0-\u0026gt;1-\u0026gt;NULL // Related Topics 链表 双指针 // 👍 430 👎 0 /* * 61 旋转链表 * 2021-02-26 22:24:19 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { if(!head) return nullptr; int n = 0; for(auto cur = head;cur;cur = cur-\u0026gt;next) n++; k = k % n; // cout\u0026lt;\u0026lt;k\u0026lt;\u0026lt;endl; // return nullptr; auto fast = head, slow = head; while( k-- ) fast = fast-\u0026gt;next; while(fast-\u0026gt;next){ // stop at last node fast = fast-\u0026gt;next; slow = slow-\u0026gt;next; } fast-\u0026gt;next = head; head = slow-\u0026gt;next; slow-\u0026gt;next = nullptr; return head; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/61-ii%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/","summary":"//给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 // // 示例 1: // // 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, k = 2 //输出: 4-\u0026gt;5-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;NULL //解释: //向右旋转 1","title":"[61]旋转链表"},{"content":"//给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 // // 示例 1: // // 输入: 1-\u0026gt;1-\u0026gt;2 //输出: 1-\u0026gt;2 // // // 示例 2: // // 输入: 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;3 //输出: 1-\u0026gt;2-\u0026gt;3 // Related Topics 链表 // 👍 478 👎 0 /* * 83 删除排序链表中的重复元素 * 2021-02-26 20:33:53 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { auto cur = head; while(cur){ if(cur-\u0026gt;next \u0026amp;\u0026amp; cur-\u0026gt;val == cur-\u0026gt;next-\u0026gt;val){ cur-\u0026gt;next = cur-\u0026gt;next-\u0026gt;next; }else cur = cur-\u0026gt;next; } return head; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/83%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/","summary":"//给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 // // 示例 1: // // 输入: 1-\u0026gt;1-\u0026gt;2 //输出: 1-\u0026gt;2 // // // 示例 2: // // 输入: 1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;3 //输出: 1-\u0026gt;2-\u0026gt;3 // Related","title":"[83]删除排序链表中的重复元素"},{"content":"//请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。 // // // // 现有一个链表 -- head = [4,5,1,9]，它可以表示为: // // // // // // 示例 1： // // 输入：head = [4,5,1,9], node = 5 //输出：[4,1,9] //解释：给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -\u0026gt; 1 -\u0026gt; 9. // // // 示例 2： // // 输入：head = [4,5,1,9], node = 1 //输出：[4,5,9] //解释：给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -\u0026gt; 5 -\u0026gt; 9. // // // // // 提示： // // // 链表至少包含两个节点。 // 链表中所有节点的值都是唯一的。 // 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 // 不要从你的函数中返回任何结果。 // // Related Topics 链表 // 👍 848 👎 0 /* * 237 删除链表中的节点 * 2021-02-26 20:27:21 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution2 { public: void deleteNode(ListNode* node) { node-\u0026gt;val = node-\u0026gt;next-\u0026gt;val; node-\u0026gt;next = node-\u0026gt;next-\u0026gt;next; } }; class Solution { public: void deleteNode(ListNode* node) { // 使用node-\u0026gt;next取代node *(node) = *(node-\u0026gt;next); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/237%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/","summary":"//请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。 // // // // 现有一个链表 -- head = [4,5,1,","title":"[237]删除链表中的节点"},{"content":"//给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 // // 进阶：你能尝试使用一趟扫描实现吗？ // // // // 示例 1： // // //输入：head = [1,2,3,4,5], n = 2 //输出：[1,2,3,5] // // // 示例 2： // // //输入：head = [1], n = 1 //输出：[] // // // 示例 3： // // //输入：head = [1,2], n = 1 //输出：[1] // // // // // 提示： // // // 链表中结点的数目为 sz // 1 \u0026lt;= sz \u0026lt;= 30 // 0 \u0026lt;= Node.val \u0026lt;= 100 // 1 \u0026lt;= n \u0026lt;= sz // // Related Topics 链表 双指针 // 👍 1236 👎 0 /* * 19 删除链表的倒数第 N 个结点 * 2021-02-26 20:15:55 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { auto dummy = new ListNode(-1); dummy-\u0026gt;next = head; auto fast = dummy, slow = dummy; while(n--) fast = fast-\u0026gt;next; while(fast-\u0026gt;next){ fast = fast-\u0026gt;next; slow = slow-\u0026gt;next; } slow-\u0026gt;next = slow-\u0026gt;next-\u0026gt;next; return dummy.next; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/19-ii%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9/","summary":"//给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 // // 进阶：你能尝试使用一趟扫描实现吗？ // // // // 示例 1： // // //输入：hea","title":"[19]删除链表的倒数第 N 个结点"},{"content":"//你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有 //版本都是错的。 // // 假设你有 n 个版本 [1, 2, ..., n]，你想找出导致之后所有版本出错的第一个错误的版本。 // // 你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误 //的版本。你应该尽量减少对调用 API 的次数。 // // 示例: // // 给定 n = 5，并且 version = 4 是第一个错误的版本。 // //调用 isBadVersion(3) -\u0026gt; false //调用 isBadVersion(5) -\u0026gt; true //调用 isBadVersion(4) -\u0026gt; true // //所以，4 是第一个错误的版本。 // Related Topics 二分查找 // 👍 258 👎 0 /* * 278 第一个错误的版本 * 2021-02-26 19:57:01 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) // The API isBadVersion is defined for you. bool isBadVersion(int version); class Solution { public: int firstBadVersion(int n) { int l = 1, r = n; while(l \u0026lt; r){ int mid = l + (long long)r \u0026gt;\u0026gt; 1; if(isBadVersion(mid)) r = mid; else l = mid + 1; } return l; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/278%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/","summary":"//你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以","title":"[278]第一个错误的版本"},{"content":"//整数数组 nums 按升序排列，数组中的值 互不相同 。 // // 在传递给函数之前，nums 在预先未知的某个下标 k（0 \u0026lt;= k \u0026lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[ //k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2 //,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 // // 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。 // // // // 示例 1： // // //输入：nums = [4,5,6,7,0,1,2], target = 0 //输出：4 // // // 示例 2： // // //输入：nums = [4,5,6,7,0,1,2], target = 3 //输出：-1 // // 示例 3： // // //输入：nums = [1], target = 0 //输出：-1 // // // // // 提示： // // // 1 \u0026lt;= nums.length \u0026lt;= 5000 // -10^4 \u0026lt;= nums[i] \u0026lt;= 10^4 // nums 中的每个值都 独一无二 // nums 肯定会在某个点上旋转 // -10^4 \u0026lt;= target \u0026lt;= 10^4 // // // // // 进阶：你可以设计一个时间复杂度为 O(log n) 的解决方案吗？ // Related Topics 数组 二分查找 // 👍 1197 👎 0 /* * 33 搜索旋转排序数组 * 2021-02-26 19:39:27 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { if(nums.empty()) return -1; int l = 0, r = nums.size() - 1; // find turn pos while(l \u0026lt; r){ int mid = l + r \u0026gt;\u0026gt; 1; if(nums[mid] \u0026lt;= nums.back()) r = mid; else l = mid + 1; } if(target \u0026lt;= nums.back()) r = nums.size() - 1; else l = 0, r--; // find target while(l \u0026lt; r){ int mid = l + r \u0026gt;\u0026gt; 1; if(nums[mid] \u0026gt;= target) r = mid; else l = mid + 1; } // compare and judge if(nums[l] == target) return l; else return -1; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/33%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/","summary":"//整数数组 nums 按升序排列，数组中的值 互不相同 。 // // 在传递给函数之前，nums 在预先未知的某个下标 k（0 \u0026lt;= k \u0026lt; nums.length）上进行了","title":"[33]搜索旋转排序数组"},{"content":"//假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。 // // 请找出其中最小的元素。 // // // // 示例 1： // // //输入：nums = [3,4,5,1,2] //输出：1 // // // 示例 2： // // //输入：nums = [4,5,6,7,0,1,2] //输出：0 // // // 示例 3： // // //输入：nums = [1] //输出：1 // // // // // 提示： // // // 1 \u0026lt;= nums.length \u0026lt;= 5000 // -5000 \u0026lt;= nums[i] \u0026lt;= 5000 // nums 中的所有整数都是 唯一 的 // nums 原来是一个升序排序的数组，但在预先未知的某个点上进行了旋转 // // Related Topics 数组 二分查找 // 👍 357 👎 0 /* * 153 寻找旋转排序数组中的最小值 * 2021-02-26 15:40:53 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution2 { public: int findMin(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); if(!n) return 0; if(nums[n-1] \u0026gt; nums[0]) return nums[0]; while(--n){ if(n \u0026gt;= 0 \u0026amp;\u0026amp; nums[n] == nums[0]) n--; else break; } int l = 0, r = n; while(l \u0026lt; r){ int mid = l + r \u0026gt;\u0026gt; 1; if(nums[mid] \u0026lt; nums[0]) r = mid; // 注意这里的特征，是nums[mid] \u0026lt; nums[0] else l = mid + 1; } return nums[l]; } }; class Solution { public: int findMin(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int l = 0, r = nums.size() - 1; while(l \u0026lt; r){ int mid = l + r \u0026gt;\u0026gt; 1; if(nums[mid] \u0026lt;= nums.back()) r = mid; // 注意特征 else l = mid + 1; } return nums[r]; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/153%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/","summary":"//假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。 // // 请找出其中最小的元素。 // // // // 示例 1： // // //输入：n","title":"[153]寻找旋转排序数组中的最小值"},{"content":"//编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： // // // 每行中的整数从左到右按升序排列。 // 每行的第一个整数大于前一行的最后一个整数。 // // // // // 示例 1： // // //输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 //输出：true // // // 示例 2： // // //输入：matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 //输出：false // // // // // 提示： // // // m == matrix.length // n == matrix[i].length // 1 \u0026lt;= m, n \u0026lt;= 100 // -104 \u0026lt;= matrix[i][j], target \u0026lt;= 104 // // Related Topics 数组 二分查找 // 👍 325 👎 0 /* * 74 搜索二维矩阵 * 2021-02-26 15:31:50 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: bool searchMatrix(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { int m = matrix.size(); if(!m) return false; int n = matrix[0].size(); if(!n) return false; int i = 0, j = n - 1; while(i \u0026lt; m \u0026amp;\u0026amp; j \u0026gt;= 0){ if(target == matrix[i][j]) return true; else if(matrix[i][j] \u0026lt; target) i++; else j--; } return false; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/74%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/","summary":"//编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： // // // 每行中的整数从左到右按升序排列。 // 每行的第一个整数大","title":"[74]搜索二维矩阵"},{"content":"//实现 int sqrt(int x) 函数。 // // 计算并返回 x 的平方根，其中 x 是非负整数。 // // 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 // // 示例 1: // // 输入: 4 //输出: 2 // // // 示例 2: // // 输入: 8 //输出: 2 //说明: 8 的平方根是 2.82842..., // 由于返回类型是整数，小数部分将被舍去。 // // Related Topics 数学 二分查找 // 👍 602 👎 0 /* * 69 x 的平方根 * 2021-02-26 13:41:49 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution2 { public: int mySqrt(int x) { int l = 0, r = x; while(l \u0026lt; r){ int mid = l + r + 1ll \u0026gt;\u0026gt; 1; if(mid \u0026lt;= x / mid) l = mid; // 满足 (mid \u0026lt;= x / mid) 右边界 else r = mid - 1; } return l; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/69x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/","summary":"//实现 int sqrt(int x) 函数。 // // 计算并返回 x 的平方根，其中 x 是非负整数。 // // 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 // // 示例 1: //","title":"[69]x 的平方根"},{"content":"//给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 // // 你可以假设数组中无重复元素。 // // 示例 1: // // 输入: [1,3,5,6], 5 //输出: 2 // // // 示例 2: // // 输入: [1,3,5,6], 2 //输出: 1 // // // 示例 3: // // 输入: [1,3,5,6], 7 //输出: 4 // // // 示例 4: // // 输入: [1,3,5,6], 0 //输出: 0 // // Related Topics 数组 二分查找 // 👍 828 👎 0 /* * 35 搜索插入位置 * 2021-02-26 13:41:41 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int searchInsert(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { if(nums.empty() || nums.back() \u0026lt; target) return nums.size(); int l = 0, r = nums.size() - 1; while(l \u0026lt; r){ int mid = l + r \u0026gt;\u0026gt; 1; if(nums[mid] \u0026gt;= target) r = mid; // 满足(nums[mid] \u0026gt;= target\u0026gt;的左边界 else l = mid + 1; } return l; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/35%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","summary":"//给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 // // 你可以假设数","title":"[35]搜索插入位置"},{"content":"//给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 // // 如果数组中不存在目标值 target，返回 [-1, -1]。 // // 进阶： // // // 你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？ // // // // // 示例 1： // // //输入：nums = [5,7,7,8,8,10], target = 8 //输出：[3,4] // // 示例 2： // // //输入：nums = [5,7,7,8,8,10], target = 6 //输出：[-1,-1] // // 示例 3： // // //输入：nums = [], target = 0 //输出：[-1,-1] // // // // 提示： // // // 0 \u0026lt;= nums.length \u0026lt;= 105 // -109 \u0026lt;= nums[i] \u0026lt;= 109 // nums 是一个非递减数组 // -109 \u0026lt;= target \u0026lt;= 109 // // Related Topics 数组 二分查找 // 👍 868 👎 0 /* * 34 在排序数组中查找元素的第一个和最后一个位置 * 2021-02-26 13:41:40 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;int\u0026gt; searchRange(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { if(nums.empty()) return {-1, -1}; else if(nums.back() \u0026lt; target || nums.front() \u0026gt; target) return {-1, -1}; int l = 0, r = nums.size() - 1; while(l \u0026lt; r){ int mid = l + r + 1\u0026gt;\u0026gt; 1; if(nums[mid] \u0026lt;= target) l = mid; // nums[mid] \u0026lt;= target 的右边界 else r = mid - 1; } int end; if(nums[l] != target) return {-1, -1}; else end = l; l = 0, r = nums.size() - 1; while(l \u0026lt; r){ int mid = l + r \u0026gt;\u0026gt; 1; if(nums[mid] \u0026gt;= target) r = mid; // nums[mid] \u0026gt;= target 的左边界 else l = mid + 1; } int start = l; return {start, end}; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/34%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/","summary":"//给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 // // 如果数组中不存在目标值","title":"[34]在排序数组中查找元素的第一个和最后一个位置"},{"content":"//给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 // // 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 // // // // // // 示例 1： // // //输入：digits = \u0026#34;23\u0026#34; //输出：[\u0026#34;ad\u0026#34;,\u0026#34;ae\u0026#34;,\u0026#34;af\u0026#34;,\u0026#34;bd\u0026#34;,\u0026#34;be\u0026#34;,\u0026#34;bf\u0026#34;,\u0026#34;cd\u0026#34;,\u0026#34;ce\u0026#34;,\u0026#34;cf\u0026#34;] // // // 示例 2： // // //输入：digits = \u0026#34;\u0026#34; //输出：[] // // // 示例 3： // // //输入：digits = \u0026#34;2\u0026#34; //输出：[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;] // // // // // 提示： // // // 0 \u0026lt;= digits.length \u0026lt;= 4 // digits[i] 是范围 [\u0026#39;2\u0026#39;, \u0026#39;9\u0026#39;] 的一个数字。 // // Related Topics 深度优先搜索 递归 字符串 回溯算法 // 👍 1145 👎 0 /* * 17 电话号码的字母组合 * 2021-02-26 13:27:27 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;string\u0026gt; letterCombinations(string digits) { string symbols[10] = {\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;,\u0026#34;wxyz\u0026#34;}; vector\u0026lt;string\u0026gt; ans; if(digits.empty()) return ans; ans.push_back(\u0026#34;\u0026#34;); for(char ch : digits){ int num = ch - \u0026#39;0\u0026#39;; vector\u0026lt;string\u0026gt; new_ans; for(const string\u0026amp; str : ans){ for(auto symbol : symbols[num]){ string temp = str + symbol; new_ans.push_back(temp); } } ans.swap(new_ans); } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/17-ii%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","summary":"//给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 // // 给出数字到字母的映射如下（与电话按键相同）。注意 1","title":"[17]电话号码的字母组合"},{"content":"//给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + // d 的值与 target 相等？找出所有满足条件且不重复的四元组。 // // 注意： // // 答案中不可以包含重复的四元组。 // // 示例： // // 给定数组 nums = [1, 0, -1, 0, -2, 2]，和 target = 0。 // //满足要求的四元组集合为： //[ // [-1, 0, 0, 1], // [-2, -1, 1, 2], // [-2, 0, 0, 2] //] // // Related Topics 数组 哈希表 双指针 // 👍 758 👎 0 /* * 18 四数之和 * 2021-02-26 12:51:32 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; fourSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { sort(nums.begin(), nums.end()); int n = nums.size(); if(n \u0026lt; 4 || nums[0] \u0026gt; 0 || nums[n-1] \u0026lt; 0) return ans; // for(auto x : nums) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;; for(int i = 0;i \u0026lt;= n - 3;i++){ if(i \u0026gt;= 1 \u0026amp;\u0026amp; nums[i] == nums[i-1]) continue; for(int j = i + 1;j \u0026lt;= n - 2;j++){ if(j \u0026gt; i + 1 \u0026amp;\u0026amp; nums[j] == nums[j-1]) continue; int l = j + 1; int r = n - 1; int cur_sum = nums[i] + nums[j]; while(l \u0026lt; r){ // cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;l\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;r\u0026lt;\u0026lt;endl; int sum = cur_sum + nums[l] + nums[r]; if(sum \u0026lt; target) l++; else if(sum \u0026gt; target) r--; else{ ans.push_back({nums[i], nums[j], nums[l], nums[r]}); while( (l + 1) \u0026lt; n \u0026amp;\u0026amp; nums[l] == nums[l+1]) l++; l++; while( (r - 1) \u0026gt;= 0 \u0026amp;\u0026amp; nums[r] == nums[r-1]) r--; r--; } } } } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/18%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"//给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + // d 的值与 target 相等？找出所有","title":"[18]四数之和"},{"content":"//编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。 // // // 如果是有效的 IPv4 地址，返回 \u0026#34;IPv4\u0026#34; ； // 如果是有效的 IPv6 地址，返回 \u0026#34;IPv6\u0026#34; ； // 如果不是上述类型的 IP 地址，返回 \u0026#34;Neither\u0026#34; 。 // // // IPv4 地址由十进制数和点来表示，每个地址包含 4 个十进制数，其范围为 0 - 255， 用(\u0026#34;.\u0026#34;)分割。比如，172.16.254.1； // // 同时，IPv4 地址内的数不会以 0 开头。比如，地址 172.16.254.01 是不合法的。 // // IPv6 地址由 8 组 16 进制的数字来表示，每组表示 16 比特。这些组数字通过 (\u0026#34;:\u0026#34;)分割。比如, 2001:0db8:85a3:0000:0 //000:8a2e:0370:7334 是一个有效的地址。而且，我们可以加入一些以 0 开头的数字，字母可以使用大写，也可以是小写。所以， 2001:db8:85 //a3:0:0:8A2E:0370:7334 也是一个有效的 IPv6 address地址 (即，忽略 0 开头，忽略大小写)。 // // 然而，我们不能因为某个组的值为 0，而使用一个空的组，以至于出现 (::) 的情况。 比如， 2001:0db8:85a3::8A2E:0370:7334 // 是无效的 IPv6 地址。 // // 同时，在 IPv6 地址中，多余的 0 也是不被允许的。比如， 02001:0db8:85a3:0000:0000:8a2e:0370:7334 是无效的 //。 // // // // 示例 1： // // 输入：IP = \u0026#34;172.16.254.1\u0026#34; //输出：\u0026#34;IPv4\u0026#34; //解释：有效的 IPv4 地址，返回 \u0026#34;IPv4\u0026#34; // // // 示例 2： // // 输入：IP = \u0026#34;2001:0db8:85a3:0:0:8A2E:0370:7334\u0026#34; //输出：\u0026#34;IPv6\u0026#34; //解释：有效的 IPv6 地址，返回 \u0026#34;IPv6\u0026#34; // // // 示例 3： // // 输入：IP = \u0026#34;256.256.256.256\u0026#34; //输出：\u0026#34;Neither\u0026#34; //解释：既不是 IPv4 地址，又不是 IPv6 地址 // // // 示例 4： // // 输入：IP = \u0026#34;2001:0db8:85a3:0:0:8A2E:0370:7334:\u0026#34; //输出：\u0026#34;Neither\u0026#34; // // // 示例 5： // // 输入：IP = \u0026#34;1e1.4.5.6\u0026#34; //输出：\u0026#34;Neither\u0026#34; // // // // // 提示： // // // IP 仅由英文字母，数字，字符 \u0026#39;.\u0026#39; 和 \u0026#39;:\u0026#39; 组成。 // // Related Topics 字符串 // 👍 79 👎 0 /* * 468 验证IP地址 * 2021-02-24 12:01:34 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: string validIPAddress(string IP) { // cpp正则部分 \u0026#39;\\\\\u0026#39; 代表 \u0026#39;\\\u0026#39; regex ipv4(\u0026#34;(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\\\\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\u0026#34;); regex ipv6(\u0026#34;([0-9a-fA-F]{1,4}\\\\:){7}[0-9a-fA-F]{1,4}\u0026#34;); if (regex_match(IP, ipv4)) return \u0026#34;IPv4\u0026#34;; else if (regex_match(IP, ipv6)) return \u0026#34;IPv6\u0026#34;; else return \u0026#34;Neither\u0026#34;; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/468%E9%AA%8C%E8%AF%81ip%E5%9C%B0%E5%9D%80/","summary":"//编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。 // // // 如果是有效的 IPv4 地址，返回 \u0026#34;IPv4\u0026#34; ； // 如果是有效的 IPv6 地址，返回 \u0026#34;IPv6\u0026#34; ； // 如果不是上述类型","title":"[468]验证IP地址"},{"content":"//给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 // // 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 //例如，\u0026#34;ace\u0026#34; 是 \u0026#34;abcde\u0026#34; 的子序列，但 \u0026#34;aec\u0026#34; 不是 \u0026#34;abcde\u0026#34; 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。 // // // 若这两个字符串没有公共子序列，则返回 0。 // // // // 示例 1: // // 输入：text1 = \u0026#34;abcde\u0026#34;, text2 = \u0026#34;ace\u0026#34; //输出：3 //解释：最长公共子序列是 \u0026#34;ace\u0026#34;，它的长度为 3。 // // // 示例 2: // // 输入：text1 = \u0026#34;abc\u0026#34;, text2 = \u0026#34;abc\u0026#34; //输出：3 //解释：最长公共子序列是 \u0026#34;abc\u0026#34;，它的长度为 3。 // // // 示例 3: // // 输入：text1 = \u0026#34;abc\u0026#34;, text2 = \u0026#34;def\u0026#34; //输出：0 //解释：两个字符串没有公共子序列，返回 0。 // // // // // 提示: // // // 1 \u0026lt;= text1.length \u0026lt;= 1000 // 1 \u0026lt;= text2.length \u0026lt;= 1000 // 输入的字符串只含有小写英文字符。 // // Related Topics 动态规划 // 👍 366 👎 0 /* * 1143 最长公共子序列 * 2021-02-24 11:42:27 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int longestCommonSubsequence(string text1, string text2) { int m = text1.length(); int n = text2.length(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m + 1, vector\u0026lt;int\u0026gt;(n + 1, 0)); for(int i = 1;i \u0026lt;= m;i++){ for(int j = 1;j \u0026lt;= n;j++){ if(!i || !j) continue; else if(text1[i-1] == text2[j-1]) dp[i][j] = dp[i-1][j-1] + 1; else dp[i][j] = max(dp[i-1][j], dp[i][j-1]); } } return dp.back().back(); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/1143%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/","summary":"//给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 // // 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改","title":"[1143]最长公共子序列"},{"content":"//给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 // // 说明：每次只能向下或者向右移动一步。 // // // // 示例 1： // // //输入：grid = [[1,3,1],[1,5,1],[4,2,1]] //输出：7 //解释：因为路径 1→3→1→1→1 的总和最小。 // // // 示例 2： // // //输入：grid = [[1,2,3],[4,5,6]] //输出：12 // // // // // 提示： // // // m == grid.length // n == grid[i].length // 1 \u0026lt;= m, n \u0026lt;= 200 // 0 \u0026lt;= grid[i][j] \u0026lt;= 100 // // Related Topics 数组 动态规划 // 👍 792 👎 0 /* * 64 最小路径和 * 2021-02-24 11:34:06 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int minPathSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size(); int n = grid[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n, 0)); for(int i = 0;i \u0026lt; m;i++){ for(int j = 0;j \u0026lt; n;j++){ if(!i \u0026amp;\u0026amp; !j) dp[i][j] = grid[i][j]; else if(!i) dp[i][j] = grid[i][j] + dp[i][j-1]; else if(!j) dp[i][j] = grid[i][j] + dp[i-1][j]; else dp[i][j] = min(dp[i][j-1], dp[i-1][j]) + grid[i][j]; } } return dp.back().back(); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/64%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","summary":"//给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 // // 说明：每次只能向下或者向右移动一步","title":"[64]最小路径和"},{"content":"//给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 // // k 是一个正整数，它的值小于或等于链表的长度。 // // 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 // // // // 示例： // // 给你这个链表：1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5 // // 当 k = 2 时，应当返回: 2-\u0026gt;1-\u0026gt;4-\u0026gt;3-\u0026gt;5 // // 当 k = 3 时，应当返回: 3-\u0026gt;2-\u0026gt;1-\u0026gt;4-\u0026gt;5 // // // // 说明： // // // 你的算法只能使用常数的额外空间。 // 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 // // Related Topics 链表 // 👍 915 👎 0 /* * 25 K 个一组翻转链表 * 2021-02-24 11:13:31 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseKGroup(ListNode* head, int k) { if(!head || !head-\u0026gt;next) return head; auto ptr = head; for(int i = 0;i \u0026lt; k;i++){ if(!ptr) return head; ptr = ptr-\u0026gt;next; } auto cur = head; ListNode* pre = nullptr; for(int i = 0;i \u0026lt; k;i++){ auto temp = cur-\u0026gt;next; cur-\u0026gt;next = pre; pre = cur; cur = temp; } head-\u0026gt;next = reverseKGroup(cur, k); return pre; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/25k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/","summary":"//给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 // // k 是一个正整数，它的值小于或等于链表的长度。 // // 如果节点总数不是 k 的整数","title":"[25]K 个一组翻转链表"},{"content":"//给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 // // // // 提示： // // // num1 和num2 的长度都小于 5100 // num1 和num2 都只包含数字 0-9 // num1 和num2 都不包含任何前导零 // 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式 // // Related Topics 字符串 // 👍 312 👎 0 /* * 415 字符串相加 * 2021-02-23 22:36:11 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: string addStrings(string num1, string num2) { string result; int i = num1.size() - 1; int j = num2.size() - 1; int carry = 0; while(i \u0026gt;= 0 || j \u0026gt;= 0 || carry != 0){ int x = i \u0026gt;= 0 ? num1[i] - \u0026#39;0\u0026#39; : 0; int y = j \u0026gt;= 0 ? num2[j] - \u0026#39;0\u0026#39; : 0; int cur = (x + y + carry) % 10; carry = (x + y + carry) / 10; result.push_back(\u0026#39;0\u0026#39; + cur); i--; j--; } reverse(result.begin(), result.end()); return result; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/415%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/","summary":"//给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 // // // // 提示： // // // num1 和num2 的长度都小于 5100 // num1 和num2 都只包含数字 0-9 // num1 和","title":"[415]字符串相加"},{"content":"//反转一个单链表。 // // 示例: // // 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL //输出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL // // 进阶: //你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ // Related Topics 链表 // 👍 1519 👎 0 /* * 206 反转链表 * 2021-02-23 22:33:19 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { if(!head || !head-\u0026gt;next) return head; auto ptr = reverseList(head-\u0026gt;next); head-\u0026gt;next-\u0026gt;next = head; head-\u0026gt;next = nullptr; return ptr; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/206-ii%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","summary":"//反转一个单链表。 // // 示例: // // 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL //输出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL // // 进阶: //你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ // Related Topics 链表 // 👍 1519","title":"[206]反转链表"},{"content":"//给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 // // 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 // // // // 示例 1： // // //输入：[3,2,3] //输出：3 // // 示例 2： // // //输入：[2,2,1,1,1,2,2] //输出：2 // // // // // 进阶： // // // 尝试设计时间复杂度为 O(n)、空间复杂度为 O(1) 的算法解决此问题。 // // Related Topics 位运算 数组 分治算法 // 👍 880 👎 0 /* * 169 多数元素 * 2021-02-23 22:12:54 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int majorityElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.size() == 0) return 0; if(nums.size() == 1) return nums[0]; int ans = nums[0]; int freq = 1; for(int i = 1;i \u0026lt; nums.size();i++){ if(!freq) ans = nums[i], freq++; else{ if(ans == nums[i]) freq++; else freq--; } } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/169%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/","summary":"//给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 // // 你可以假设数组是非空的，并且给定的数组总是","title":"[169]多数元素"},{"content":"//给定一个只包括 \u0026#39;(\u0026#39;，\u0026#39;)\u0026#39;，\u0026#39;{\u0026#39;，\u0026#39;}\u0026#39;，\u0026#39;[\u0026#39;，\u0026#39;]\u0026#39; 的字符串 s ，判断字符串是否有效。 // // 有效字符串需满足： // // // 左括号必须用相同类型的右括号闭合。 // 左括号必须以正确的顺序闭合。 // // // // // 示例 1： // // //输入：s = \u0026#34;()\u0026#34; //输出：true // // // 示例 2： // // //输入：s = \u0026#34;()[]{}\u0026#34; //输出：true // // // 示例 3： // // //输入：s = \u0026#34;(]\u0026#34; //输出：false // // // 示例 4： // // //输入：s = \u0026#34;([)]\u0026#34; //输出：false // // // 示例 5： // // //输入：s = \u0026#34;{[]}\u0026#34; //输出：true // // // // 提示： // // // 1 \u0026lt;= s.length \u0026lt;= 104 // s 仅由括号 \u0026#39;()[]{}\u0026#39; 组成 // // Related Topics 栈 字符串 // 👍 2183 👎 0 /* * 20 有效的括号 * 2021-02-23 21:59:02 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: bool isValid(string s) { stack\u0026lt;char\u0026gt; stk; unordered_map\u0026lt;char, char\u0026gt; mp; mp[\u0026#39;(\u0026#39;] = \u0026#39;)\u0026#39;; mp[\u0026#39;{\u0026#39;] = \u0026#39;}\u0026#39;; mp[\u0026#39;[\u0026#39;] = \u0026#39;]\u0026#39;; for(int i = 0;i \u0026lt; s.length();i++){ // 根据当前元素的分类的不同，做不同的判断处理 if(!mp.count(s[i])){ // 如果当前元素是右括号，出栈 if(stk.empty()) return false; else if(mp[stk.top()] != s[i]) return false; else stk.pop(); }else{ // 如果当前元素是左括号，入栈 stk.push(s[i]); } } return stk.size() == 0; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/stack/20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/","summary":"//给定一个只包括 \u0026#39;(\u0026#39;，\u0026#39;)\u0026#39;，\u0026#39;{\u0026#39;，\u0026#39;}\u0026#39;，\u0026#39;[\u0026#39;，\u0026","title":"[20]有效的括号"},{"content":"什么是C++对象模型? 语言中直接支持面向对象程序设计的部分。 对于各种支持的底层实现机制。 对象模型研究的是对象在存储上的空间与时间上的更优，并对C++面向对象技术加以支持，如以虚指针、虚表机制支持多态特性。\n理解虚函数表 C++中虚函数的作用主要是为了实现多态机制。多态，简单来说，是指在继承层次中，父类的指针可以具有多种形态——当它指向某个子类对象时，通过它能够调用到子类的函数，而非父类的函数。\n#include \u0026lt;iostream\u0026gt; using namespace std; class Base { public: virtual void print(){ cout\u0026lt;\u0026lt;\u0026#34;Base\u0026#34;\u0026lt;\u0026lt;endl;}; }; class Derive : public Base{ public: virtual void print(){cout\u0026lt;\u0026lt;\u0026#34;Derive\u0026#34;\u0026lt;\u0026lt;endl;}; }; int main(){ Base* ptr1 = new Base; Base* ptr2 = new Derive; ptr1-\u0026gt;print(); // Base::print(); ptr2-\u0026gt;print(); // Derive::print(); return 0; } 这是一种运行期多态，即父类指针唯有在程序运行时才能知道所指的真正类型是什么。这种运行期决议，是通过虚函数表来实现的。\n使用指针访问虚表 #include \u0026lt;iostream\u0026gt; using namespace std; class Base { private: int a; public: virtual void test(){ cout\u0026lt;\u0026lt;\u0026#34;test\u0026#34;\u0026lt;\u0026lt;endl; } virtual void print(){ cout\u0026lt;\u0026lt;\u0026#34;Base\u0026#34;\u0026lt;\u0026lt;endl;} }; typedef void(*Func)(void); int main(){ Base b; int * vptrAdree = (int *)(\u0026amp;b); cout\u0026lt;\u0026lt;vptrAdree\u0026lt;\u0026lt;endl; Func fun = (Func)*(int * )(*(int*)(\u0026amp;b)+8); fun(); // Base return 0; } 我们强行把类对象的地址转换为 int* 类型，取得了虚函数指针的地址。虚函数指针指向虚函数表,虚函数表中存储的是一系列虚函数的地址，虚函数地址出现的顺序与类中虚函数声明的顺序一致。对虚函数指针地址值，可以得到虚函数表的地址，也即是虚函数表第二个虚函数的地址。\n对象模型概述 在C++中，有两种数据成员（class data members）：static 和nonstatic,以及三种类成员函数（class member functions）:static、nonstatic和virtual:\n那么，这个类在内存中将被如何表示？5种数据都是连续存放的吗？如何布局才能支持C++多态？ 我们的C++标准与编译器将如何塑造出各种数据成员与成员函数呢？\n4.1.简单对象模型 说明：在下面出现的图中，用蓝色边框框起来的内容在内存上是连续的。 这个模型非常地简单粗暴。在该模型下，对象由一系列的指针组成，每一个指针都指向一个数据成员或成员函数，也即是说，每个数据成员和成员函数在类中所占的大小是相同的，都为一个指针的大小。这样有个好处——很容易算出对象的大小，不过赔上的是空间和执行期效率。想象一下，如果我们的Point3d类是这种模型，将会比C语言的struct多了许多空间来存放指向函数的指针，而且每次读取类的数据成员，都需要通过再一次寻址——又是时间上的消耗。 所以这种对象模型并没有被用于实际产品上。\n4.2.表格驱动模型 这个模型在简单对象模型的基础上又添加一个间接层，它把类中的数据分成了两个部分：数据部分与函数部分，并使用两张表格，一张存放数据本身，一张存放函数的地址（也即函数比成员多一次寻址），而类对象仅仅含有两个指针，分别指向上面这两个表。这样看来，对象的大小是固定为两个指针大小。这个模型也没有用于实际应用于真正的C++编译器上。\n4.3.非继承下的C++对象模型 概述：在此模型下，nonstatic 数据成员被置于每一个类对象中，而static数据成员被置于类对象之外。static与nonstatic函数也都放在类对象之外，而对于virtual 函数，则通过虚函数表+虚指针来支持，具体如下：\n每个类生成一个表格，称为虚表（virtual table，简称vtbl）。虚表中存放着一堆指针，这些指针指向该类每一个虚函数。虚表中的函数地址将按声明时的顺序排列，不过当子类有多个重载函数时例外，后面会讨论。 每个类对象都拥有一个虚表指针(vptr)，由编译器为其生成。虚表指针的设定与重置皆由类的复制控制（也即是构造函数、析构函数、赋值操作符）来完成。vptr的位置为编译器决定，传统上它被放在所有显示声明的成员之后，不过现在许多编译器把vptr放在一个类对象的最前端。 另外，虚函数表的前面设置了一个指向type_info的指针，用以支持RTTI（Run Time Type Identification，运行时类型识别）。RTTI是为多态而生成的信息，包括对象继承关系，对象本身的描述等，只有具有虚函数的对象在会生成。 参考 图说C++对象模型：对象内存布局详解 ","permalink":"https://oxygenbytes.github.io/posts/cplus/c++%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/","summary":"什么是C++对象模型? 语言中直接支持面向对象程序设计的部分。 对于各种支持的底层实现机制。 对象模型研究的是对象在存储上的空间与时间上的更优，并","title":"C++对象模型"},{"content":"//给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 // // 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 // // // // // // 示例 1： // // //输入：digits = \u0026#34;23\u0026#34; //输出：[\u0026#34;ad\u0026#34;,\u0026#34;ae\u0026#34;,\u0026#34;af\u0026#34;,\u0026#34;bd\u0026#34;,\u0026#34;be\u0026#34;,\u0026#34;bf\u0026#34;,\u0026#34;cd\u0026#34;,\u0026#34;ce\u0026#34;,\u0026#34;cf\u0026#34;] // // // 示例 2： // // //输入：digits = \u0026#34;\u0026#34; //输出：[] // // // 示例 3： // // //输入：digits = \u0026#34;2\u0026#34; //输出：[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;] // // // // // 提示： // // // 0 \u0026lt;= digits.length \u0026lt;= 4 // digits[i] 是范围 [\u0026#39;2\u0026#39;, \u0026#39;9\u0026#39;] 的一个数字。 // // Related Topics 深度优先搜索 递归 字符串 回溯算法 // 👍 1136 👎 0 /* * 17 电话号码的字母组合 * 2021-02-23 10:25:30 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;string\u0026gt; dict{\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;abc\u0026#34;, \u0026#34;def\u0026#34;, \u0026#34;ghi\u0026#34;, \u0026#34;jkl\u0026#34;, \u0026#34;mno\u0026#34;, \u0026#34;pqrs\u0026#34;, \u0026#34;tuv\u0026#34;, \u0026#34;wxyz\u0026#34;}; vector\u0026lt;string\u0026gt; ans; string cur; vector\u0026lt;string\u0026gt; letterCombinations(string digits) { if(!digits.size()) return ans; dfs(digits, 0); return ans; } void dfs(string\u0026amp; digits, int level){ if(level == digits.size()) { ans.push_back(cur); return ; } auto str = dict[digits[level] - \u0026#39;0\u0026#39;]; for(int i = 0;i \u0026lt; str.size();i++){ string temp = cur; cur += str[i]; dfs(digits, level + 1); cur = temp; } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/","summary":"//给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 // // 给出数字到字母的映射如下（与电话按键相同）。注意 1","title":"[17]电话号码的字母组合"},{"content":"//翻转一棵二叉树。 // // 示例： // // 输入： // // 4 // / \\ // 2 7 // / \\ / \\ //1 3 6 9 // // 输出： // // 4 // / \\ // 7 2 // / \\ / \\ //9 6 3 1 // // 备注: //这个问题是受到 Max Howell 的 原问题 启发的 ： // // 谷歌：我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。 // Related Topics 树 // 👍 763 👎 0 /* * 226 翻转二叉树 * 2021-02-23 10:10:03 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* invertTree(TreeNode* root) { if(!root) return nullptr; auto temp = root-\u0026gt;left; root-\u0026gt;left = root-\u0026gt;right; root-\u0026gt;right = temp; invertTree(root-\u0026gt;left); invertTree(root-\u0026gt;right); return root; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/226%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"//翻转一棵二叉树。 // // 示例： // // 输入： // // 4 // / \\ // 2 7 // / \\ / \\ //1 3 6 9 // // 输出： // // 4 // / \\ // 7 2 // / \\ / \\ //9 6 3 1 // // 备注: //这个","title":"[226]翻转二叉树"},{"content":"//给定一个三角形 triangle ，找出自顶向下的最小路径和。 // // 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。也就是说，如果 //正位于当前行的下标 i ，那么下一步可以移动到下一行的下标 i 或 i + 1 。 // // // // 示例 1： // // //输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]] //输出：11 //解释：如下面简图所示： // 2 // 3 4 // 6 5 7 //4 1 8 3 //自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 // // // 示例 2： // // //输入：triangle = [[-10]] //输出：-10 // // // // // 提示： // // // 1 \u0026lt;= triangle.length \u0026lt;= 200 // triangle[0].length == 1 // triangle[i].length == triangle[i - 1].length + 1 // -104 \u0026lt;= triangle[i][j] \u0026lt;= 104 // // // // // 进阶： // // // 你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题吗？ // // Related Topics 数组 动态规划 // 👍 692 👎 0 /* * 120 三角形最小路径和 * 2021-02-22 17:19:50 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int minimumTotal(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; triangle) { int n = triangle.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n, vector\u0026lt;int\u0026gt;(n, 0)); for(int i = 0;i \u0026lt; n;i++){ // 状态转移由位置决定，与triangle的数值无关 for(int j = 0;j \u0026lt;= i;j++){ dp[i][j] += triangle[i][j]; if(!i) continue; else if(!j) dp[i][j] += dp[i-1][j]; else if(i == j) dp[i][j] += dp[i-1][j-1]; else dp[i][j] += min(dp[i-1][j-1], dp[i-1][j]); } } // for(int i = 0;i \u0026lt; n;i++){ // for(int j = 0; j \u0026lt;= i ;j++){ // cout\u0026lt;\u0026lt;dp[i][j]\u0026lt;\u0026lt;\u0026#34; \u0026#34;; // } // cout\u0026lt;\u0026lt;endl; // } return *min_element(dp[n-1].begin(), dp[n-1].end()); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/120%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/","summary":"//给定一个三角形 triangle ，找出自顶向下的最小路径和。 // // 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者","title":"[120]三角形最小路径和"},{"content":"//给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。 // // 字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余字符相对位置所组成的新字符串。（例如，\u0026#34;ACE\u0026#34; 是 \u0026#34;ABCDE\u0026#34; 的一个子序列 //，而 \u0026#34;AEC\u0026#34; 不是） // // 题目数据保证答案符合 32 位带符号整数范围。 // // // // 示例 1： // // //输入：s = \u0026#34;rabbbit\u0026#34;, t = \u0026#34;rabbit\u0026#34; //输出：3 //解释： //如下图所示, 有 3 种可以从 s 中得到 \u0026#34;rabbit\u0026#34; 的方案。 //(上箭头符号 ^ 表示选取的字母) //rabbbit //^^^^ ^^ //rabbbit //^^ ^^^^ //rabbbit //^^^ ^^^ // // // 示例 2： // // //输入：s = \u0026#34;babgbag\u0026#34;, t = \u0026#34;bag\u0026#34; //输出：5 //解释： //如下图所示, 有 5 种可以从 s 中得到 \u0026#34;bag\u0026#34; 的方案。 //(上箭头符号 ^ 表示选取的字母) //babgbag //^^ ^ //babgbag //^^ ^ //babgbag //^ ^^ //babgbag // ^ ^^ //babgbag // ^^^ // // // // 提示： // // // 0 \u0026lt;= s.length, t.length \u0026lt;= 1000 // s 和 t 由英文字母组成 // // Related Topics 字符串 动态规划 // 👍 308 👎 0 /* * 115 不同的子序列 * 2021-02-22 17:19:43 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int numDistinct(string s, string t) { int m = s.size(); int n = t.size(); // dp[i][j] means that s[0, i] equals t[0, j] vector\u0026lt;vector\u0026lt;long long\u0026gt;\u0026gt; dp(m + 1, vector\u0026lt;long long\u0026gt;(n + 1, 0)); for(int i = 0;i \u0026lt;= m;i++) dp[i][0] = 1; for(int i = 1;i \u0026lt;= m;i++){ for(int j = 1; j \u0026lt;= n;j++) { if(s[i-1] == t[j-1]){ dp[i][j] = dp[i-1][j] + dp[i-1][j-1]; }else{ dp[i][j] = dp[i-1][j]; } } } return (int)dp[m][n]; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/115%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/","summary":"//给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。 // // 字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余","title":"[115]不同的子序列"},{"content":"//一条包含字母 A-Z 的消息通过以下映射进行了 编码 ： // // //\u0026#39;A\u0026#39; -\u0026gt; 1 //\u0026#39;B\u0026#39; -\u0026gt; 2 //... //\u0026#39;Z\u0026#39; -\u0026gt; 26 // // // 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，\u0026#34;111\u0026#34; 可以将 \u0026#34;1\u0026#34; 中的每个 \u0026#34;1\u0026#34; 映射为 \u0026#34;A //\u0026#34; ，从而得到 \u0026#34;AAA\u0026#34; ，或者可以将 \u0026#34;11\u0026#34; 和 \u0026#34;1\u0026#34;（分别为 \u0026#34;K\u0026#34; 和 \u0026#34;A\u0026#34; ）映射为 \u0026#34;KA\u0026#34; 。注意，\u0026#34;06\u0026#34; 不能映射为 \u0026#34;F\u0026#34; ，因为 \u0026#34; //6\u0026#34; 和 \u0026#34;06\u0026#34; 不同。 // // 给你一个只含数字的 非空 字符串 num ，请计算并返回 解码 方法的 总数 。 // // 题目数据保证答案肯定是一个 32 位 的整数。 // // // // 示例 1： // // //输入：s = \u0026#34;12\u0026#34; //输出：2 //解释：它可以解码为 \u0026#34;AB\u0026#34;（1 2）或者 \u0026#34;L\u0026#34;（12）。 // // // 示例 2： // // //输入：s = \u0026#34;226\u0026#34; //输出：3 //解释：它可以解码为 \u0026#34;BZ\u0026#34; (2 26), \u0026#34;VF\u0026#34; (22 6), 或者 \u0026#34;BBF\u0026#34; (2 2 6) 。 // // // 示例 3： // // //输入：s = \u0026#34;0\u0026#34; //输出：0 //解释：没有字符映射到以 0 开头的数字。含有 0 的有效映射是 \u0026#39;J\u0026#39; -\u0026gt; \u0026#34;10\u0026#34; 和 \u0026#39;T\u0026#39;-\u0026gt; \u0026#34;20\u0026#34; 。由于没有字符，因此没有有效的方法对此进行 //解码，因为所有数字都需要映射。 // // // 示例 4： // // //输入：s = \u0026#34;06\u0026#34; //输出：0 //解释：\u0026#34;06\u0026#34; 不能映射到 \u0026#34;F\u0026#34; ，因为字符串开头的 0 无法指向一个有效的字符。 // // // // // 提示： // // // 1 \u0026lt;= s.length \u0026lt;= 100 // s 只包含数字，并且可能包含前导零。 // // Related Topics 字符串 动态规划 // 👍 621 👎 0 /* * 91 解码方法 * 2021-02-22 17:19:33 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int numDecodings(string s) { int n = s.length(); if(n \u0026lt;= 0) return 0; vector\u0026lt;int\u0026gt; dp(n, 0); // 处理边界情况 if(s[0] == \u0026#39;0\u0026#39;) return 0; dp[0] = 1; // 根据状态进行分类讨论 for(int i = 1;i \u0026lt; n;i++){ if(s[i] == \u0026#39;0\u0026#39;){ if(s[i-1] != \u0026#39;1\u0026#39; \u0026amp;\u0026amp; s[i-1] != \u0026#39;2\u0026#39;) return 0; if(i == 1) dp[i] = 1; else dp[i] = dp[i-2]; }else if(s[i-1] == \u0026#39;1\u0026#39; || (s[i-1] == \u0026#39;2\u0026#39; \u0026amp;\u0026amp; s[i] \u0026gt;= \u0026#39;1\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;6\u0026#39;)) if(i == 1) dp[i] = dp[i-1] + 1; else dp[i] = dp[i-1] + dp[i-2]; else dp[i] = dp[i-1]; } return dp.back(); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/91%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/","summary":"//一条包含字母 A-Z 的消息通过以下映射进行了 编码 ： // // //\u0026#39;A\u0026#39; -\u0026gt; 1 //\u0026#39;B\u0026#39; -\u0026gt; 2 //... //\u0026#39;Z\u0026#39; -\u0026gt; 26 // // // 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回","title":"[91]解码方法"},{"content":"//给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 // // 示例 1: // // 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5 //输出: 1-\u0026gt;2-\u0026gt;5 // // // 示例 2: // // 输入: 1-\u0026gt;1-\u0026gt;1-\u0026gt;2-\u0026gt;3 //输出: 2-\u0026gt;3 // Related Topics 链表 // 👍 456 👎 0 /* * 82 删除排序链表中的重复元素 II * 2021-02-22 17:19:22 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* deleteDuplicates(ListNode* head) { if(!head ||!head-\u0026gt;next) return head; ListNode dummy(-1); dummy.next = head; auto ptr = \u0026amp;dummy; // ptr mark end of target list // cur mark current node while(ptr-\u0026gt;next){ auto cur = ptr-\u0026gt;next; while(cur-\u0026gt;next \u0026amp;\u0026amp; cur-\u0026gt;next-\u0026gt;val == cur-\u0026gt;val){ // a--\u0026gt;a--\u0026gt;a--\u0026gt;b cur = cur-\u0026gt;next; } if(cur != ptr-\u0026gt;next) ptr-\u0026gt;next = cur-\u0026gt;next; // a-\u0026gt;b-\u0026gt;c-\u0026gt;d else ptr = ptr-\u0026gt;next; } return dummy.next; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/82%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii/","summary":"//给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 // // 示例 1: // // 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5 //输出: 1-\u0026gt;2-\u0026gt;5 // // // 示例 2: // // 输入","title":"[82]删除排序链表中的重复元素 II"},{"content":"//给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 // // 示例 1: // // 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, k = 2 //输出: 4-\u0026gt;5-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;NULL //解释: //向右旋转 1 步: 5-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;NULL //向右旋转 2 步: 4-\u0026gt;5-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;NULL // // // 示例 2: // // 输入: 0-\u0026gt;1-\u0026gt;2-\u0026gt;NULL, k = 4 //输出: 2-\u0026gt;0-\u0026gt;1-\u0026gt;NULL //解释: //向右旋转 1 步: 2-\u0026gt;0-\u0026gt;1-\u0026gt;NULL //向右旋转 2 步: 1-\u0026gt;2-\u0026gt;0-\u0026gt;NULL //向右旋转 3 步: 0-\u0026gt;1-\u0026gt;2-\u0026gt;NULL //向右旋转 4 步: 2-\u0026gt;0-\u0026gt;1-\u0026gt;NULL // Related Topics 链表 双指针 // 👍 426 👎 0 /* * 61 旋转链表 * 2021-02-22 17:19:12 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* rotateRight(ListNode* head, int k) { if(!head) return nullptr; int n = 1; auto ptr = head; while(ptr-\u0026gt;next){ ptr = ptr-\u0026gt;next; n++; } ptr-\u0026gt;next = head; int m = n - k % n; for(int i = 0;i \u0026lt; m;i++){ ptr = ptr-\u0026gt;next; } auto ans = ptr-\u0026gt;next; ptr-\u0026gt;next = nullptr; return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/61%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/","summary":"//给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 // // 示例 1: // // 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL, k = 2 //输出: 4-\u0026gt;5-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;NULL //解释: //向右旋转 1","title":"[61]旋转链表"},{"content":"//给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 // // 你可以对一个单词进行如下三种操作： // // // 插入一个字符 // 删除一个字符 // 替换一个字符 // // // // // 示例 1： // // //输入：word1 = \u0026#34;horse\u0026#34;, word2 = \u0026#34;ros\u0026#34; //输出：3 //解释： //horse -\u0026gt; rorse (将 \u0026#39;h\u0026#39; 替换为 \u0026#39;r\u0026#39;) //rorse -\u0026gt; rose (删除 \u0026#39;r\u0026#39;) //rose -\u0026gt; ros (删除 \u0026#39;e\u0026#39;) // // // 示例 2： // // //输入：word1 = \u0026#34;intention\u0026#34;, word2 = \u0026#34;execution\u0026#34; //输出：5 //解释： //intention -\u0026gt; inention (删除 \u0026#39;t\u0026#39;) //inention -\u0026gt; enention (将 \u0026#39;i\u0026#39; 替换为 \u0026#39;e\u0026#39;) //enention -\u0026gt; exention (将 \u0026#39;n\u0026#39; 替换为 \u0026#39;x\u0026#39;) //exention -\u0026gt; exection (将 \u0026#39;n\u0026#39; 替换为 \u0026#39;c\u0026#39;) //exection -\u0026gt; execution (插入 \u0026#39;u\u0026#39;) // // // // // 提示： // // // 0 \u0026lt;= word1.length, word2.length \u0026lt;= 500 // word1 和 word2 由小写英文字母组成 // // Related Topics 字符串 动态规划 // 👍 1415 👎 0 /* * 72 编辑距离 * 2021-02-22 17:19:02 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int minDistance(string word1, string word2) { int m = word1.size(); int n = word2.size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m + 1, vector\u0026lt;int\u0026gt;(n + 1, 0)); for(int i = 0;i \u0026lt;= m;i++) dp[i][0] = i; for(int j = 1;j \u0026lt;= n;j++) dp[0][j] = j; for(int i = 1;i \u0026lt;= m;i++){ for(int j = 1;j \u0026lt;= n;j++){ if(word1[i-1] == word2[j-1]) dp[i][j] = dp[i-1][j-1]; else dp[i][j] = min(min(dp[i][j-1] + 1, dp[i-1][j] + 1), dp[i-1][j-1] + 1); } } return dp.back().back(); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/72%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/","summary":"//给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 // // 你可以对一个单词进行如下三种操作： // // // 插入一个字符 // 删除一个","title":"[72]编辑距离"},{"content":"//给你一个链表数组，每个链表都已经按升序排列。 // // 请你将所有链表合并到一个升序链表中，返回合并后的链表。 // // // // 示例 1： // // 输入：lists = [[1,4,5],[1,3,4],[2,6]] //输出：[1,1,2,3,4,4,5,6] //解释：链表数组如下： //[ // 1-\u0026gt;4-\u0026gt;5, // 1-\u0026gt;3-\u0026gt;4, // 2-\u0026gt;6 //] //将它们合并到一个有序链表中得到。 //1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4-\u0026gt;5-\u0026gt;6 // // // 示例 2： // // 输入：lists = [] //输出：[] // // // 示例 3： // // 输入：lists = [[]] //输出：[] // // // // // 提示： // // // k == lists.length // 0 \u0026lt;= k \u0026lt;= 10^4 // 0 \u0026lt;= lists[i].length \u0026lt;= 500 // -10^4 \u0026lt;= lists[i][j] \u0026lt;= 10^4 // lists[i] 按 升序 排列 // lists[i].length 的总和不超过 10^4 // // Related Topics 堆 链表 分治算法 // 👍 1148 👎 0 /* * 23 合并K个升序链表 * 2021-02-22 17:18:56 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: struct cmp{ bool operator() (ListNode* a, ListNode* b){ return a-\u0026gt;val \u0026gt; b-\u0026gt;val; } }; ListNode* mergeKLists(vector\u0026lt;ListNode*\u0026gt;\u0026amp; lists) { if(lists.size() == 0) return nullptr; if(lists.size() == 1) return lists[0]; priority_queue\u0026lt;ListNode*, vector\u0026lt;ListNode*\u0026gt;, cmp\u0026gt; pq; for(int i = 0;i \u0026lt; lists.size();i++){ auto t = lists[i]; if(t) pq.push(t); } ListNode dummy(-1); auto ptr = \u0026amp;dummy; while(pq.size()){ auto t = pq.top(); pq.pop(); if(t-\u0026gt;next) pq.push(t-\u0026gt;next); ptr-\u0026gt;next = t; ptr = ptr-\u0026gt;next; } return dummy.next; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/23%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/","summary":"//给你一个链表数组，每个链表都已经按升序排列。 // // 请你将所有链表合并到一个升序链表中，返回合并后的链表。 // // // // 示例 1： // // 输入：list","title":"[23]合并K个升序链表"},{"content":"//给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 // // 进阶：你能尝试使用一趟扫描实现吗？ // // // // 示例 1： // // //输入：head = [1,2,3,4,5], n = 2 //输出：[1,2,3,5] // // // 示例 2： // // //输入：head = [1], n = 1 //输出：[] // // // 示例 3： // // //输入：head = [1,2], n = 1 //输出：[1] // // // // // 提示： // // // 链表中结点的数目为 sz // 1 \u0026lt;= sz \u0026lt;= 30 // 0 \u0026lt;= Node.val \u0026lt;= 100 // 1 \u0026lt;= n \u0026lt;= sz // // Related Topics 链表 双指针 // 👍 1226 👎 0 /* * 19 删除链表的倒数第 N 个结点 * 2021-02-22 17:18:53 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* removeNthFromEnd(ListNode* head, int n) { if(!head-\u0026gt;next \u0026amp;\u0026amp; n == 1){ return nullptr; } auto fast = head, slow = head; while(n--) if(fast) fast = fast-\u0026gt;next; if(!fast) return head-\u0026gt;next; auto keep = slow; while(fast){ fast = fast-\u0026gt;next; keep = slow; slow = slow-\u0026gt;next; } keep-\u0026gt;next = slow-\u0026gt;next; return head; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/19%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9/","summary":"//给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 // // 进阶：你能尝试使用一趟扫描实现吗？ // // // // 示例 1： // // //输入：hea","title":"[19]删除链表的倒数第 N 个结点"},{"content":"//给你一个字符串 s，找到 s 中最长的回文子串。 // // // // 示例 1： // // //输入：s = \u0026#34;babad\u0026#34; //输出：\u0026#34;bab\u0026#34; //解释：\u0026#34;aba\u0026#34; 同样是符合题意的答案。 // // // 示例 2： // // //输入：s = \u0026#34;cbbd\u0026#34; //输出：\u0026#34;bb\u0026#34; // // // 示例 3： // // //输入：s = \u0026#34;a\u0026#34; //输出：\u0026#34;a\u0026#34; // // // 示例 4： // // //输入：s = \u0026#34;ac\u0026#34; //输出：\u0026#34;a\u0026#34; // // // // // 提示： // // // 1 \u0026lt;= s.length \u0026lt;= 1000 // s 仅由数字和英文字母（大写和/或小写）组成 // // Related Topics 字符串 动态规划 // 👍 3225 👎 0 /* * 5 最长回文子串 * 2021-02-22 17:18:48 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: string str; string longestPalindrome(string s) { str = s; const int n = s.size(); int len = 0, left, right; for(int i = 0;i \u0026lt; n;i++) { int x = i, y = i; int a = aux(x, y); if (a \u0026gt; len) { len = a; left = x; right = y; } x = i, y = i + 1; int b = aux(x, y); if (b \u0026gt; len) { len = b; left = x; right = y; } } return s.substr(left, right - left + 1); } int aux(int\u0026amp; left, int\u0026amp; right){ const int n = str.size(); while(left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; n \u0026amp;\u0026amp; str[left] == str[right]) left--, right++; left++; right--; return right - left + 1; } }; class Solution2 { public: string longestPalindrome(string s) { if(s.size() \u0026lt; 2) return s; const int n = s.length(); int maxLeft = 0; int maxLength = 1; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(n,vector\u0026lt;bool\u0026gt;(n,false)); for(int i = 0;i \u0026lt; n;i++){ for(int j = 0;j \u0026lt; i;j++){ if(s[i] == s[j] \u0026amp;\u0026amp; ((i - j) \u0026lt;= 2 || dp[j+1][i-1])){ dp[j][i] = true; if(i - j + 1 \u0026gt; maxLength){ maxLeft = j; maxLength = i - j + 1; } } } } return s.substr(maxLeft, maxLength); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/","summary":"//给你一个字符串 s，找到 s 中最长的回文子串。 // // // // 示例 1： // // //输入：s = \u0026#34;babad\u0026#34; //输出：\u0026#34;bab\u0026#34; //解释：\u0026#34;a","title":"[5]最长回文子串"},{"content":"//给定一个二叉树，检查它是否是镜像对称的。 // // // // 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 // // 1 // / \\ // 2 2 // / \\ / \\ //3 4 4 3 // // // // // 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: // // 1 // / \\ // 2 2 // \\ \\ // 3 3 // // // // // 进阶： // // 你可以运用递归和迭代两种方法解决这个问题吗？ // Related Topics 树 深度优先搜索 广度优先搜索 // 👍 1244 👎 0 /* * 101 对称二叉树 * 2021-02-22 17:14:13 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isSymmetric(TreeNode* root) { if(!root) return true; if(!root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right) return true; if(!root-\u0026gt;left || !root-\u0026gt;right) return false; return symmetric(root-\u0026gt;left, root-\u0026gt;right); } bool symmetric(TreeNode* le, TreeNode* ri){ if(!le \u0026amp;\u0026amp; !ri) return true; if(!le || !ri) return false; if(le-\u0026gt;val != ri-\u0026gt;val) return false; return symmetric(le-\u0026gt;left, ri-\u0026gt;right) \u0026amp;\u0026amp; symmetric(le-\u0026gt;right, ri-\u0026gt;left); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"//给定一个二叉树，检查它是否是镜像对称的。 // // // // 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 // // 1 // / \\ // 2 2 // / \\ / \\ //3 4 4 3 // // // // // 但是下面这个 [1,2,2,null,3,null,3] 则不","title":"[101]对称二叉树"},{"content":"//给定一个 没有重复 数字的序列，返回其所有可能的全排列。 // // 示例: // // 输入: [1,2,3] //输出: //[ // [1,2,3], // [1,3,2], // [2,1,3], // [2,3,1], // [3,1,2], // [3,2,1] //] // Related Topics 回溯算法 // 👍 1142 👎 0 /* * 46 全排列 * 2021-02-22 16:18:01 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; cur; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; permute(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); vector\u0026lt;bool\u0026gt; vis(n + 1, false); dfs(n, nums, vis); return ans; } void dfs(int n, vector\u0026lt;int\u0026gt;\u0026amp; nums, vector\u0026lt;bool\u0026gt;\u0026amp; vis){ if(cur.size() == n){ ans.push_back(cur); return ; } for(int i = 1;i \u0026lt;= n;i++){ if(!vis[i]){ cur.push_back(nums[i-1]); vis[i] = true; dfs(n, nums, vis); vis[i] = false; cur.pop_back(); } } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/46%E5%85%A8%E6%8E%92%E5%88%97/","summary":"//给定一个 没有重复 数字的序列，返回其所有可能的全排列。 // // 示例: // // 输入: [1,2,3] //输出: //[ // [1,2,3], // [1,3,2], // [2,1,3], // [2,3,1], // [3,1,2], // [3,2,1] //] // Related Topics 回溯算法 // 👍 1142 👎 0","title":"[46]全排列"},{"content":"//给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 // // 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 // // // // 示例 1： // // //输入：nums = [1,2,3] //输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] // // // 示例 2： // // //输入：nums = [0] //输出：[[],[0]] // // // // // 提示： // // // 1 \u0026lt;= nums.length \u0026lt;= 10 // -10 \u0026lt;= nums[i] \u0026lt;= 10 // nums 中的所有元素 互不相同 // // Related Topics 位运算 数组 回溯算法 // 👍 1001 👎 0 /* * 78 子集 * 2021-02-22 16:17:47 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; cur; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; subsets(vector\u0026lt;int\u0026gt;\u0026amp; nums) { dfs(0, nums); return ans; } // 子集、组合类问题，无关顺序，关键是用一个 start 参数来对数组进行筛选 void dfs(int start, vector\u0026lt;int\u0026gt;\u0026amp; nums){ ans.push_back(cur); for(int i = start;i \u0026lt; nums.size();i++){ cur.push_back(nums[i]); dfs(i+1, nums); cur.pop_back(); } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/78%E5%AD%90%E9%9B%86/","summary":"//给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 // // 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 // // //","title":"[78]子集"},{"content":"//给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。 // // 示例: // // 输入: n = 4, k = 2 //输出: //[ // [2,4], // [3,4], // [2,3], // [1,2], // [1,3], // [1,4], //] // Related Topics 回溯算法 // 👍 499 👎 0 /* * 77 组合 * 2021-02-22 16:17:43 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; vector\u0026lt;int\u0026gt; cur; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; combine(int n, int k) { if(k \u0026gt; n || k \u0026lt;= 0) return ans; dfs(n, k, 1); return ans; } void dfs(int n, int k, int level){ if(cur.size() == k){ ans.push_back(cur); return ; } if(n - level + 1 \u0026lt; k - cur.size()) return ; // 剪枝 for(int i = level;i \u0026lt;= n;i++){ cur.push_back(i); dfs(n, k, i+1); cur.pop_back(); } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/77%E7%BB%84%E5%90%88/","summary":"//给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。 // // 示例: // // 输入: n = 4, k = 2 //输出: //[ // [2,4], // [3,4], // [2,3], // [1,2], // [1,3], // [1,4], //] // Related Topics 回溯","title":"[77]组合"},{"content":"//给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 // // 示例: // // 输入: [0,1,0,3,12] //输出: [1,3,12,0,0] // // 说明: // // // 必须在原数组上操作，不能拷贝额外的数组。 // 尽量减少操作次数。 // // Related Topics 数组 双指针 // 👍 956 👎 0 /* * 283 移动零 * 2021-02-22 10:43:13 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: void moveZeroes(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int j = 0; // mark end of non-zero seq for(int i = 0;i \u0026lt; n;i++){ if(nums[i]){ swap(nums[i], nums[j]); j++; } } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/283%E7%A7%BB%E5%8A%A8%E9%9B%B6/","summary":"//给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 // // 示例: // // 输入: [0,1,0,3,12] //输出: [1,3,12,0,0] // // 说明: // //","title":"[283]移动零"},{"content":"//在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 // // 示例 1: // // 输入: [3,2,1,5,6,4] 和 k = 2 //输出: 5 // // // 示例 2: // // 输入: [3,2,3,1,2,4,5,5,6] 和 k = 4 //输出: 4 // // 说明: // // 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 // Related Topics 堆 分治算法 // 👍 896 👎 0 /* * 215 数组中的第K个最大元素 * 2021-02-22 10:40:03 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int findKthLargest(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { priority_queue\u0026lt;int\u0026gt; pq(nums.begin(), nums.end()); for(int i = 0;i \u0026lt; k - 1;i++){ pq.pop(); } return pq.top(); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/215%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/","summary":"//在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 // // 示例 1: // // 输入: [3,2,1,5,6,4] 和","title":"[215]数组中的第K个最大元素"},{"content":"//请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 // // 函数 myAtoi(string s) 的算法如下： // // // 读入字符串并丢弃无用的前导空格 // 检查第一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。 // 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。 // 将前面步骤读入的这些数字转换为整数（即，\u0026#34;123\u0026#34; -\u0026gt; 123， \u0026#34;0032\u0026#34; -\u0026gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 //2 开始）。 // 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固 //定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。 // 返回整数作为最终结果。 // // // 注意： // // // 本题中的空白字符只包括空格字符 \u0026#39; \u0026#39; 。 // 除前导空格或数字后的其余字符串外，请勿忽略 任何其他字符。 // // // // // 示例 1： // // //输入：s = \u0026#34;42\u0026#34; //输出：42 //解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。 //第 1 步：\u0026#34;42\u0026#34;（当前没有读入字符，因为没有前导空格） // ^ //第 2 步：\u0026#34;42\u0026#34;（当前没有读入字符，因为这里不存在 \u0026#39;-\u0026#39; 或者 \u0026#39;+\u0026#39;） // ^ //第 3 步：\u0026#34;42\u0026#34;（读入 \u0026#34;42\u0026#34;） // ^ //解析得到整数 42 。 //由于 \u0026#34;42\u0026#34; 在范围 [-231, 231 - 1] 内，最终结果为 42 。 // // 示例 2： // // //输入：s = \u0026#34; -42\u0026#34; //输出：-42 //解释： //第 1 步：\u0026#34; -42\u0026#34;（读入前导空格，但忽视掉） // ^ //第 2 步：\u0026#34; -42\u0026#34;（读入 \u0026#39;-\u0026#39; 字符，所以结果应该是负数） // ^ //第 3 步：\u0026#34; -42\u0026#34;（读入 \u0026#34;42\u0026#34;） // ^ //解析得到整数 -42 。 //由于 \u0026#34;-42\u0026#34; 在范围 [-231, 231 - 1] 内，最终结果为 -42 。 // // // 示例 3： // // //输入：s = \u0026#34;4193 with words\u0026#34; //输出：4193 //解释： //第 1 步：\u0026#34;4193 with words\u0026#34;（当前没有读入字符，因为没有前导空格） // ^ //第 2 步：\u0026#34;4193 with words\u0026#34;（当前没有读入字符，因为这里不存在 \u0026#39;-\u0026#39; 或者 \u0026#39;+\u0026#39;） // ^ //第 3 步：\u0026#34;4193 with words\u0026#34;（读入 \u0026#34;4193\u0026#34;；由于下一个字符不是一个数字，所以读入停止） // ^ //解析得到整数 4193 。 //由于 \u0026#34;4193\u0026#34; 在范围 [-231, 231 - 1] 内，最终结果为 4193 。 // // // 示例 4： // // //输入：s = \u0026#34;words and 987\u0026#34; //输出：0 //解释： //第 1 步：\u0026#34;words and 987\u0026#34;（当前没有读入字符，因为没有前导空格） // ^ //第 2 步：\u0026#34;words and 987\u0026#34;（当前没有读入字符，因为这里不存在 \u0026#39;-\u0026#39; 或者 \u0026#39;+\u0026#39;） // ^ //第 3 步：\u0026#34;words and 987\u0026#34;（由于当前字符 \u0026#39;w\u0026#39; 不是一个数字，所以读入停止） // ^ //解析得到整数 0 ，因为没有读入任何数字。 //由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。 // // 示例 5： // // //输入：s = \u0026#34;-91283472332\u0026#34; //输出：-2147483648 //解释： //第 1 步：\u0026#34;-91283472332\u0026#34;（当前没有读入字符，因为没有前导空格） // ^ //第 2 步：\u0026#34;-91283472332\u0026#34;（读入 \u0026#39;-\u0026#39; 字符，所以结果应该是负数） // ^ //第 3 步：\u0026#34;-91283472332\u0026#34;（读入 \u0026#34;91283472332\u0026#34;） // ^ //解析得到整数 -91283472332 。 //由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。 // // // // 提示： // // // 0 \u0026lt;= s.length \u0026lt;= 200 // s 由英文字母（大写和小写）、数字（0-9）、\u0026#39; \u0026#39;、\u0026#39;+\u0026#39;、\u0026#39;-\u0026#39; 和 \u0026#39;.\u0026#39; 组成 // // Related Topics 数学 字符串 // 👍 991 👎 0 /* * 8 字符串转换整数 (atoi) * 2021-02-22 09:56:20 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int myAtoi(string s) { if(!s.length()) return 0; int i = 0; while(s[i] == \u0026#39; \u0026#39;) i++; bool flag = true; if(s[i] == \u0026#39;+\u0026#39;) flag = true, i++; else if(s[i] == \u0026#39;-\u0026#39;) flag = false, i++; s = s.substr(i); long long int ans = 0; for(int k = 0;k \u0026lt; s.size();k++){ if(s[k] - \u0026#39;0\u0026#39; \u0026lt;= 9 \u0026amp;\u0026amp; s[k] - \u0026#39;0\u0026#39; \u0026gt;= 0) continue; else if(k) s = s.substr(0, k); else return 0; } for(int j = 0;j \u0026lt; s.size();j++){ ans = ans * 10; ans += s[j] - \u0026#39;0\u0026#39;; if(ans \u0026gt; INT_MAX) { if(flag) return INT_MAX; else return INT_MIN; } } return flag ? ans : -ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/8%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/","summary":"//请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 // // 函数 myAtoi(string s) 的算法如下： // // // 读入字符串并丢弃无用的","title":"[8]字符串转换整数 (atoi)"},{"content":"//给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。 // // 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。 //假设环境不允许存储 64 位整数（有符号或无符号）。 // // // // 示例 1： // // //输入：x = 123 //输出：321 // // // 示例 2： // // //输入：x = -123 //输出：-321 // // // 示例 3： // // //输入：x = 120 //输出：21 // // // 示例 4： // // //输入：x = 0 //输出：0 // // // // // 提示： // // // -231 \u0026lt;= x \u0026lt;= 231 - 1 // // Related Topics 数学 // 👍 2541 👎 0 /* * 7 整数反转 * 2021-02-22 09:46:04 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int reverse(int x) { if(!x) return 0; bool flag = x \u0026gt; 0 ? true : false; x = abs(x); long long int res = 0; while(x){ res = res * 10; res += x % 10; x /= 10; } if(res \u0026gt; INT_MAX || res \u0026lt; INT_MIN) return 0; return flag ? res : -res; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/7%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","summary":"//给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。 // // 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。","title":"[7]整数反转"},{"content":"//给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重 //复的三元组。 // // 注意：答案中不可以包含重复的三元组。 // // // // 示例 1： // // //输入：nums = [-1,0,1,2,-1,-4] //输出：[[-1,-1,2],[-1,0,1]] // // // 示例 2： // // //输入：nums = [] //输出：[] // // // 示例 3： // // //输入：nums = [0] //输出：[] // // // // // 提示： // // // 0 \u0026lt;= nums.length \u0026lt;= 3000 // -105 \u0026lt;= nums[i] \u0026lt;= 105 // // Related Topics 数组 双指针 // 👍 2981 👎 0 /* * 15 三数之和 * 2021-02-22 09:01:42 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution2 { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { set\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; sort(nums.begin(), nums.end()); if(nums.size() \u0026lt; 3 || nums.front() \u0026gt; 0 || nums.back() \u0026lt; 0) return {}; // nums has been sorted for(int k = 0;k \u0026lt; nums.size() - 2;k++){ if(nums[k] \u0026gt; 0) break; int target = 0 - nums[k], i = k + 1, j = nums.size() - 1; while(i \u0026lt; j){ if(nums[i] + nums[j] == target){ ans.insert({nums[k], nums[i], nums[j]}); while(i \u0026lt; j \u0026amp;\u0026amp; nums[i] == nums[i+1]) i++; while(i \u0026lt; j \u0026amp;\u0026amp; nums[j] == nums[j-1]) j--; ++i, --j; }else if(nums[i] + nums[j] \u0026lt; target){ ++i; }else --j; } } return vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;(ans.begin(), ans.end()); } }; class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; threeSum(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; sort(nums.begin(), nums.end()); if(nums.size() \u0026lt; 3 || nums.front() \u0026gt; 0 || nums.back() \u0026lt; 0) return {}; // nums has been sorted for(int k = 0;k \u0026lt; nums.size() - 2;k++){ if(nums[k] \u0026gt; 0) break; //剪枝 if (k \u0026gt; 0 \u0026amp;\u0026amp; nums[k] == nums[k - 1]) continue; // 判重 int target = 0 - nums[k], i = k + 1, j = nums.size() - 1; while(i \u0026lt; j){ if(nums[i] + nums[j] == target){ ans.push_back({nums[k], nums[i], nums[j]}); while(i \u0026lt; j \u0026amp;\u0026amp; nums[i] == nums[i+1]) i++; while(i \u0026lt; j \u0026amp;\u0026amp; nums[j] == nums[j-1]) j--; ++i, --j; }else if(nums[i] + nums[j] \u0026lt; target){ ++i; }else --j; } } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/15%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"//给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重 //复的三元组。 // //","title":"[15]三数之和"},{"content":"//给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 // // // // 示例 1： // // //输入：root = [1,null,2,3] //输出：[1,2,3] // // // 示例 2： // // //输入：root = [] //输出：[] // // // 示例 3： // // //输入：root = [1] //输出：[1] // // // 示例 4： // // //输入：root = [1,2] //输出：[1,2] // // // 示例 5： // // //输入：root = [1,null,2] //输出：[1,2] // // // // // 提示： // // // 树中节点数目在范围 [0, 100] 内 // -100 \u0026lt;= Node.val \u0026lt;= 100 // // // // // 进阶：递归算法很简单，你可以通过迭代算法完成吗？ // Related Topics 栈 树 // 👍 514 👎 0 /* * 144 二叉树的前序遍历 * 2021-02-22 08:51:19 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; ans; if(!root) return ans; stack\u0026lt;TreeNode*\u0026gt; stk; auto ptr = root; while(stk.size() || ptr){ if(ptr) ans.push_back(ptr-\u0026gt;val), stk.push(ptr), ptr = ptr-\u0026gt;left; else ptr = stk.top(), stk.pop(), ptr = ptr-\u0026gt;right; } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/144%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/","summary":"//给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 // // // // 示例 1： // // //输入：root = [1,null,2,3] //输出：[1,2,3] // // // 示例 2： // // //输","title":"[144]二叉树的前序遍历"},{"content":"//反转一个单链表。 // // 示例: // // 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL //输出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL // // 进阶: //你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ // Related Topics 链表 // 👍 1518 👎 0 /* * 206 反转链表 * 2021-02-21 22:36:27 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { if(!head || !head-\u0026gt;next) return head; ListNode* pre = nullptr; auto cur = head; while(cur){ auto t = cur-\u0026gt;next; cur-\u0026gt;next = pre; pre = cur; cur = t; } return pre; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","summary":"//反转一个单链表。 // // 示例: // // 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL //输出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL // // 进阶: //你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ // Related Topics 链表 // 👍 1518","title":"[206]反转链表"},{"content":"//编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 \u0026#39;1\u0026#39; 的个数（也被称为汉明重量）。 // // // // 提示： // // // 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的 //还是无符号的，其内部的二进制表示形式都是相同的。 // 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 3 中，输入表示有符号整数 -3。 // // // // // 进阶： // // // 如果多次调用这个函数，你将如何优化你的算法？ // // // // // 示例 1： // // //输入：00000000000000000000000000001011 //输出：3 //解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 \u0026#39;1\u0026#39;。 // // // 示例 2： // // //输入：00000000000000000000000010000000 //输出：1 //解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 \u0026#39;1\u0026#39;。 // // // 示例 3： // // //输入：11111111111111111111111111111101 //输出：31 //解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 \u0026#39;1\u0026#39;。 // // // // 提示： // // // 输入必须是长度为 32 的 二进制串 。 // // // // // // // Related Topics 位运算 // 👍 253 👎 0 /* * 191 位1的个数 * 2021-02-21 22:34:05 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int hammingWeight(uint32_t n) { int ans = 0; for(int i = 31;i \u0026gt;= 0;i--){ if(n \u0026gt;\u0026gt; i \u0026amp; 1) ans ++; } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/191%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/","summary":"//编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 \u0026#39;1\u0026#39; 的个数（也被称为汉明重量）。 // // // // 提示： // // //","title":"[191]位1的个数"},{"content":"//给定一个二叉树，找出其最小深度。 // // 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 // // 说明：叶子节点是指没有子节点的节点。 // // // // 示例 1： // // //输入：root = [3,9,20,null,null,15,7] //输出：2 // // // 示例 2： // // //输入：root = [2,null,3,null,4,null,5,null,6] //输出：5 // // // // // 提示： // // // 树中节点数的范围在 [0, 105] 内 // -1000 \u0026lt;= Node.val \u0026lt;= 1000 // // Related Topics 树 深度优先搜索 广度优先搜索 // 👍 455 👎 0 /* * 111 二叉树的最小深度 * 2021-02-21 22:26:17 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int minDepth(TreeNode* root) { int ans = 0; if(!root) return ans; vector\u0026lt;int\u0026gt; cur; queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); bool flag = true; while(q.size()){ int n = q.size(); if(!flag) break; ans ++ ; for(int i = n-1;i \u0026gt;= 0;i--){ auto t = q.front(); q.pop(); if(!t-\u0026gt;left \u0026amp;\u0026amp; !t-\u0026gt;right){ flag = false; break; } if(t-\u0026gt;left) q.push(t-\u0026gt;left); if(t-\u0026gt;right) q.push(t-\u0026gt;right); } } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/111%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/","summary":"//给定一个二叉树，找出其最小深度。 // // 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 // // 说明：叶子节点是指没有子节点的节点。 // //","title":"[111]二叉树的最小深度"},{"content":"//给定一个二叉树，找出其最大深度。 // // 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 // // 说明: 叶子节点是指没有子节点的节点。 // // 示例： //给定二叉树 [3,9,20,null,null,15,7]， // // 3 // / \\ // 9 20 // / \\ // 15 7 // // 返回它的最大深度 3 。 // Related Topics 树 深度优先搜索 递归 // 👍 797 👎 0 /* * 104 二叉树的最大深度 * 2021-02-21 22:15:34 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution2 { public: int maxDepth(TreeNode* root) { if(!root) return 0; return max(maxDepth(root-\u0026gt;left), maxDepth(root-\u0026gt;right)) + 1; } }; class Solution { public: int maxDepth(TreeNode* root) { if(!root) return 0; queue\u0026lt;TreeNode*\u0026gt; q; int ans = 0; TreeNode* ptr; q.push(root); while(!q.empty()){ int n = q.size()-1; ans ++; for(int i = n;i \u0026gt;= 0;i-- ){ ptr = q.front();q.pop(); if(ptr-\u0026gt;left) q.push(ptr-\u0026gt;left); if(ptr-\u0026gt;right) q.push(ptr-\u0026gt;right); } } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/","summary":"//给定一个二叉树，找出其最大深度。 // // 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 // // 说明: 叶子节点是指没有子节点的节点。 // //","title":"[104]二叉树的最大深度"},{"content":"//给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 // // // // 示例： //二叉树：[3,9,20,null,null,15,7], // // // 3 // / \\ // 9 20 // / \\ // 15 7 // // // 返回其层序遍历结果： // // //[ // [3], // [9,20], // [15,7] //] // // Related Topics 树 广度优先搜索 // 👍 775 👎 0 /* * 102 二叉树的层序遍历 * 2021-02-21 22:15:25 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; if(!root) return ans; vector\u0026lt;int\u0026gt; cur; queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); while(q.size()){ int n = q.size(); cur.clear(); for(int i = n-1;i \u0026gt;= 0;i--){ auto t = q.front(); cur.push_back(t-\u0026gt;val); q.pop(); if(t-\u0026gt;left) q.push(t-\u0026gt;left); if(t-\u0026gt;right) q.push(t-\u0026gt;right); } ans.push_back(cur); } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/","summary":"//给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 // // // // 示例： //二叉树：[3,9,20,null","title":"[102]二叉树的层序遍历"},{"content":"//给定一个二叉树的根节点 root ，返回它的 中序 遍历。 // // // // 示例 1： // // //输入：root = [1,null,2,3] //输出：[1,3,2] // // // 示例 2： // // //输入：root = [] //输出：[] // // // 示例 3： // // //输入：root = [1] //输出：[1] // // // 示例 4： // // //输入：root = [1,2] //输出：[2,1] // // // 示例 5： // // //输入：root = [1,null,2] //输出：[1,2] // // // // // 提示： // // // 树中节点数目在范围 [0, 100] 内 // -100 \u0026lt;= Node.val \u0026lt;= 100 // // // // // 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ // Related Topics 栈 树 哈希表 // 👍 861 👎 0 /* * 94 二叉树的中序遍历 * 2021-02-21 22:02:35 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution2 { public: vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { dfs(root); return ans; } void dfs(TreeNode* root){ if(!root) return ; dfs(root-\u0026gt;left); ans.push_back(root-\u0026gt;val); dfs(root-\u0026gt;right); } }; class Solution { public: vector\u0026lt;int\u0026gt; ans; vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { if(!root) return ans; stack\u0026lt;TreeNode*\u0026gt; stk; auto ptr = root; while(stk.size() || ptr){ // stk is not empty or ptr isn\u0026#39;t nullptr if(ptr) stk.push(ptr), ptr = ptr-\u0026gt;left ; // go to the left node else { ptr = stk.top();stk.pop(); ans.push_back(ptr-\u0026gt;val); ptr = ptr-\u0026gt;right; } } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/","summary":"//给定一个二叉树的根节点 root ，返回它的 中序 遍历。 // // // // 示例 1： // // //输入：root = [1,null,2,3] //输出：[1,3,2] // // // 示例 2： // // //输入","title":"[94]二叉树的中序遍历"},{"content":"//给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 // // 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点 //。 // // 示例 1: // // //输入: //\tTree 1 Tree 2 // 1 2 // / \\ / \\ // 3 2 1 3 // / \\ \\ // 5 4 7 //输出: //合并后的树: //\t3 //\t/ \\ //\t4 5 //\t/ \\ \\ //\t5 4 7 // // // 注意: 合并必须从两个树的根节点开始。 // Related Topics 树 // 👍 624 👎 0 /* * 617 合并二叉树 * 2021-02-21 21:47:00 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) { if(!root1 || !root2) return root1 ? cp(root1) : cp(root2); TreeNode* result = new TreeNode(root1-\u0026gt;val + root2-\u0026gt;val); result-\u0026gt;left = mergeTrees(root1-\u0026gt;left,root2-\u0026gt;left); result-\u0026gt;right = mergeTrees(root1-\u0026gt;right, root2-\u0026gt;right); return result; } TreeNode* cp(TreeNode* root){ if(!root) return nullptr; TreeNode* result = new TreeNode(root-\u0026gt;val); result-\u0026gt;left = cp(root-\u0026gt;left); result-\u0026gt;right = cp(root-\u0026gt;right); return result; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/617%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"//给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 // // 你需要将他们合并为一个新的二叉树。合并的规则是","title":"[617]合并二叉树"},{"content":"//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 // // 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 // // 问总共有多少条不同的路径？ // // // // 示例 1： // // //输入：m = 3, n = 7 //输出：28 // // 示例 2： // // //输入：m = 3, n = 2 //输出：3 //解释： //从左上角开始，总共有 3 条路径可以到达右下角。 //1. 向右 -\u0026gt; 向下 -\u0026gt; 向下 //2. 向下 -\u0026gt; 向下 -\u0026gt; 向右 //3. 向下 -\u0026gt; 向右 -\u0026gt; 向下 // // // 示例 3： // // //输入：m = 7, n = 3 //输出：28 // // // 示例 4： // // //输入：m = 3, n = 3 //输出：6 // // // // 提示： // // // 1 \u0026lt;= m, n \u0026lt;= 100 // 题目数据保证答案小于等于 2 * 109 // // Related Topics 数组 动态规划 // 👍 888 👎 0 /* * 62 不同路径 * 2021-02-21 21:20:49 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int uniquePaths(int m, int n) { if(m \u0026lt;= 0 || n \u0026lt;= 0) return 0; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n, 0)); for(int i = 0;i \u0026lt; m;i++){ for(int j = 0;j \u0026lt; n;j++){ if(i == 0 || j == 0) dp[i][j] = 1; else dp[i][j] = dp[i-1][j] + dp[i][j-1]; } } return dp.back().back(); } }; class Solution2 { public: int uniquePaths(int m, int n) { vector\u0026lt;int\u0026gt; dp(n, 1); // if (!i || !j) dp[i] = 1; for(int i = 1;i \u0026lt; m;i++){ for(int j = 1;j \u0026lt; n;j++){ dp[j] += dp[j-1]; } } return dp.back(); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/62%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/","summary":"//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 // // 机器人每次只能向下或者向右移动一步。机器人试图达到网格的","title":"[62]不同路径"},{"content":"//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 // // 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 // // 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ // // // // 网格中的障碍物和空位置分别用 1 和 0 来表示。 // // // // 示例 1： // // //输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] //输出：2 //解释： //3x3 网格的正中间有一个障碍物。 //从左上角到右下角一共有 2 条不同的路径： //1. 向右 -\u0026gt; 向右 -\u0026gt; 向下 -\u0026gt; 向下 //2. 向下 -\u0026gt; 向下 -\u0026gt; 向右 -\u0026gt; 向右 // // // 示例 2： // // //输入：obstacleGrid = [[0,1],[0,0]] //输出：1 // // // // // 提示： // // // m == obstacleGrid.length // n == obstacleGrid[i].length // 1 \u0026lt;= m, n \u0026lt;= 100 // obstacleGrid[i][j] 为 0 或 1 // // Related Topics 数组 动态规划 // 👍 490 👎 0 /* * 63 不同路径 II * 2021-02-21 21:23:51 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int uniquePathsWithObstacles(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; obstacleGrid) { int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m, vector\u0026lt;int\u0026gt;(n, 0)); for(int i = 0;i \u0026lt; m;i++){ for(int j = 0;j \u0026lt; n;j++){ if(obstacleGrid[i][j]) continue; if(i == 0 \u0026amp;\u0026amp; j == 0) dp[i][j] = 1; if(j \u0026gt; 0) dp[i][j] += dp[i][j-1]; if(i \u0026gt; 0) dp[i][j] += dp[i-1][j]; } } return dp.back().back(); } }; class Solution { public: int uniquePaths(int m, int n) { vector\u0026lt;int\u0026gt; dp(n, 1); // if (!i || !j) dp[i] = 1; for(int i = 1;i \u0026lt; m;i++){ for(int j = 1;j \u0026lt; n;j++){ dp[j] += dp[j-1]; } } return dp.back(); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/63%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-ii/","summary":"//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 // // 机器人每次只能向下或者向右移动一步。机器人试图达到网格的","title":"[62]不同路径 II"},{"content":"//给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 // // // // 示例 1: // // //输入: s = \u0026#34;abcabcbb\u0026#34; //输出: 3 //解释: 因为无重复字符的最长子串是 \u0026#34;abc\u0026#34;，所以其长度为 3。 // // // 示例 2: // // //输入: s = \u0026#34;bbbbb\u0026#34; //输出: 1 //解释: 因为无重复字符的最长子串是 \u0026#34;b\u0026#34;，所以其长度为 1。 // // // 示例 3: // // //输入: s = \u0026#34;pwwkew\u0026#34; //输出: 3 //解释: 因为无重复字符的最长子串是 \u0026#34;wke\u0026#34;，所以其长度为 3。 // 请注意，你的答案必须是 子串 的长度，\u0026#34;pwke\u0026#34; 是一个子序列，不是子串。 // // // 示例 4: // // //输入: s = \u0026#34;\u0026#34; //输出: 0 // // // // // 提示： // // // 0 \u0026lt;= s.length \u0026lt;= 5 * 104 // s 由英文字母、数字、符号和空格组成 // // Related Topics 哈希表 双指针 字符串 Sliding Window // 👍 4984 👎 0 /* * 3 无重复字符的最长子串 * 2021-02-21 20:29:29 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int lengthOfLongestSubstring(string s) { const int n = s.length(); int ans = 0; int left = 0; unordered_set\u0026lt;char\u0026gt; us; // windows [left, i] is the current result for(int i = 0;i \u0026lt; n;i++){ while(us.find(s[i]) != us.end()) { us.erase(s[left]); left++; } ans = max(ans, i - left + 1); us.insert(s[i]); } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/","summary":"//给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 // // // // 示例 1: // // //输入: s = \u0026#34;abcabcbb\u0026#34; //输出: 3 //解释: 因为无重复字符的最长","title":"[3]无重复字符的最长子串"},{"content":"//给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。 // // 注意：两个节点之间的路径长度由它们之间的边数表示。 // // 示例 1: // // 输入: // // // 5 // / \\ // 4 5 // / \\ \\ // 1 1 5 // // // 输出: // // //2 // // // 示例 2: // // 输入: // // // 1 // / \\ // 4 5 // / \\ \\ // 4 4 5 // // // 输出: // // //2 // // // 注意: 给定的二叉树不超过10000个结点。 树的高度不超过1000。 // Related Topics 树 递归 // 👍 424 👎 0 /* * 687 最长同值路径 * 2021-02-21 19:54:43 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: int ans = 0; int longestUnivaluePath(TreeNode* root) { if(!root) return 0; dfs(root); return ans; } int dfs(TreeNode* root){ // return root and its any node single path if(!root) return 0; int l = dfs(root-\u0026gt;left); int r = dfs(root-\u0026gt;right); int pl = 0; int pr = 0; if(root-\u0026gt;left \u0026amp;\u0026amp; root-\u0026gt;val == root-\u0026gt;left-\u0026gt;val) pl = l + 1; if(root-\u0026gt;right \u0026amp;\u0026amp; root-\u0026gt;val == root-\u0026gt;right-\u0026gt;val) pr = r + 1; ans = max(ans, pl + pr); return max(pl, pr); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/687%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/","summary":"//给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。 // // 注意：两个节点之间的路径长度由它","title":"[687]最长同值路径"},{"content":"//给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 // // // // 示例 : //给定二叉树 // // 1 // / \\ // 2 3 // / \\ // 4 5 // // // 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 // // // // 注意：两结点之间的路径长度是以它们之间边的数目表示。 // Related Topics 树 // 👍 614 👎 0 /* * 543 二叉树的直径 * 2021-02-21 19:45:41 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int ans = 0; int diameterOfBinaryTree(TreeNode* root) { dfs(root); return ans; } int dfs(TreeNode* root){ // return max length from root to his leaf if(!root) return -1; int l = dfs(root-\u0026gt;left) + 1; int r = dfs(root-\u0026gt;right) + 1; ans = max(ans, l + r); return max(l, r); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/543%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/","summary":"//给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 // // //","title":"[543]二叉树的直径"},{"content":"//给定一个二叉树，判断它是否是高度平衡的二叉树。 // // 本题中，一棵高度平衡二叉树定义为： // // // 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 // // // // // 示例 1： // // //输入：root = [3,9,20,null,null,15,7] //输出：true // // // 示例 2： // // //输入：root = [1,2,2,3,3,null,null,4,4] //输出：false // // // 示例 3： // // //输入：root = [] //输出：true // // // // // 提示： // // // 树中的节点数在范围 [0, 5000] 内 // -104 \u0026lt;= Node.val \u0026lt;= 104 // // Related Topics 树 深度优先搜索 递归 // 👍 595 👎 0 /* * 110 平衡二叉树 * 2021-02-21 19:34:59 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: // O(N*logN) O(n) + O(n / 2) + O(n / 4) + ... bool isBalanced(TreeNode* root) { if(!root) return true; int left_height = height(root-\u0026gt;left); int right_height = height(root-\u0026gt;right); return abs(left_height - right_height) \u0026lt;= 1 \u0026amp;\u0026amp; isBalanced(root-\u0026gt;left) \u0026amp;\u0026amp; isBalanced(root-\u0026gt;right); } int height(TreeNode* root){ if(!root) return 0; return max(height(root-\u0026gt;left), height(root-\u0026gt;right)) + 1; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"//给定一个二叉树，判断它是否是高度平衡的二叉树。 // // 本题中，一棵高度平衡二叉树定义为： // // // 一个二叉树每个节点 的左右两个子树的高度差的绝对","title":"[110]平衡二叉树"},{"content":"//给定一个二叉树，判断其是否是一个有效的二叉搜索树。 // // 假设一个二叉搜索树具有如下特征： // // // 节点的左子树只包含小于当前节点的数。 // 节点的右子树只包含大于当前节点的数。 // 所有左子树和右子树自身必须也是二叉搜索树。 // // // 示例 1: // // 输入: // 2 // / \\ // 1 3 //输出: true // // // 示例 2: // // 输入: // 5 // / \\ // 1 4 // / \\ // 3 6 //输出: false //解释: 输入为: [5,1,4,null,null,3,6]。 // 根节点的值为 5 ，但是其右子节点值为 4 。 // // Related Topics 树 深度优先搜索 递归 // 👍 923 👎 0 /* * 98 验证二叉搜索树 * 2021-02-20 11:51:32 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isValidBST(TreeNode* root) { return valid(root, nullptr, nullptr); } bool valid(TreeNode* root, int* min_val, int* max_val){ if(!root) return true; if((min_val \u0026amp;\u0026amp; root-\u0026gt;val \u0026lt;= *min_val) || max_val \u0026amp;\u0026amp; root-\u0026gt;val \u0026gt;= *max_val) return false; return valid(root-\u0026gt;left, min_val, \u0026amp;root-\u0026gt;val) \u0026amp;\u0026amp; valid(root-\u0026gt;right, \u0026amp;root-\u0026gt;val, max_val); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/","summary":"//给定一个二叉树，判断其是否是一个有效的二叉搜索树。 // // 假设一个二叉搜索树具有如下特征： // // // 节点的左子树只包含小于当前节点的数。 // 节点的","title":"[98]验证二叉搜索树"},{"content":"//给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 // // 请你将两个数相加，并以相同形式返回一个表示和的链表。 // // 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 // // // // 示例 1： // // //输入：l1 = [2,4,3], l2 = [5,6,4] //输出：[7,0,8] //解释：342 + 465 = 807. // // // 示例 2： // // //输入：l1 = [0], l2 = [0] //输出：[0] // // // 示例 3： // // //输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] //输出：[8,9,9,9,0,0,0,1] // // // // // 提示： // // // 每个链表中的节点数在范围 [1, 100] 内 // 0 \u0026lt;= Node.val \u0026lt;= 9 // 题目数据保证列表表示的数字不含前导零 // // Related Topics 递归 链表 数学 // 👍 5652 👎 0 /* * 2 两数相加 * 2021-02-20 11:22:10 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { if(!l2 || !l1) return l1 ? l1 : l2; ListNode dummy(-1); auto cur = \u0026amp;dummy; int carry; while(l1 || l2 || carry){ int sum = (l1 ? l1-\u0026gt;val : 0) + (l2 ? l2-\u0026gt;val : 0) + carry; cur-\u0026gt;next = new ListNode(sum % 10); carry = sum / 10; l1 = l1 ? l1-\u0026gt;next : nullptr; l2 = l2 ? l2-\u0026gt;next : nullptr; cur = cur-\u0026gt;next; } if(carry) cur-\u0026gt;next = new ListNode(carry); return dummy.next; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/","summary":"//给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 // // 请你将两个数相加，并以相","title":"[2]两数相加"},{"content":"//给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 // // 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 // // 你可以按任意顺序返回答案。 // // // // 示例 1： // // //输入：nums = [2,7,11,15], target = 9 //输出：[0,1] //解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 // // // 示例 2： // // //输入：nums = [3,2,4], target = 6 //输出：[1,2] // // // 示例 3： // // //输入：nums = [3,3], target = 6 //输出：[0,1] // // // // // 提示： // // // 2 \u0026lt;= nums.length \u0026lt;= 103 // -109 \u0026lt;= nums[i] \u0026lt;= 109 // -109 \u0026lt;= target \u0026lt;= 109 // 只会存在一个有效答案 // // Related Topics 数组 哈希表 // 👍 10310 👎 0 /* * 1 两数之和 * 2021-02-20 11:22:07 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { unordered_map\u0026lt;int, int\u0026gt; indies; for(int i = 0;i \u0026lt; nums.size();i++){ indies[nums[i]] = i; } for(int i = 0;i \u0026lt; nums.size();i++){ int left = target - nums[i]; if(indies.count(left) \u0026amp;\u0026amp; indies[left] != i) return {i, indies[left]}; } return {}; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/hashmap/1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","summary":"//给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 // // 你可以假设每种输入只","title":"[1]两数之和"},{"content":"//将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 // // // // 示例 1： // // //输入：l1 = [1,2,4], l2 = [1,3,4] //输出：[1,1,2,3,4,4] // // // 示例 2： // // //输入：l1 = [], l2 = [] //输出：[] // // // 示例 3： // // //输入：l1 = [], l2 = [0] //输出：[0] // // // // // 提示： // // // 两个链表的节点数目范围是 [0, 50] // -100 \u0026lt;= Node.val \u0026lt;= 100 // l1 和 l2 均按 非递减顺序 排列 // // Related Topics 递归 链表 // 👍 1539 👎 0 /* * 21 合并两个有序链表 * 2021-02-20 11:15:25 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution2 { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(!l1 || !l2) return l1 ? l1 : l2; ListNode dummy(-1); auto cur = \u0026amp;dummy; while(l1 \u0026amp;\u0026amp; l2){ if(l1-\u0026gt;val \u0026lt; l2-\u0026gt;val){ cur-\u0026gt;next = l1; l1 = l1-\u0026gt;next; }else{ cur-\u0026gt;next = l2; l2 = l2-\u0026gt;next; } cur = cur-\u0026gt;next; } if(l1) cur-\u0026gt;next = l1; if(l2) cur-\u0026gt;next = l2; return dummy.next; } }; class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(!l1 || !l2) return l1 ? l1 : l2; if(l1-\u0026gt;val \u0026lt; l2-\u0026gt;val){ l1-\u0026gt;next =mergeTwoLists(l1-\u0026gt;next, l2); return l1; }else{ l2-\u0026gt;next = mergeTwoLists(l1, l2-\u0026gt;next); return l2; } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/","summary":"//将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 // // // // 示例 1： // // //输入：l1 = [1,2,4], l2 = [1,3,4]","title":"[21]合并两个有序链表"},{"content":"//假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 // // 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ // // 注意：给定 n 是一个正整数。 // // 示例 1： // // 输入： 2 //输出： 2 //解释： 有两种方法可以爬到楼顶。 //1. 1 阶 + 1 阶 //2. 2 阶 // // 示例 2： // // 输入： 3 //输出： 3 //解释： 有三种方法可以爬到楼顶。 //1. 1 阶 + 1 阶 + 1 阶 //2. 1 阶 + 2 阶 //3. 2 阶 + 1 阶 // // Related Topics 动态规划 // 👍 1476 👎 0 /* * 70 爬楼梯 * 2021-02-20 11:09:41 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int climbStairs(int n) { if(n == 1) return 1; if(n == 2) return 2; int a = 1; int b = 2; for(int i = 3;i \u0026lt;= n;i++){ int temp = b; b = a + b; a = temp; } return b; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/70%E7%88%AC%E6%A5%BC%E6%A2%AF/","summary":"//假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 // // 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ // // 注意：给定 n 是一个正整数","title":"[70]爬楼梯"},{"content":"//给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 // // 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 // // // // 示例 1： // // //输入：p = [1,2,3], q = [1,2,3] //输出：true // // // 示例 2： // // //输入：p = [1,2], q = [1,null,2] //输出：false // // // 示例 3： // // //输入：p = [1,2,1], q = [1,1,2] //输出：false // // // // // 提示： // // // 两棵树上的节点数目都在范围 [0, 100] 内 // -104 \u0026lt;= Node.val \u0026lt;= 104 // // Related Topics 树 深度优先搜索 // 👍 565 👎 0 /* * 100 相同的树 * 2021-02-20 11:05:40 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if(!p \u0026amp;\u0026amp; !q) return true; if(!p || !q) return false; if(p-\u0026gt;val != q-\u0026gt;val) return false; return isSameTree(p-\u0026gt;left, q-\u0026gt;left) \u0026amp;\u0026amp; isSameTree(p-\u0026gt;right, q-\u0026gt;right); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/tree/100%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/","summary":"//给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 // // 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。","title":"[100]相同的树"},{"content":"//给定一个链表，判断链表中是否有环。 // // 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的 //位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 // // 如果链表中存在环，则返回 true 。 否则，返回 false 。 // // // // 进阶： // // 你能用 O(1)（即，常量）内存解决此问题吗？ // // // // 示例 1： // // // // 输入：head = [3,2,0,-4], pos = 1 //输出：true //解释：链表中有一个环，其尾部连接到第二个节点。 // // // 示例 2： // // // // 输入：head = [1,2], pos = 0 //输出：true //解释：链表中有一个环，其尾部连接到第一个节点。 // // // 示例 3： // // // // 输入：head = [1], pos = -1 //输出：false //解释：链表中没有环。 // // // // // 提示： // // // 链表中节点的数目范围是 [0, 104] // -105 \u0026lt;= Node.val \u0026lt;= 105 // pos 为 -1 或者链表中的一个 有效索引 。 // // Related Topics 链表 双指针 // 👍 934 👎 0 /* * 141 环形链表 * 2021-02-20 10:52:12 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution2 { public: bool hasCycle(ListNode *head) { unordered_set\u0026lt;ListNode*\u0026gt; us; while(head){ if(us.count(head)) return true; us.insert(head); head = head-\u0026gt;next; } return false; } }; class Solution { public: bool hasCycle(ListNode *head) { auto fast = head; auto slow = head; while(fast){ if(!fast-\u0026gt;next) return false; fast = fast-\u0026gt;next-\u0026gt;next; slow = slow-\u0026gt;next; if(fast == slow) return true; } return false; } }; class Solution3 { public: bool hasCycle(ListNode *head) { if(!head) return false; auto fast = head, slow = head; while(fast){ if(fast-\u0026gt;next) fast = fast-\u0026gt;next-\u0026gt;next, slow = slow-\u0026gt;next; else return false; if(fast == slow) return true; } return false; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/list/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/","summary":"//给定一个链表，判断链表中是否有环。 // // 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们","title":"[141]环形链表"},{"content":"//给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 // // // // 示例 1： // // //输入：nums = [-2,1,-3,4,-1,2,1,-5,4] //输出：6 //解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 // // // 示例 2： // // //输入：nums = [1] //输出：1 // // // 示例 3： // // //输入：nums = [0] //输出：0 // // // 示例 4： // // //输入：nums = [-1] //输出：-1 // // // 示例 5： // // //输入：nums = [-100000] //输出：-100000 // // // // // 提示： // // // 1 \u0026lt;= nums.length \u0026lt;= 3 * 104 // -105 \u0026lt;= nums[i] \u0026lt;= 105 // // // // // 进阶：如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 // Related Topics 数组 分治算法 动态规划 // 👍 2896 👎 0 /* * 53 最大子序和 * 2021-02-20 08:29:45 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { vector\u0026lt;int\u0026gt; dp(nums.size(), 0); // dp[i] is the result of nums[0, i] and must contain nums[i] dp[0] = nums[0]; int res = dp[0]; for(int i = 1;i \u0026lt; dp.size();i++){ dp[i] = max(dp[i- 1] + nums[i], nums[i]); res = max(res, dp[i]); } return res; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/","summary":"//给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 // // // // 示例 1： // // //输入：nums = [-2,1,-3,4,-1,2,1,-5,4] /","title":"[53]最大子序和"},{"content":"//编写一个函数来查找字符串数组中的最长公共前缀。 // // 如果不存在公共前缀，返回空字符串 \u0026#34;\u0026#34;。 // // // // 示例 1： // // //输入：strs = [\u0026#34;flower\u0026#34;,\u0026#34;flow\u0026#34;,\u0026#34;flight\u0026#34;] //输出：\u0026#34;fl\u0026#34; // // // 示例 2： // // //输入：strs = [\u0026#34;dog\u0026#34;,\u0026#34;racecar\u0026#34;,\u0026#34;car\u0026#34;] //输出：\u0026#34;\u0026#34; //解释：输入不存在公共前缀。 // // // // 提示： // // // 0 \u0026lt;= strs.length \u0026lt;= 200 // 0 \u0026lt;= strs[i].length \u0026lt;= 200 // strs[i] 仅由小写英文字母组成 // // Related Topics 字符串 // 👍 1462 👎 0 /* * 14 最长公共前缀 * 2021-02-19 23:04:38 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { if(strs.empty()) return \u0026#34;\u0026#34;; string prefix = strs[0]; for(int i = 1;i \u0026lt; strs.size();i++){ int k = 0; while(k \u0026lt; min(strs[i].length(), prefix.length())){ if(strs[i][k] != prefix[k]){ break; } k++; } prefix = prefix.substr(0, k); } return prefix; } }; class Solution { public: string longestCommonPrefix(vector\u0026lt;string\u0026gt;\u0026amp; strs) { int n = strs.size(); if(n == 0) return \u0026#34;\u0026#34;; size_t m = strs[0].length(); for(int i = 1;i \u0026lt; n;i++){ m = min(m, strs[i].length()); } for(int s = 1;s \u0026lt;= m;s++){ char c = strs[0][s-1]; for(int i = 1;i \u0026lt; n;i++){ // start from s == 1 if(strs[i][s-1] != c) // if not match , then get the result return strs[0].substr(0, s-1); } } return strs[0].substr(0, m); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/14%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/","summary":"//编写一个函数来查找字符串数组中的最长公共前缀。 // // 如果不存在公共前缀，返回空字符串 \u0026#34;\u0026#34;。 // // // // 示例 1： // // //输入：s","title":"[14]最长公共前缀"},{"content":"//给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。 // // 你可以进行如下操作至多 maxOperations 次： // // // 选择任意一个袋子，并将袋子里的球分到 2 个新的袋子中，每个袋子里都有 正整数 个球。 // // // 比方说，一个袋子里有 5 个球，你可以把它们分到两个新袋子里，分别有 1 个和 4 个球，或者分别有 2 个和 3 个球。 // // // // // 你的开销是单个袋子里球数目的 最大值 ，你想要 最小化 开销。 // // 请你返回进行上述操作后的最小开销。 // // // // 示例 1： // // //输入：nums = [9], maxOperations = 2 //输出：3 //解释： //- 将装有 9 个球的袋子分成装有 6 个和 3 个球的袋子。[9] -\u0026gt; [6,3] 。 //- 将装有 6 个球的袋子分成装有 3 个和 3 个球的袋子。[6,3] -\u0026gt; [3,3,3] 。 //装有最多球的袋子里装有 3 个球，所以开销为 3 并返回 3 。 // // // 示例 2： // // //输入：nums = [2,4,8,2], maxOperations = 4 //输出：2 //解释： //- 将装有 8 个球的袋子分成装有 4 个和 4 个球的袋子。[2,4,8,2] -\u0026gt; [2,4,4,4,2] 。 //- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,4,4,4,2] -\u0026gt; [2,2,2,4,4,2] 。 //- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,4,4,2] -\u0026gt; [2,2,2,2,2,4,2] 。 //- 将装有 4 个球的袋子分成装有 2 个和 2 个球的袋子。[2,2,2,2,2,4,2] -\u0026gt; [2,2,2,2,2,2,2,2] 。 //装有最多球的袋子里装有 2 个球，所以开销为 2 并返回 2 。 // // // 示例 3： // // //输入：nums = [7,17], maxOperations = 2 //输出：7 // // // // // 提示： // // // 1 \u0026lt;= nums.length \u0026lt;= 10^5 // 1 \u0026lt;= maxOperations, nums[i] \u0026lt;= 10^9 // // Related Topics 堆 二分查找 // 👍 16 👎 0 /* * 1760 袋子里最少数目的球 * 2021-02-19 22:06:02 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int minimumSize(vector\u0026lt;int\u0026gt;\u0026amp; nums, int maxOperations) { // 将极小极大化问题转化为二分查找 // 到了10^9，要么是O(log(m)) 要么是 O(1) // 将计算问题转化为判定问题，判定本身的难度要小于计算 int left = 0, right = *max_element(nums.begin(), nums.end()); while(left \u0026lt; right){ int mid = left + right \u0026gt;\u0026gt; 1; int ops = 0; for(auto x : nums){ ops += (x - 1) / mid; } // mid是数目， ops是操作 if(ops \u0026lt;= maxOperations) right = mid; // ops满足条件，继续探索mid下界 else left = mid + 1; // ops不满足 } return left; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/leetcode/binarysearch/1760%E8%A2%8B%E5%AD%90%E9%87%8C%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E7%90%83/","summary":"//给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。 // // 你可以进行如下操作至多 maxOperations 次： // // // 选择任意一个袋子，并将袋子","title":"[1760]袋子里最少数目的球"},{"content":"//给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 // // 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（ //一个节点也可以是它自己的祖先）。” // // 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] // // // // // // 示例 1: // // 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 //输出: 3 //解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 // // // 示例 2: // // 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 //输出: 5 //解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 // // // // // 说明: // // // 所有节点的值都是唯一的。 // p、q 为不同节点且均存在于给定的二叉树中。 // // // 注意：本题与主站 236 题相同：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a //-binary-tree/ // Related Topics 树 // 👍 191 👎 0 /* * 剑指 Offer 68 - II 二叉树的最近公共祖先 * 2021-02-18 11:49:40 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(!root) return nullptr; if(root == p || root == q) return root; TreeNode* l = lowestCommonAncestor(root-\u0026gt;left, p, q); TreeNode* r = lowestCommonAncestor(root-\u0026gt;right, p, q); if(l \u0026amp;\u0026amp; r) return root; return l ? l : r; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-68-ii%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","summary":"//给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 // // 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表","title":"[剑指 Offer 68 - II]二叉树的最近公共祖先"},{"content":"//给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 // // 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（ //一个节点也可以是它自己的祖先）。” // // 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] // // // // // // 示例 1: // // 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 //输出: 6 //解释: 节点 2 和节点 8 的最近公共祖先是 6。 // // // 示例 2: // // 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 //输出: 2 //解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 // // // // 说明: // // // 所有节点的值都是唯一的。 // p、q 为不同节点且均存在于给定的二叉搜索树中。 // // // 注意：本题与主站 235 题相同：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a //-binary-search-tree/ // Related Topics 树 // 👍 93 👎 0 /* * 剑指 Offer 68 - I 二叉搜索树的最近公共祖先 * 2021-02-18 11:49:18 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(!root) return nullptr; if(root == p || root == q) return root; TreeNode* l = lowestCommonAncestor(root-\u0026gt;left, p, q); TreeNode* r = lowestCommonAncestor(root-\u0026gt;right, p, q); if(l \u0026amp;\u0026amp; r) return root; return l ? l : r; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-68-i%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/","summary":"//给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 // // 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖","title":"[剑指 Offer 68 - I]二叉搜索树的最近公共祖先"},{"content":"//写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。 // // // // 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 // // 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连 //续的数字字符组合起来，形成整数。 // // 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 // // 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 // // 在任何情况下，若函数不能进行有效的转换时，请返回 0。 // // 说明： // // 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 // − 1) 或 INT_MIN (−231) 。 // // 示例 1: // // 输入: \u0026#34;42\u0026#34; //输出: 42 // // // 示例 2: // // 输入: \u0026#34; -42\u0026#34; //输出: -42 //解释: 第一个非空白字符为 \u0026#39;-\u0026#39;, 它是一个负号。 // 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 // // // 示例 3: // // 输入: \u0026#34;4193 with words\u0026#34; //输出: 4193 //解释: 转换截止于数字 \u0026#39;3\u0026#39; ，因为它的下一个字符不为数字。 // // // 示例 4: // // 输入: \u0026#34;words and 987\u0026#34; //输出: 0 //解释: 第一个非空字符是 \u0026#39;w\u0026#39;, 但它不是数字或正、负号。 // 因此无法执行有效的转换。 // // 示例 5: // // 输入: \u0026#34;-91283472332\u0026#34; //输出: -2147483648 //解释: 数字 \u0026#34;-91283472332\u0026#34; 超过 32 位有符号整数范围。 // 因此返回 INT_MIN (−231) 。 // // // // // 注意：本题与主站 8 题相同：https://leetcode-cn.com/problems/string-to-integer-atoi/ // Related Topics 数学 字符串 // 👍 56 👎 0 /* * 剑指 Offer 67 把字符串转换成整数 * 2021-02-18 11:49:02 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: // 测试用例很变态，慢慢调试 int strToInt(string str) { if(str.empty()) return 0; int k = 0; bool is_minus = false; // 正负 while(k \u0026lt; str.size() \u0026amp;\u0026amp; str[k] == \u0026#39; \u0026#39;) k++; // 空格 if(str[k] == \u0026#39;+\u0026#39;) k++; else if(str[k] == \u0026#39;-\u0026#39;) is_minus = true, k++; long long int number = 0; for(int i = k;i \u0026lt; str.size() \u0026amp;\u0026amp; 0 \u0026lt;= str[i] - \u0026#39;0\u0026#39; \u0026amp;\u0026amp; str[i] - \u0026#39;0\u0026#39; \u0026lt;= 9;i++){ number = number * 10 + str[i] - \u0026#39;0\u0026#39;; // 提前判断，防止溢出 if(number \u0026gt;= INT_MAX \u0026amp;\u0026amp; !is_minus) return INT_MAX; long long int ans = number * -1; if(is_minus \u0026amp;\u0026amp; ans \u0026lt;= INT_MIN) return INT_MIN; } if(is_minus) number *= -1; return number; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-67%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/","summary":"//写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。 // // // // 首先，该函数会根据需要丢弃无用的开头","title":"[剑指 Offer 67]把字符串转换成整数"},{"content":"//给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[ //i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。 // // // // 示例: // // //输入: [1,2,3,4,5] //输出: [120,60,40,30,24] // // // // 提示： // // // 所有元素乘积之和不会溢出 32 位整数 // a.length \u0026lt;= 100000 // // 👍 79 👎 0 /* * 剑指 Offer 66 构建乘积数组 * 2021-02-18 11:48:44 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;int\u0026gt; constructArr(vector\u0026lt;int\u0026gt;\u0026amp; a) { if(a.size() == 0) return {}; vector\u0026lt;int\u0026gt; ans(a.size(), 0); ans[0] = 1; for(int i = 1, mult = a[0];i \u0026lt; a.size();i++){ ans[i] = mult; mult *= a[i]; } for(int i = a.size() - 2, mult = a[a.size()-1];i \u0026gt;= 0;i--){ ans[i] *= mult; mult *= a[i]; } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-66%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/","summary":"//给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[ //i]","title":"[剑指 Offer 66]构建乘积数组"},{"content":"//求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 // // // // 示例 1： // // 输入: n = 3 //输出: 6 // // // 示例 2： // // 输入: n = 9 //输出: 45 // // // // // 限制： // // // 1 \u0026lt;= n \u0026lt;= 10000 // // 👍 267 👎 0 /* * 剑指 Offer 64 求1+2+…+n * 2021-02-18 11:48:19 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int sumNums(int n) { if(n == 1) return 1; else return sumNums((n-1)) + n; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-64%E6%B1%821+2++n/","summary":"//求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 // // // // 示例 1","title":"[剑指 Offer 64]求1+2+…+n"},{"content":"//写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 // // // // 示例: // // 输入: a = 1, b = 1 //输出: 2 // // // // 提示： // // // a, b 均可能是负数或 0 // 结果不会溢出 32 位整数 // // 👍 117 👎 0 /* * 剑指 Offer 65 不用加减乘除做加法 * 2021-02-18 11:48:18 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int add(int a, int b) { int result = 0; int carry = 0; // + is not allowed to use // a + b == result + carry , so if b == 0, a is the ans; while(b){ result = a ^ b; // [ref]:https://www.cnblogs.com/grandyang/p/5631814.html carry = (a \u0026amp; b \u0026amp; 0x7fffffff) \u0026lt;\u0026lt; 1; // LeetCode 自己的编译器比较 strict，不能对负数进行左移，就是说最高位符号位必须要为0，才能左移 a = result; b = carry; } return a; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-65%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/","summary":"//写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 // // // // 示例: // // 输入: a = 1, b = 1 //输","title":"[剑指 Offer 65]不用加减乘除做加法"},{"content":"//假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ // // // // 示例 1: // // 输入: [7,1,5,3,6,4] //输出: 5 //解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 // 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。 // // // 示例 2: // // 输入: [7,6,4,3,1] //输出: 0 //解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 // // // // 限制： // // 0 \u0026lt;= 数组长度 \u0026lt;= 10^5 // // // // 注意：本题与主站 121 题相同：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-s //tock/ // Related Topics 动态规划 // 👍 91 👎 0 /* * 剑指 Offer 63 股票的最大利润 * 2021-02-18 11:48:08 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int maxProfit(vector\u0026lt;int\u0026gt;\u0026amp; prices) { int n = prices.size(); if(n == 0) return 0; int res = 0; // use minv to keep the min value for(int i = 0, minv = prices[0];i \u0026lt; n;i++){ res = max(res, prices[i] - minv); if(minv \u0026gt; prices[i]) minv = prices[i]; } return res; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-63%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/","summary":"//假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖该股票一次可能获得的最大利润是多少？ // // // // 示例 1: // // 输入: [7,1,5,3,6,4] //输出: 5 //解","title":"[剑指 Offer 63]股票的最大利润"},{"content":"//0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里剩下的最后一个数字。 // // // 例如，0、1、2、3、4这5个数字组成一个圆圈，从数字0开始每次删除第3个数字，则删除的前4个数字依次是2、0、4、1，因此最后剩下的数字是3。 // // // // 示例 1： // // //输入: n = 5, m = 3 //输出: 3 // // // 示例 2： // // //输入: n = 10, m = 17 //输出: 2 // // // // // 限制： // // // 1 \u0026lt;= n \u0026lt;= 10^5 // 1 \u0026lt;= m \u0026lt;= 10^6 // // 👍 294 👎 0 /* * 剑指 Offer 62 圆圈中最后剩下的数字 * 2021-02-18 11:47:52 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int lastRemaining(int n, int m) { if(!n) return 0; return (lastRemaining(n-1, m) + m) % n; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-62%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/","summary":"//0,1,···,n-1这n个数字排成一个圆圈，从数字0开始，每次从这个圆圈里删除第m个数字（删除后从下一个数字开始计数）。求出这个圆圈里","title":"[剑指 Offer 62]圆圈中最后剩下的数字"},{"content":"//从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任 //意数字。A 不能视为 14。 // // // // 示例 1: // // 输入: [1,2,3,4,5] //输出: True // // // // 示例 2: // // 输入: [0,0,1,2,5] //输出: True // // // // 限制： // // 数组长度为 5 // // 数组的数取值为 [0, 13] . // 👍 95 👎 0 /* * 剑指 Offer 61 扑克牌中的顺子 * 2021-02-18 11:47:36 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: bool isStraight(vector\u0026lt;int\u0026gt;\u0026amp; nums) { if(nums.size() != 5) return false; sort(nums.begin(), nums.end()); int k = 0; while(!nums[k]) k++; for(int i = k + 1; i \u0026lt; 5;i++){ if(nums[i] == nums[i-1]) return false; } return nums[4] - nums[k] \u0026lt;= 4; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-61%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/","summary":"//从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王","title":"[剑指 Offer 61]扑克牌中的顺子"},{"content":"//把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 // // // // 你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。 // // // // 示例 1: // // 输入: 1 //输出: [0.16667,0.16667,0.16667,0.16667,0.16667,0.16667] // // // 示例 2: // // 输入: 2 //输出: [0.02778,0.05556,0.08333,0.11111,0.13889,0.16667,0.13889,0.11111,0.08333,0 //.05556,0.02778] // // // // 限制： // // 1 \u0026lt;= n \u0026lt;= 11 // 👍 167 👎 0 /* * 剑指 Offer 60 n个骰子的点数 * 2021-02-18 11:47:26 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;double\u0026gt; dicesProbability(int n) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(n + 1, vector\u0026lt;int\u0026gt;(6 * n + 1, 0)); dp[0][0] = 1; for(int i = 1;i \u0026lt;= n;i++){ for(int j = 1;j \u0026lt;= 6 * n;j++){ for(int k = 1; k \u0026lt;= min(6, j);k++){ dp[i][j] += dp[i-1][j-k]; } } } vector\u0026lt;double\u0026gt; ans; int sum = 0; for(int i = n;i \u0026lt;= 6 * n;i++) sum += dp[n][i]; for(int i = n;i \u0026lt;= 6 * n;i++) ans.push_back((double)dp[n][i] / sum); return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-60n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/","summary":"//把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。 // // // // 你需要用一个浮点数数组返回答案，其","title":"[剑指 Offer 60]n个骰子的点数"},{"content":"//请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都 //是O(1)。 // // 若队列为空，pop_front 和 max_value 需要返回 -1 // // 示例 1： // // 输入: //[\u0026#34;MaxQueue\u0026#34;,\u0026#34;push_back\u0026#34;,\u0026#34;push_back\u0026#34;,\u0026#34;max_value\u0026#34;,\u0026#34;pop_front\u0026#34;,\u0026#34;max_value\u0026#34;] //[[],[1],[2],[],[],[]] //输出: [null,null,null,2,1,2] // // // 示例 2： // // 输入: //[\u0026#34;MaxQueue\u0026#34;,\u0026#34;pop_front\u0026#34;,\u0026#34;max_value\u0026#34;] //[[],[],[]] //输出: [null,-1,-1] // // // // // 限制： // // // 1 \u0026lt;= push_back,pop_front,max_value的总操作数 \u0026lt;= 10000 // 1 \u0026lt;= value \u0026lt;= 10^5 // // Related Topics 栈 Sliding Window // 👍 195 👎 0 /* * 剑指 Offer 59 - II 队列的最大值 * 2021-02-18 11:47:07 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class MaxQueue { public: queue\u0026lt;int\u0026gt; q; deque\u0026lt;int\u0026gt; dq; MaxQueue() { } int max_value() { if(dq.empty()) return -1; else return dq.front(); } void push_back(int value) { q.push(value); while(!dq.empty() \u0026amp;\u0026amp; dq.back() \u0026lt; value){ dq.pop_back(); } dq.push_back(value); } int pop_front() { int t = -1; if(!q.empty()) t = q.front(), q.pop(); if(!dq.empty() \u0026amp;\u0026amp; dq.front() == t) dq.pop_front(); return t; } }; /** * Your MaxQueue object will be instantiated and called as such: * MaxQueue* obj = new MaxQueue(); * int param_1 = obj-\u0026gt;max_value(); * obj-\u0026gt;push_back(value); * int param_3 = obj-\u0026gt;pop_front(); */ //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-59-ii%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","summary":"//请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都 //是O(1)。 // // 若","title":"[剑指 Offer 59 - II]队列的最大值"},{"content":"//给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 // // 示例: // // 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 //输出: [3,3,5,5,6,7] //解释: // // 滑动窗口的位置 最大值 //--------------- ----- //[1 3 -1] -3 5 3 6 7 3 // 1 [3 -1 -3] 5 3 6 7 3 // 1 3 [-1 -3 5] 3 6 7 5 // 1 3 -1 [-3 5 3] 6 7 5 // 1 3 -1 -3 [5 3 6] 7 6 // 1 3 -1 -3 5 [3 6 7] 7 // // // // 提示： // // 你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。 // // 注意：本题与主站 239 题相同：https://leetcode-cn.com/problems/sliding-window-maximum/ // Related Topics 队列 Sliding Window // 👍 186 👎 0 /* * 剑指 Offer 59 - I 滑动窗口的最大值 * 2021-02-18 11:46:56 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;int\u0026gt; maxSlidingWindow(vector\u0026lt;int\u0026gt;\u0026amp; nums, int k) { vector\u0026lt;int\u0026gt; res; deque\u0026lt;int\u0026gt; q; // which keep index for(int i = 0;i \u0026lt; nums.size();i++){ while(q.size() \u0026amp;\u0026amp; q.front() \u0026lt;= i - k) q.pop_front();// when out of windows while(q.size() \u0026amp;\u0026amp; nums[q.back()] \u0026lt;= nums[i]) q.pop_back(); // when new element is big q.push_back(i); // push current index if(i \u0026gt;= k - 1) res.push_back(nums[q.front()]); } return res; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-59-i%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","summary":"//给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 // // 示例: // // 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 //输出: [3,3,5,5,6,7] //解释: // // 滑动窗口的位","title":"[剑指 Offer 59 - I]滑动窗口的最大值"},{"content":"//字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\u0026#34;abcdefg\u0026#34;和数字2，该函数 //将返回左旋转两位得到的结果\u0026#34;cdefgab\u0026#34;。 // // // // 示例 1： // // 输入: s = \u0026#34;abcdefg\u0026#34;, k = 2 //输出: \u0026#34;cdefgab\u0026#34; // // // 示例 2： // // 输入: s = \u0026#34;lrloseumgh\u0026#34;, k = 6 //输出: \u0026#34;umghlrlose\u0026#34; // // // // // 限制： // // // 1 \u0026lt;= k \u0026lt; s.length \u0026lt;= 10000 // // Related Topics 字符串 // 👍 81 👎 0 /* * 剑指 Offer 58 - II 左旋转字符串 * 2021-02-18 11:46:46 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: string reverseLeftWords(string s, int n) { int len = s.size(); string temp = s + s; return temp.substr(n, len); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-58-ii%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/","summary":"//字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串\u0026#34;ab","title":"[剑指 Offer 58 - II]左旋转字符串"},{"content":"//输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串\u0026#34;I am a student. \u0026#34;， //则输出\u0026#34;student. a am I\u0026#34;。 // // // // 示例 1： // // 输入: \u0026#34;the sky is blue\u0026#34; //输出: \u0026#34;blue is sky the\u0026#34; // // // 示例 2： // // 输入: \u0026#34; hello world! \u0026#34; //输出: \u0026#34;world! hello\u0026#34; //解释: 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 // // // 示例 3： // // 输入: \u0026#34;a good example\u0026#34; //输出: \u0026#34;example good a\u0026#34; //解释: 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 // // // // // 说明： // // // 无空格字符构成一个单词。 // 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 // 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 // // // 注意：本题与主站 151 题相同：https://leetcode-cn.com/problems/reverse-words-in-a-string/ // // // 注意：此题对比原题有改动 // Related Topics 字符串 // 👍 66 👎 0 /* * 剑指 Offer 58 - I 翻转单词顺序 * 2021-02-18 11:46:27 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: string reverseWords(string s) { if(s.size() \u0026lt;= 0) return s; int pos; vector\u0026lt;string\u0026gt; ans; for(int i = 0, j = 0;i \u0026lt; s.size() \u0026amp;\u0026amp; j \u0026lt;= s.size(); j++){ if(s[i] == \u0026#39; \u0026#39;) i++; else if(s[j] == \u0026#39; \u0026#39; || j == s.size()){ ans.push_back(s.substr(i, j - i)); i = j+1; } } reverse(ans.begin(), ans.end()); string res; for(int i = 0;i \u0026lt; ans.size();i++){ if(i == 0) res += ans[i]; else res += \u0026#39; \u0026#39;, res += ans[i]; } return res; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-58-i%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/","summary":"//输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串\u0026#34;I am a student.","title":"[剑指 Offer 58 - I]翻转单词顺序"},{"content":"//输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 // // 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 // // // // 示例 1： // // 输入：target = 9 //输出：[[2,3,4],[4,5]] // // // 示例 2： // // 输入：target = 15 //输出：[[1,2,3,4,5],[4,5,6],[7,8]] // // // // // 限制： // // // 1 \u0026lt;= target \u0026lt;= 10^5 // // // // 👍 213 👎 0 /* * 剑指 Offer 57 - II 和为s的连续正数序列 * 2021-02-18 11:46:13 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; findContinuousSequence(int target) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;int\u0026gt; temp; for(int i = 1, j = 2;i \u0026lt; j \u0026amp;\u0026amp; j \u0026lt; target;) { int ans = (i + j) * (j - i + 1) / 2; if (ans == target) { temp.clear(); for (int k = i; k \u0026lt;= j; k++) temp.push_back(k); res.push_back(temp); i++;j++; } else if (ans \u0026lt; target) { j++; } else i++; } return res; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-57-ii%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/","summary":"//输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。 // // 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。 // //","title":"[剑指 Offer 57 - II]和为s的连续正数序列"},{"content":"//输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。 // // // // 示例 1： // // 输入：nums = [2,7,11,15], target = 9 //输出：[2,7] 或者 [7,2] // // // 示例 2： // // 输入：nums = [10,26,30,31,47,60], target = 40 //输出：[10,30] 或者 [30,10] // // // // // 限制： // // // 1 \u0026lt;= nums.length \u0026lt;= 10^5 // 1 \u0026lt;= nums[i] \u0026lt;= 10^6 // // 👍 72 👎 0 /* * 剑指 Offer 57 和为s的两个数字 * 2021-02-18 11:45:35 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;int\u0026gt; twoSum(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { for(int i = 0;i \u0026lt; nums.size();i++){ if(nums[i] \u0026gt; target) continue; if(binarySearch(nums, target - nums[i])) return {nums[i], target - nums[i]}; } return {}; } bool binarySearch(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target){ int left = 0, right = nums.size() - 1; while(left \u0026lt; right){ int mid = left + right \u0026gt;\u0026gt; 1; if(nums[mid] == target) return true; else if(nums[mid] \u0026lt; target) left = mid + 1; else right = mid; } return false; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-57%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/","summary":"//输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。 // // // // 示例","title":"[剑指 Offer 57]和为s的两个数字"},{"content":"//在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 // // // // 示例 1： // // 输入：nums = [3,4,3,3] //输出：4 // // // 示例 2： // // 输入：nums = [9,1,7,9,7,9,7] //输出：1 // // // // 限制： // // // 1 \u0026lt;= nums.length \u0026lt;= 10000 // 1 \u0026lt;= nums[i] \u0026lt; 2^31 // // // // 👍 125 👎 0 /* * 剑指 Offer 56 - II 数组中数字出现的次数 II * 2021-02-18 11:45:24 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: // 看每一位1的数量 int singleNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int ans = 0; for(int i = 31;i \u0026gt;= 0;i--){ int cnt = 0; for(auto x : nums){ if(x \u0026gt;\u0026gt; i \u0026amp; 1) cnt++; } if(cnt % 3 == 1){ ans = ans * 2 + 1; }else{ ans = ans * 2; } } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-56-ii%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0-ii/","summary":"//在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。 // // // // 示例 1： // // 输入：nums = [3,4,3,3] //输出","title":"[剑指 Offer 56 - II]数组中数字出现的次数 II"},{"content":"//一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。 // // // // 示例 1： // // 输入：nums = [4,1,4,6] //输出：[1,6] 或 [6,1] // // // 示例 2： // // 输入：nums = [1,2,10,4,1,4,3,3] //输出：[2,10] 或 [10,2] // // // // 限制： // // // 2 \u0026lt;= nums.length \u0026lt;= 10000 // // // // 👍 301 👎 0 /* * 剑指 Offer 56 - I 数组中数字出现的次数 * 2021-02-18 11:45:07 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /* 异或得到 x^y 取 x与y中第k位为1的数 将数分为两个集合，第k位为1的集合和第k位不是1的集合 其中x y分别在这两个集合，且相同的元素是在同一个集合里面 于是将其转化成了求重复数字中的单个数值的问题 */ class Solution { public: vector\u0026lt;int\u0026gt; singleNumbers(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int sum = 0; for(auto x : nums) sum ^= x; int k = 0; while(!(sum \u0026gt;\u0026gt; k \u0026amp; 1)) k++; int first = 0; for(auto x : nums){ if(x \u0026gt;\u0026gt; k \u0026amp; 1) first ^= x; } return vector\u0026lt;int\u0026gt;{first, first^sum}; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-56-i%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/","summary":"//一个整型数组 nums 里除两个数字之外，其他数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)","title":"[剑指 Offer 56 - I]数组中数字出现的次数"},{"content":"//输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 // // // // 示例 1: // // 给定二叉树 [3,9,20,null,null,15,7] // // // 3 // / \\ // 9 20 // / \\ // 15 7 // // 返回 true 。 // //示例 2: // // 给定二叉树 [1,2,2,3,3,null,null,4,4] // // // 1 // / \\ // 2 2 // / \\ // 3 3 // / \\ // 4 4 // // // 返回 false 。 // // // // 限制： // // // 0 \u0026lt;= 树的结点个数 \u0026lt;= 10000 // // // 注意：本题与主站 110 题相同：https://leetcode-cn.com/problems/balanced-binary-tree/ // // // Related Topics 树 深度优先搜索 // 👍 114 👎 0 /* * 剑指 Offer 55 - II 平衡二叉树 * 2021-02-18 11:44:55 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isBalanced(TreeNode* root) { if(!root) return true; return isBalanced(root-\u0026gt;left) \u0026amp;\u0026amp; isBalanced(root-\u0026gt;right) \u0026amp;\u0026amp; abs(bfs(root-\u0026gt;right) - bfs(root-\u0026gt;left)) \u0026lt; 2; } int bfs(TreeNode* root){ if(!root) return 0; return max(bfs(root-\u0026gt;left), bfs(root-\u0026gt;right)) + 1; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-55-ii%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"//输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。 // // // //","title":"[剑指 Offer 55 - II]平衡二叉树"},{"content":"//输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 // // 例如： // // 给定二叉树 [3,9,20,null,null,15,7]， // // 3 // / \\ // 9 20 // / \\ // 15 7 // // 返回它的最大深度 3 。 // // // // 提示： // // // 节点总数 \u0026lt;= 10000 // // // 注意：本题与主站 104 题相同：https://leetcode-cn.com/problems/maximum-depth-of-binary-tre //e/ // Related Topics 树 深度优先搜索 // 👍 87 👎 0 /* * 剑指 Offer 55 - I 二叉树的深度 * 2021-02-18 11:44:39 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: int maxDepth(TreeNode* root) { if(!root) return 0; return max(maxDepth(root-\u0026gt;left), maxDepth(root-\u0026gt;right)) + 1; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-55-i%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/","summary":"//输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。 // // 例如","title":"[剑指 Offer 55 - I]二叉树的深度"},{"content":"//给定一棵二叉搜索树，请找出其中第k大的节点。 // // // // 示例 1: // // 输入: root = [3,1,4,null,2], k = 1 // 3 // / \\ // 1 4 // \\ // 2 //输出: 4 // // 示例 2: // // 输入: root = [5,3,6,2,4,null,null,1], k = 3 // 5 // / \\ // 3 6 // / \\ // 2 4 // / // 1 //输出: 4 // // // // 限制： // // 1 ≤ k ≤ 二叉搜索树元素个数 // Related Topics 树 // 👍 118 👎 0 /* * 剑指 Offer 54 二叉搜索树的第k大节点 * 2021-02-18 11:44:28 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; ans; int kthLargest(TreeNode* root, int k) { dfs(root); reverse(ans.begin(), ans.end()); return ans[k-1]; } void dfs(TreeNode* root){ if(!root) return ; dfs(root-\u0026gt;left) ; ans.push_back(root-\u0026gt;val); dfs(root-\u0026gt;right); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-54%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/","summary":"//给定一棵二叉搜索树，请找出其中第k大的节点。 // // // // 示例 1: // // 输入: root = [3,1,4,null,2], k = 1 // 3 // / \\ // 1 4 // \\ // 2 //输出: 4 // // 示例 2: // // 输入:","title":"[剑指 Offer 54]二叉搜索树的第k大节点"},{"content":"//一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字不在该数组中，请找出 //这个数字。 // // // // 示例 1: // // 输入: [0,1,3] //输出: 2 // // // 示例 2: // // 输入: [0,1,2,3,4,5,6,7,9] //输出: 8 // // // // 限制： // // 1 \u0026lt;= 数组长度 \u0026lt;= 10000 // Related Topics 数组 二分查找 // 👍 102 👎 0 /* * 剑指 Offer 53 - II 0～n-1中缺失的数字 * 2021-02-18 11:44:18 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int missingNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int left = 0, right = nums.size() -1; if(nums.size() == 0) return 0; while(left \u0026lt; right){ int mid = left + right \u0026gt;\u0026gt; 1; if(nums[mid] != mid) right = mid; else left = mid + 1; } if(nums[left] == left) return nums.size(); return left; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-53-ii0n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","summary":"//一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0～n-1之内。在范围0～n-1内的n个数字中有且只有一个数字","title":"[剑指 Offer 53 - II]0～n-1中缺失的数字"},{"content":"//统计一个数字在排序数组中出现的次数。 // // // // 示例 1: // // 输入: nums = [5,7,7,8,8,10], target = 8 //输出: 2 // // 示例 2: // // 输入: nums = [5,7,7,8,8,10], target = 6 //输出: 0 // // // // 限制： // // 0 \u0026lt;= 数组长度 \u0026lt;= 50000 // // // // 注意：本题与主站 34 题相同（仅返回值不同）：https://leetcode-cn.com/problems/find-first-and-last- //position-of-element-in-sorted-array/ // Related Topics 数组 二分查找 // 👍 93 👎 0 /* * 剑指 Offer 53 - I 在排序数组中查找数字 I * 2021-02-18 11:44:07 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { if(nums.size() == 0) return 0; int left = 0, right = nums.size() - 1; while(left \u0026lt; right){ int mid = left + right \u0026gt;\u0026gt; 1; if(target \u0026lt;= nums[mid]) right = mid; else left = mid + 1; } int temp = left; left = 0, right = nums.size() - 1; while(left \u0026lt; right){ int mid = 1 + left + right \u0026gt;\u0026gt; 1; if(target \u0026gt;= nums[mid]) left = mid; else right = mid - 1; } if(nums[temp] != target) return 0; return right - temp + 1; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-53-i%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-i/","summary":"//统计一个数字在排序数组中出现的次数。 // // // // 示例 1: // // 输入: nums = [5,7,7,8,8,10], target = 8 //输出: 2 // // 示例 2: // // 输入: nums = [5,7,7,8,8,10], target = 6 //输出: 0 // // // //","title":"[剑指 Offer 53 - I]在排序数组中查找数字 I"},{"content":"//输入两个链表，找出它们的第一个公共节点。 // // 如下面的两个链表： // // // // 在节点 c1 开始相交。 // // // // 示例 1： // // // // 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, s //kipB = 3 //输出：Reference of the node with value = 8 //输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1 //,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 // // // // // 示例 2： // // // // 输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = // 1 //输出：Reference of the node with value = 2 //输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4 //]。在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 // // // // // 示例 3： // // // // 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 //输出：null //输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由于这两个链表不相交，所以 intersectVal 必须为 0，而 // skipA 和 skipB 可以是任意值。 //解释：这两个链表不相交，因此返回 null。 // // // // // 注意： // // // 如果两个链表没有交点，返回 null. // 在返回结果后，两个链表仍须保持原有的结构。 // 可假定整个链表结构中没有循环。 // 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。 // 本题与主站 160 题相同：https://leetcode-cn.com/problems/intersection-of-two-linked-lis //ts/ // // Related Topics 链表 // 👍 160 👎 0 /* * 剑指 Offer 52 两个链表的第一个公共节点 * 2021-02-18 11:43:49 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *getIntersectionNode(ListNode *ha, ListNode *hb) { if(!ha || !hb){ return nullptr; } int lena = 0, lenb = 0; ListNode *p = ha, *q = hb; while(p) p = p-\u0026gt;next, lena++; while(q) q = q-\u0026gt;next, lenb++; if(lena \u0026gt; lenb){ p = ha; q = hb; }else{ p = hb; q = ha; } int gap = abs(lena-lenb); while(gap--){ p = p-\u0026gt;next; } while(p \u0026amp;\u0026amp; q){ if(p == q) return p; p = p-\u0026gt;next; q = q-\u0026gt;next; } return nullptr; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-52%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/","summary":"//输入两个链表，找出它们的第一个公共节点。 // // 如下面的两个链表： // // // // 在节点 c1 开始相交。 // // // // 示例 1： // // // // 输入：intersect","title":"[剑指 Offer 52]两个链表的第一个公共节点"},{"content":"//在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 // // // // 示例 1: // // 输入: [7,5,6,4] //输出: 5 // // // // 限制： // // 0 \u0026lt;= 数组长度 \u0026lt;= 50000 // 👍 316 👎 0 /* * 剑指 Offer 51 数组中的逆序对 * 2021-02-18 11:43:30 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int reversePairs(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int result = merge(nums, 0, nums.size() - 1); // for(auto x : nums) cout\u0026lt;\u0026lt;x\u0026lt;\u0026lt;\u0026#34; \u0026#34;; return result; } int merge(vector\u0026lt;int\u0026gt;\u0026amp; nums ,int left, int right){ if(left \u0026gt;= right) return 0; vector\u0026lt;int\u0026gt; temp; int mid = left + right \u0026gt;\u0026gt; 1; int i = left, j = mid + 1; int res = merge(nums ,left, mid) + merge(nums, mid + 1, right); while(i \u0026lt;= mid \u0026amp;\u0026amp; j \u0026lt;= right){ if(nums[i] \u0026lt;= nums[j]) temp.push_back(nums[i++]); else { temp.push_back(nums[j++]); res += mid - i + 1; } } while(i \u0026lt;= mid) temp.push_back(nums[i++]); while(j \u0026lt;= right) temp.push_back(nums[j++]); i = left; for(auto x : temp){ nums[i++] = x; } return res; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-51%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/","summary":"//在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。 // // // // 示例","title":"[剑指 Offer 51]数组中的逆序对"},{"content":"//在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。 // // 示例: // // s = \u0026#34;abaccdeff\u0026#34; //返回 \u0026#34;b\u0026#34; // //s = \u0026#34;\u0026#34; //返回 \u0026#34; \u0026#34; // // // // // 限制： // // 0 \u0026lt;= s 的长度 \u0026lt;= 50000 // Related Topics 哈希表 // 👍 72 👎 0 /* * 剑指 Offer 50 第一个只出现一次的字符 * 2021-02-18 11:43:19 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: char firstUniqChar(string s) { unordered_map\u0026lt;char, int\u0026gt; mp; for(auto x : s) mp[x]++; for(auto x : s) if(mp[x] == 1) return x; return \u0026#39; \u0026#39;; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-50%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/","summary":"//在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。 // // 示例: // // s = \u0026#34;abaccdeff\u0026#34; //返回 \u0026#34;b\u0026#34; // //s = \u0026#34;\u0026#34; //返回 \u0026#34; \u0026#34; //","title":"[剑指 Offer 50]第一个只出现一次的字符"},{"content":"//我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 // // // // 示例: // // 输入: n = 10 //输出: 12 //解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。 // // 说明: // // // 1 是丑数。 // n 不超过1690。 // // // 注意：本题与主站 264 题相同：https://leetcode-cn.com/problems/ugly-number-ii/ // Related Topics 数学 // 👍 116 👎 0 /* * 剑指 Offer 49 丑数 * 2021-02-18 11:43:06 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int nthUglyNumber(int n) { vector\u0026lt;int\u0026gt; num(1, 1); int i = 0, j = 0, k = 0; while(--n){ int t = min(num[i] * 2, min(num[j] * 3, num[k] * 5)); num.push_back(t); // cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;k\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;endl; if(num[i] * 2 == t) i ++ ; if(num[j] * 3 == t) j ++ ; if(num[k] * 5 == t) k ++ ; } return num.back(); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-49%E4%B8%91%E6%95%B0/","summary":"//我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。 // // // // 示例: // // 输入: n = 10 //输出","title":"[剑指 Offer 49]丑数"},{"content":"//请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 // // // // 示例 1: // // 输入: \u0026#34;abcabcbb\u0026#34; //输出: 3 //解释: 因为无重复字符的最长子串是 \u0026#34;abc\u0026#34;，所以其长度为 3。 // // // 示例 2: // // 输入: \u0026#34;bbbbb\u0026#34; //输出: 1 //解释: 因为无重复字符的最长子串是 \u0026#34;b\u0026#34;，所以其长度为 1。 // // // 示例 3: // // 输入: \u0026#34;pwwkew\u0026#34; //输出: 3 //解释: 因为无重复字符的最长子串是 \u0026#34;wke\u0026#34;，所以其长度为 3。 // 请注意，你的答案必须是 子串 的长度，\u0026#34;pwke\u0026#34; 是一个子序列，不是子串。 // // // // // 提示： // // // s.length \u0026lt;= 40000 // // // 注意：本题与主站 3 题相同：https://leetcode-cn.com/problems/longest-substring-without-rep //eating-characters/ // Related Topics 哈希表 双指针 Sliding Window // 👍 150 👎 0 /* * 剑指 Offer 48 最长不含重复字符的子字符串 * 2021-02-18 11:42:47 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int lengthOfLongestSubstring(string s) { int n = s.size(); unordered_map\u0026lt;char, int\u0026gt; mp; int res = 0; for(int i = 0, j = 0;j \u0026lt; s.size();j++){ mp[s[j]]++; while(mp[s[j]] \u0026gt; 1){ mp[s[i]]--; i++; } res = max(res, j - i + 1); //cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;j\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;res\u0026lt;\u0026lt;endl; } return res; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-48%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","summary":"//请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。 // // // // 示例 1: // // 输入: \u0026#34;abcabcbb\u0026#34; //输出: 3 //解释: 因为无重复","title":"[剑指 Offer 48]最长不含重复字符的子字符串"},{"content":"//在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格、直 //到到达棋盘的右下角。给定一个棋盘及其上面的礼物的价值，请计算你最多能拿到多少价值的礼物？ // // // // 示例 1: // // 输入: //[ // [1,3,1], // [1,5,1], // [4,2,1] //] //输出: 12 //解释: 路径 1→3→5→2→1 可以拿到最多价值的礼物 // // // // 提示： // // // 0 \u0026lt; grid.length \u0026lt;= 200 // 0 \u0026lt; grid[0].length \u0026lt;= 200 // // Related Topics 动态规划 // 👍 105 👎 0 /* * 剑指 Offer 47 礼物的最大价值 * 2021-02-18 11:42:34 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int maxValue(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; grid) { int m = grid.size(); int n = grid[0].size(); vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; dp(m+1, vector\u0026lt;int\u0026gt;(n+1, 0)); for(int i = 1;i \u0026lt;= m;i++){ for(int j = 1;j \u0026lt;= n;j++){ dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i-1][j-1]; } } return dp.back().back(); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-47%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/","summary":"//在一个 m*n 的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于 0）。你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移","title":"[剑指 Offer 47]礼物的最大价值"},{"content":"//给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可 //能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 // // // // 示例 1: // // 输入: 12258 //输出: 5 //解释: 12258有5种不同的翻译，分别是\u0026#34;bccfi\u0026#34;, \u0026#34;bwfi\u0026#34;, \u0026#34;bczi\u0026#34;, \u0026#34;mcfi\u0026#34;和\u0026#34;mzi\u0026#34; // // // // 提示： // // // 0 \u0026lt;= num \u0026lt; 231 // // 👍 183 👎 0 /* * 剑指 Offer 46 把数字翻译成字符串 * 2021-02-18 11:42:18 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int translateNum(int num) { string str = to_string(num); int n = str.size(); vector\u0026lt;int\u0026gt; dp(n+1, 0); dp[0] = 1; dp[1] = 1; for(int i = 2;i \u0026lt;= n;i++){ dp[i] = dp[i-1]; int t = str[i-1] - \u0026#39;0\u0026#39; + (str[i-2] - \u0026#39;0\u0026#39;) * 10; if(t \u0026gt;= 10 \u0026amp;\u0026amp; t \u0026lt;= 25) dp[i] += dp[i-2]; } return dp[n]; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-46%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/","summary":"//给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字","title":"[剑指 Offer 46]把数字翻译成字符串"},{"content":"//输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 // // // // 示例 1: // // 输入: [10,2] //输出: \u0026#34;102\u0026#34; // // 示例 2: // // 输入: [3,30,34,5,9] //输出: \u0026#34;3033459\u0026#34; // // // // 提示: // // // 0 \u0026lt; nums.length \u0026lt;= 100 // // // 说明: // // // 输出结果可能非常大，所以你需要返回一个字符串而不是整数 // 拼接起来的数字可能会有前导 0，最后结果不需要去掉前导 0 // // Related Topics 排序 // 👍 158 👎 0 /* * 剑指 Offer 45 把数组排成最小的数 * 2021-02-18 11:42:05 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: string minNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { sort(nums.begin(), nums.end(), cmp); string res; for(auto x : nums) res += to_string(x); return res; } static bool cmp(int a, int b){ auto as = to_string(a), bs = to_string(b); return as + bs \u0026lt; bs + as; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-45%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/","summary":"//输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。 // // // // 示例 1: // // 输入: [10,2] //输出: \u0026#34;102\u0026#34; // //","title":"[剑指 Offer 45]把数组排成最小的数"},{"content":"//数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4， //等等。 // // 请写一个函数，求任意第n位对应的数字。 // // // // 示例 1： // // 输入：n = 3 //输出：3 // // // 示例 2： // // 输入：n = 11 //输出：0 // // // // 限制： // // // 0 \u0026lt;= n \u0026lt; 2^31 // // // 注意：本题与主站 400 题相同：https://leetcode-cn.com/problems/nth-digit/ // Related Topics 数学 // 👍 86 👎 0 /* * 剑指 Offer 44 数字序列中某一位的数字 * 2021-02-18 11:41:52 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int findNthDigit(int n) { int digit = 1; long long s = 9, base = 1; while(n \u0026gt; digit * s) { n -= digit * s; digit++; s *= 10; base *= 10; // cout\u0026lt;\u0026lt;digit\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;s\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;base\u0026lt;\u0026lt;endl; } int number = base + (n-1) / digit; int r = n % digit ? n % digit : digit; //cout\u0026lt;\u0026lt;number\u0026lt;\u0026lt;endl; for(int j = 0;j \u0026lt; digit - r;j++) number /= 10; return number % 10; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-44%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/","summary":"//数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位","title":"[剑指 Offer 44]数字序列中某一位的数字"},{"content":"//输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。 // // 例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。 // // // // 示例 1： // // //输入：n = 12 //输出：5 // // // 示例 2： // // //输入：n = 13 //输出：6 // // // // 限制： // // // 1 \u0026lt;= n \u0026lt; 2^31 // // // 注意：本题与主站 233 题相同：https://leetcode-cn.com/problems/number-of-digit-one/ // Related Topics 数学 // 👍 129 👎 0 /* * 剑指 Offer 43 1～n 整数中 1 出现的次数 * 2021-02-18 11:41:34 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int countDigitOne(int n) { vector\u0026lt;int\u0026gt; number; while(n) number.push_back(n % 10), n /= 10; //ab*c*def left=\u0026gt;ab right=\u0026gt;def t = power(10,c) // 0-(ab-1) c=1 t ans += ab * t // ab 1. c = 0 ab * t ans += 0 // 2. c = 1 def ans += def // 3. c = 2 t ans += t int ans = 0; for(int i = number.size() - 1;i \u0026gt;= 0;i--){ int left = 0, right = 0, t =1; for(int j = number.size() - 1;j \u0026gt; i;j--) left = left * 10 + number[j]; for(int j = i - 1;j \u0026gt;= 0;j--) right = right * 10 + number[j], t *= 10; ans += t * left; if(number[i] == 1) ans += right + 1; if(number[i] \u0026gt; 1) ans += t; } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-431n-%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/","summary":"//输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。 // // 例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，","title":"[剑指 Offer 43]1～n 整数中 1 出现的次数"},{"content":"//输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 // // 要求时间复杂度为O(n)。 // // // // 示例1: // // 输入: nums = [-2,1,-3,4,-1,2,1,-5,4] //输出: 6 //解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 // // // // 提示： // // // 1 \u0026lt;= arr.length \u0026lt;= 10^5 // -100 \u0026lt;= arr[i] \u0026lt;= 100 // // // 注意：本题与主站 53 题相同：https://leetcode-cn.com/problems/maximum-subarray/ // // // Related Topics 分治算法 动态规划 // 👍 202 👎 0 /* * 剑指 Offer 42 连续子数组的最大和 * 2021-02-18 11:41:19 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: // sum is the result of [1...k](1 \u0026lt;= k \u0026lt;= n,sum must end with nums[k]) // if(sum \u0026lt; 0) sum = nums[i]; // else sum = sum + nums[i]; int maxSubArray(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int ans = INT_MIN; int cur = 0; for(int i = 0;i \u0026lt; nums.size();i++){ if(cur \u0026lt; 0) cur = 0; cur += nums[i]; ans = max(ans, cur); } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-42%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/","summary":"//输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。 // // 要求时间复杂度为O(n)。 // // // // 示例1: // //","title":"[剑指 Offer 42]连续子数组的最大和"},{"content":"//如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数 //值排序之后中间两个数的平均值。 // // 例如， // // [2,3,4] 的中位数是 3 // // [2,3] 的中位数是 (2 + 3) / 2 = 2.5 // // 设计一个支持以下两种操作的数据结构： // // // void addNum(int num) - 从数据流中添加一个整数到数据结构中。 // double findMedian() - 返回目前所有元素的中位数。 // // // 示例 1： // // 输入： //[\u0026#34;MedianFinder\u0026#34;,\u0026#34;addNum\u0026#34;,\u0026#34;addNum\u0026#34;,\u0026#34;findMedian\u0026#34;,\u0026#34;addNum\u0026#34;,\u0026#34;findMedian\u0026#34;] //[[],[1],[2],[],[3],[]] //输出：[null,null,null,1.50000,null,2.00000] // // // 示例 2： // // 输入： //[\u0026#34;MedianFinder\u0026#34;,\u0026#34;addNum\u0026#34;,\u0026#34;findMedian\u0026#34;,\u0026#34;addNum\u0026#34;,\u0026#34;findMedian\u0026#34;] //[[],[2],[],[3],[]] //输出：[null,null,2.00000,null,2.50000] // // // // 限制： // // // 最多会对 addNum、findMedian 进行 50000 次调用。 // // // 注意：本题与主站 295 题相同：https://leetcode-cn.com/problems/find-median-from-data-strea //m/ // Related Topics 堆 设计 // 👍 101 👎 0 /* * 剑指 Offer 41 数据流中的中位数 * 2021-02-18 11:41:00 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class MedianFinder { public: priority_queue\u0026lt;int\u0026gt; maxHeap; priority_queue\u0026lt;int ,vector\u0026lt;int\u0026gt;, greater\u0026lt;int\u0026gt;\u0026gt; minHeap; /** initialize your data structure here. */ MedianFinder() { } void addNum(int num) { minHeap.push(num); if(minHeap.size() \u0026gt; maxHeap.size() + 1){ maxHeap.push(minHeap.top()); minHeap.pop(); } if(maxHeap.size() \u0026amp;\u0026amp; maxHeap.top() \u0026gt; minHeap.top()){ int m = maxHeap.top(); int n = minHeap.top(); minHeap.pop(); minHeap.push(m); maxHeap.pop(); maxHeap.push(n); } } double findMedian() { int m = maxHeap.size(); int n = minHeap.size(); if(m + n \u0026amp; 1) return minHeap.top(); else return (maxHeap.top() + minHeap.top()) / 2.0; } }; /** * Your MedianFinder object will be instantiated and called as such: * MedianFinder* obj = new MedianFinder(); * obj-\u0026gt;addNum(num); * double param_2 = obj-\u0026gt;findMedian(); */ //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-41%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","summary":"//如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，","title":"[剑指 Offer 41]数据流中的中位数"},{"content":"//输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 // // // // 示例 1： // // 输入：arr = [3,2,1], k = 2 //输出：[1,2] 或者 [2,1] // // // 示例 2： // // 输入：arr = [0,1,2,1], k = 1 //输出：[0] // // // // 限制： // // // 0 \u0026lt;= k \u0026lt;= arr.length \u0026lt;= 10000 // 0 \u0026lt;= arr[i] \u0026lt;= 10000 // // Related Topics 堆 分治算法 // 👍 191 👎 0 /* * 剑指 Offer 40 最小的k个数 * 2021-02-18 11:40:47 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;int\u0026gt; getLeastNumbers(vector\u0026lt;int\u0026gt;\u0026amp; arr, int k) { int n = arr.size(); priority_queue\u0026lt;int, vector\u0026lt;int\u0026gt;, less\u0026lt;int\u0026gt;\u0026gt; pq; for(int i = 0;i \u0026lt; n;i++){ if(pq.size() \u0026lt; k){ pq.push(arr[i]); }else{ if(pq.size() \u0026amp;\u0026amp; pq.top() \u0026gt; arr[i]) pq.pop(), pq.push(arr[i]); } } vector\u0026lt;int\u0026gt; ans; while(pq.size()) ans.push_back(pq.top()), pq.pop(); return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-40%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/","summary":"//输入整数数组 arr ，找出其中最小的 k 个数。例如，输入4、5、1、6、2、7、3、8这8个数字，则最小的4个数字是1、2、3、4。 // // // // 示例","title":"[剑指 Offer 40]最小的k个数"},{"content":"//数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 // // // // 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 // // // // 示例 1: // // 输入: [1, 2, 3, 2, 2, 2, 5, 4, 2] //输出: 2 // // // // 限制： // // 1 \u0026lt;= 数组长度 \u0026lt;= 50000 // // // // 注意：本题与主站 169 题相同：https://leetcode-cn.com/problems/majority-element/ // // // Related Topics 位运算 分治算法 // 👍 111 👎 0 /* * 剑指 Offer 39 数组中出现次数超过一半的数字 * 2021-02-18 11:40:33 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int majorityElement(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int res = nums[0]; int freq = 0; for(int i = 1;i \u0026lt; nums.size();i++){ if(nums[i] == res){ freq++; }else{ if(freq == 0){ res = nums[i]; }else{ freq--; } } } return res; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-39%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/","summary":"//数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。 // // // // 你可以假设数组是非空的，并且给定的数组总是存在多数元素。 // // // // 示","title":"[剑指 Offer 39]数组中出现次数超过一半的数字"},{"content":"//输入一个字符串，打印出该字符串中字符的所有排列。 // // // // 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 // // // // 示例: // // 输入：s = \u0026#34;abc\u0026#34; //输出：[\u0026#34;abc\u0026#34;,\u0026#34;acb\u0026#34;,\u0026#34;bac\u0026#34;,\u0026#34;bca\u0026#34;,\u0026#34;cab\u0026#34;,\u0026#34;cba\u0026#34;] // // // // // 限制： // // 1 \u0026lt;= s 的长度 \u0026lt;= 8 // Related Topics 回溯算法 // 👍 183 👎 0 /* * 剑指 Offer 38 字符串的排列 * 2021-02-18 11:40:19 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: set\u0026lt;string\u0026gt; se; vector\u0026lt;string\u0026gt; permutation(string s) { vector\u0026lt;bool\u0026gt; vis(s.size(), false); string cur; dfs(s, vis, cur); vector\u0026lt;string\u0026gt; res; for(auto it = se.begin();it != se.end();it++) res.push_back(*it); return res; } void dfs(string\u0026amp; str, vector\u0026lt;bool\u0026gt;\u0026amp; vis, string\u0026amp; cur){ if(cur.size() == str.size()){ se.insert(cur); return ; } for(int i = 0;i \u0026lt; str.size();i++){ if(!vis[i]){ string temp = cur; cur += str[i]; vis[i] = true; dfs(str, vis, cur); vis[i] = false; cur = temp; } } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-38%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/","summary":"//输入一个字符串，打印出该字符串中字符的所有排列。 // // // // 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。 // // // // 示例: // // 输入","title":"[剑指 Offer 38]字符串的排列"},{"content":"//请实现两个函数，分别用来序列化和反序列化二叉树。 // // 示例: // // 你可以将以下二叉树： // // 1 // / \\ // 2 3 // / \\ // 4 5 // //序列化为 \u0026#34;[1,2,3,null,null,4,5]\u0026#34; // // 注意：本题与主站 297 题相同：https://leetcode-cn.com/problems/serialize-and-deserialize-b //inary-tree/ // Related Topics 树 设计 // 👍 109 👎 0 /* * 剑指 Offer 37 序列化二叉树 * 2021-02-18 11:39:58 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Codec { public: // Encodes a tree to a single string. string serialize(TreeNode* root) { string res; dfs_s(root, res); return res; } void dfs_s(TreeNode* root, string\u0026amp; res){ if(!root){ res += \u0026#34;null \u0026#34;; return ; } res += to_string(root-\u0026gt;val) + \u0026#39; \u0026#39;; dfs_s(root-\u0026gt;left, res); dfs_s(root-\u0026gt;right, res); } // Decodes your encoded data to tree. TreeNode* deserialize(string data) { int u = 0; return dfs_d(data, u); } TreeNode* dfs_d(string data, int \u0026amp;u){ // return nullptr; if(u == data.size()) return nullptr; int k = u; while(data[k] != \u0026#39; \u0026#39;) k++; if(data[u] == \u0026#39;n\u0026#39;){ u = k + 1; return nullptr; } bool flag = false; if(data[u] == \u0026#39;-\u0026#39;){ flag = true; } int val = 0; u = (flag ? u+1 : u); for(int i = u;i \u0026lt; k;i++){ val = val * 10 + data[i] - \u0026#39;0\u0026#39;; } if(flag) val = -val; u = k + 1; auto root = new TreeNode(val); root-\u0026gt;left = dfs_d(data, u); root-\u0026gt;right = dfs_d(data, u); return root; } }; // Your Codec object will be instantiated and called as such: // Codec codec; // codec.deserialize(codec.serialize(root)); //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-37%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"//请实现两个函数，分别用来序列化和反序列化二叉树。 // // 示例: // // 你可以将以下二叉树： // // 1 // / \\ // 2 3 // / \\ // 4 5 // //序列化为 \u0026#34;[1,2,3,null,null,4,5]\u0026#34; // // 注意","title":"[剑指 Offer 37]序列化二叉树"},{"content":"//输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 // // // // 为了让您更好地理解问题，以下面的二叉搜索树为例： // // // // // // // // 我们希望将这个二叉搜索树转化为双向循环链表。链表中的每个节点都有一个前驱和后继指针。对于双向循环链表，第一个节点的前驱是最后一个节点，最后一个节点的后继是 //第一个节点。 // // 下图展示了上面的二叉搜索树转化成的链表。“head” 表示指向链表中有最小元素的节点。 // // // // // // // // 特别地，我们希望可以就地完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中的第一个节点的指针。 // // // // 注意：本题与主站 426 题相同：https://leetcode-cn.com/problems/convert-binary-search-tree- //to-sorted-doubly-linked-list/ // // 注意：此题对比原题有改动。 // Related Topics 分治算法 // 👍 181 👎 0 /* * 剑指 Offer 36 二叉搜索树与双向链表 * 2021-02-18 11:39:03 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /* // Definition for a Node. class Node { public: int val; Node* left; Node* right; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; */ class Solution { public: Node *pre, *head; Node* treeToDoublyList(Node* root) { if(!root) return nullptr; dfs(root); head-\u0026gt;left = pre; pre-\u0026gt;right = head; return head; } void dfs(Node* root){ if(!root) return ; dfs(root-\u0026gt;left); if(pre) pre-\u0026gt;right = root; else head = root; root-\u0026gt;left = pre; pre = root; dfs(root-\u0026gt;right); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-36%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/","summary":"//输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的循环双向链表。要求不能创建任何新的节点，只能调整树中节点指针的指向。 // // // // 为了让您更","title":"[剑指 Offer 36]二叉搜索树与双向链表"},{"content":"//请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指 //向链表中的任意节点或者 null。 // // // // 示例 1： // // // // 输入：head = [[7,null],[13,0],[11,4],[10,2],[1,0]] //输出：[[7,null],[13,0],[11,4],[10,2],[1,0]] // // // 示例 2： // // // // 输入：head = [[1,1],[2,1]] //输出：[[1,1],[2,1]] // // // 示例 3： // // // // 输入：head = [[3,null],[3,0],[3,null]] //输出：[[3,null],[3,0],[3,null]] // // // 示例 4： // // 输入：head = [] //输出：[] //解释：给定的链表为空（空指针），因此返回 null。 // // // // // 提示： // // // -10000 \u0026lt;= Node.val \u0026lt;= 10000 // Node.random 为空（null）或指向链表中的节点。 // 节点数目不超过 1000 。 // // // // // 注意：本题与主站 138 题相同：https://leetcode-cn.com/problems/copy-list-with-random-point //er/ // // // Related Topics 链表 // 👍 144 👎 0 /* * 剑指 Offer 35 复杂链表的复制 * 2021-02-18 11:38:35 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /* // Definition for a Node. class Node { public: int val; Node* next; Node* random; Node(int _val) { val = _val; next = NULL; random = NULL; } }; */ class Solution { public: Node* copyRandomList(Node* head) { if(!head) return nullptr; auto p = head; Node* q; while(p){ q = p-\u0026gt;next; p-\u0026gt;next = new Node(p-\u0026gt;val); p-\u0026gt;next-\u0026gt;next =q; p = q; } Node* cp = nullptr; p = head; while(p){ cp = p-\u0026gt;next; q = p-\u0026gt;next-\u0026gt;next; cp-\u0026gt;random = p-\u0026gt;random ? p-\u0026gt;random-\u0026gt;next : nullptr; p = q; } Node* res = head-\u0026gt;next; p = head; while(p){ cp = p-\u0026gt;next; q = p-\u0026gt;next-\u0026gt;next; p-\u0026gt;next = q; cp-\u0026gt;next = q ? q-\u0026gt;next : nullptr; p = q; } return res; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-35%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/","summary":"//请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指 //向链表中的任意节点或者 null","title":"[剑指 Offer 35]复杂链表的复制"},{"content":"//输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 // // // // 示例: //给定如下二叉树，以及目标和 sum = 22， // // 5 // / \\ // 4 8 // / / \\ // 11 13 4 // / \\ / \\ // 7 2 5 1 // // // 返回: // // [ // [5,4,11,2], // [5,8,4,5] //] // // // // // 提示： // // // 节点总数 \u0026lt;= 10000 // // // 注意：本题与主站 113 题相同：https://leetcode-cn.com/problems/path-sum-ii/ // Related Topics 树 深度优先搜索 // 👍 132 👎 0 /* * 剑指 Offer 34 二叉树中和为某一值的路径 * 2021-02-18 11:38:17 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; res; vector\u0026lt;int\u0026gt; cur; vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; pathSum(TreeNode* root, int sum) { if(!root) return res; dfs(root, sum); return res; } void dfs(TreeNode* root, int sum){ if(!root) return ; cur.push_back(root-\u0026gt;val); sum -= root-\u0026gt;val; if(!root-\u0026gt;left \u0026amp;\u0026amp; !root-\u0026gt;right \u0026amp;\u0026amp; !sum) res.push_back(cur); dfs(root-\u0026gt;left, sum); dfs(root-\u0026gt;right, sum); sum += root-\u0026gt;val; cur.pop_back(); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-34%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/","summary":"//输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。 // // //","title":"[剑指 Offer 34]二叉树中和为某一值的路径"},{"content":"//输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互不相同。 // // // // 参考以下这颗二叉搜索树： // // 5 // / \\ // 2 6 // / \\ // 1 3 // // 示例 1： // // 输入: [1,6,3,2,5] //输出: false // // 示例 2： // // 输入: [1,3,2,6,5] //输出: true // // // // 提示： // // // 数组长度 \u0026lt;= 1000 // // 👍 193 👎 0 /* * 剑指 Offer 33 二叉搜索树的后序遍历序列 * 2021-02-18 11:38:09 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: bool verifyPostorder(vector\u0026lt;int\u0026gt;\u0026amp; postorder) { int n = postorder.size(); return verify(postorder, 0, n - 1); } bool verify(vector\u0026lt;int\u0026gt;\u0026amp; postorder, int left, int right){ if(left \u0026gt; right) return true; int i; for(i = left;i \u0026lt; right;i++){ if(postorder[i] \u0026gt; postorder[right]) break; } int pivot = i; for(;i \u0026lt; right;i++){ if(postorder[i] \u0026lt; postorder[right]){ return false; } } return verify(postorder, left, pivot - 1) \u0026amp;\u0026amp; verify(postorder, pivot, right - 1); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-33%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/","summary":"//输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历结果。如果是则返回 true，否则返回 false。假设输入的数组的任意两个数字都互","title":"[剑指 Offer 33]二叉搜索树的后序遍历序列"},{"content":"//请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。 // // // // 例如: //给定二叉树: [3,9,20,null,null,15,7], // // 3 // / \\ // 9 20 // / \\ // 15 7 // // // 返回其层次遍历结果： // // [ // [3], // [20,9], // [15,7] //] // // // // // 提示： // // // 节点总数 \u0026lt;= 1000 // // Related Topics 树 广度优先搜索 // 👍 73 👎 0 /* * 剑指 Offer 32 - III 从上到下打印二叉树 III * 2021-02-18 11:37:40 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; if(!root) return ans; bfs(root, ans); return ans; } void bfs(TreeNode* root, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; ans){ if(!root) return ; queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); vector\u0026lt;int\u0026gt; temp; int j = 1; while(q.size()){ int n = q.size(); temp.clear(); j++; for(int i = n - 1;i \u0026gt;= 0;i--){ auto t = q.front(); temp.push_back(q.front()-\u0026gt;val); q.pop(); if(t-\u0026gt;left) q.push(t-\u0026gt;left); if(t-\u0026gt;right) q.push(t-\u0026gt;right); } if(j % 2 == 0) ans.push_back(temp); else { reverse(temp.begin(), temp.end()); ans.push_back(temp); } } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-32-iii%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-iii/","summary":"//请实现一个函数按照之字形顺序打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其","title":"[剑指 Offer 32 - III]从上到下打印二叉树 III"},{"content":"//从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 // // // // 例如: //给定二叉树: [3,9,20,null,null,15,7], // // 3 // / \\ // 9 20 // / \\ // 15 7 // // // 返回其层次遍历结果： // // [ // [3], // [9,20], // [15,7] //] // // // // // 提示： // // // 节点总数 \u0026lt;= 1000 // // // 注意：本题与主站 102 题相同：https://leetcode-cn.com/problems/binary-tree-level-order-tra //versal/ // Related Topics 树 广度优先搜索 // 👍 80 👎 0 /* * 剑指 Offer 32 - II 从上到下打印二叉树 II * 2021-02-18 11:37:25 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; ans; if(!root) return ans; bfs(root, ans); return ans; } void bfs(TreeNode* root, vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; ans){ if(!root) return ; queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); vector\u0026lt;int\u0026gt; temp; int j = 1; while(q.size()){ int n = q.size(); temp.clear(); j++; for(int i = n - 1;i \u0026gt;= 0;i--){ auto t = q.front(); temp.push_back(q.front()-\u0026gt;val); q.pop(); if(t-\u0026gt;left) q.push(t-\u0026gt;left); if(t-\u0026gt;right) q.push(t-\u0026gt;right); } if(j % 2 == 0) ans.push_back(temp); else { // reverse(temp.begin(), temp.end()); ans.push_back(temp); } } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-32-ii%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91-ii/","summary":"//从上到下按层打印二叉树，同一层的节点按从左到右的顺序打印，每一层打印到一行。 // // // // 例如: //给定二叉树: [3,9,20,null,null,15,7], // // 3 // / \\ // 9 20 // / \\ // 15","title":"[剑指 Offer 32 - II]从上到下打印二叉树 II"},{"content":"//从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 // // // // 例如: //给定二叉树: [3,9,20,null,null,15,7], // // 3 // / \\ // 9 20 // / \\ // 15 7 // // // 返回： // // [3,9,20,15,7] // // // // // 提示： // // // 节点总数 \u0026lt;= 1000 // // Related Topics 树 广度优先搜索 // 👍 60 👎 0 /* * 剑指 Offer 32 - I 从上到下打印二叉树 * 2021-02-18 11:37:09 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; levelOrder(TreeNode* root) { vector\u0026lt;int\u0026gt; ans; if(!root) return ans; bfs(root, ans); return ans; } void bfs(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; ans){ if(!root) return ; queue\u0026lt;TreeNode*\u0026gt; q; q.push(root); while(q.size()){ TreeNode* t = q.front(); ans.push_back(t-\u0026gt;val); q.pop(); if(t-\u0026gt;left) q.push(t-\u0026gt;left); if(t-\u0026gt;right) q.push(t-\u0026gt;right); } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-32-i%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"//从上到下打印出二叉树的每个节点，同一层的节点按照从左到右的顺序打印。 // // // // 例如: //给定二叉树: [3,9,20,null,null,15,7], // // 3 // / \\ // 9 20 // / \\ // 15 7 // // //","title":"[剑指 Offer 32 - I]从上到下打印二叉树"},{"content":"//输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈 //的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。 // // // // 示例 1： // // 输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1] //输出：true //解释：我们可以按以下顺序执行： //push(1), push(2), push(3), push(4), pop() -\u0026gt; 4, //push(5), pop() -\u0026gt; 5, pop() -\u0026gt; 3, pop() -\u0026gt; 2, pop() -\u0026gt; 1 // // // 示例 2： // // 输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2] //输出：false //解释：1 不能在 2 之前弹出。 // // // // // 提示： // // // 0 \u0026lt;= pushed.length == popped.length \u0026lt;= 1000 // 0 \u0026lt;= pushed[i], popped[i] \u0026lt; 1000 // pushed 是 popped 的排列。 // // // 注意：本题与主站 946 题相同：https://leetcode-cn.com/problems/validate-stack-sequences/ // 👍 123 👎 0 /* * 剑指 Offer 31 栈的压入、弹出序列 * 2021-02-18 11:36:59 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: bool validateStackSequences(vector\u0026lt;int\u0026gt;\u0026amp; pushed, vector\u0026lt;int\u0026gt;\u0026amp; popped) { int n = pushed.size(); if(n != popped.size()) return false; stack\u0026lt;int\u0026gt; stk; int j = 0; for(int i = 0;i \u0026lt; pushed.size();i++){ // push and pop stk.push(pushed[i]); while(!stk.empty() \u0026amp;\u0026amp; stk.top() == popped[j]) stk.pop(),j++; } while(stk.size()){ // continue pop if(stk.top() == popped[j]){ stk.pop(); j++; }else{ return false; } } return j == popped.size(); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-31%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/","summary":"//输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈 //","title":"[剑指 Offer 31]栈的压入、弹出序列"},{"content":"//定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 // // // // 示例: // // MinStack minStack = new MinStack(); //minStack.push(-2); //minStack.push(0); //minStack.push(-3); //minStack.min(); --\u0026gt; 返回 -3. //minStack.pop(); //minStack.top(); --\u0026gt; 返回 0. //minStack.min(); --\u0026gt; 返回 -2. // // // // // 提示： // // // 各函数的调用总次数不超过 20000 次 // // // // // 注意：本题与主站 155 题相同：https://leetcode-cn.com/problems/min-stack/ // Related Topics 栈 设计 // 👍 88 👎 0 /* * 剑指 Offer 30 包含min函数的栈 * 2021-02-18 11:36:32 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class MinStack { public: stack\u0026lt;int\u0026gt; stk; stack\u0026lt;int\u0026gt; cache; /** initialize your data structure here. */ MinStack() { } void push(int x) { stk.push(x); if(cache.empty() || cache.top() \u0026gt;= x) cache.push(x); } void pop() { if(stk.empty()) return ; if(stk.top() == cache.top()){ cache.pop(); } stk.pop(); } int top() { return stk.empty() ? 0 : stk.top(); } int min() { return cache.empty() ? 0 : cache.top(); } }; /** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-\u0026gt;push(x); * obj-\u0026gt;pop(); * int param_3 = obj-\u0026gt;top(); * int param_4 = obj-\u0026gt;min(); */ //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-30%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/","summary":"//定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。 // // // // 示","title":"[剑指 Offer 30]包含min函数的栈"},{"content":"//输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 // // // // 示例 1： // // 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] //输出：[1,2,3,6,9,8,7,4,5] // // // 示例 2： // // 输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]] //输出：[1,2,3,4,8,12,11,10,9,5,6,7] // // // // // 限制： // // // 0 \u0026lt;= matrix.length \u0026lt;= 100 // 0 \u0026lt;= matrix[i].length \u0026lt;= 100 // // // 注意：本题与主站 54 题相同：https://leetcode-cn.com/problems/spiral-matrix/ // Related Topics 数组 // 👍 190 👎 0 /* * 剑指 Offer 29 顺时针打印矩阵 * 2021-02-18 11:36:05 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;int\u0026gt; spiralOrder(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int dx[] = {-1, 0 ,1, 0}, dy[] = {0, 1, 0, -1}; vector\u0026lt;int\u0026gt; ans; int m = matrix.size(); if(!m) return ans; int n = matrix[0].size(); if(!n) return ans; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; vis(m, vector\u0026lt;bool\u0026gt;(n, false)); int x = 0, y = 0, d =1; for(int i = 0;i \u0026lt; n * m;i++){ ans.push_back(matrix[x][y]); vis[x][y] = true; int a = x + dx[d]; int b = y + dy[d]; if(a \u0026lt; 0 || a \u0026gt;= m || b \u0026lt; 0 || b \u0026gt;= n || vis[a][b]){ d = (d + 1) % 4; a = x + dx[d]; b = y + dy[d]; } x = a, y = b; } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-29%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/","summary":"//输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 // // // // 示例 1： // // 输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] //输出：[1,2,3,6,9,","title":"[剑指 Offer 29]顺时针打印矩阵"},{"content":"//请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 // // 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 // // 1 // / \\ // 2 2 // / \\ / \\ //3 4 4 3 //但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: // // 1 // / \\ // 2 2 // \\ \\ // 3 3 // // // // 示例 1： // // 输入：root = [1,2,2,3,4,4,3] //输出：true // // // 示例 2： // // 输入：root = [1,2,2,null,3,null,3] //输出：false // // // // 限制： // // 0 \u0026lt;= 节点个数 \u0026lt;= 1000 // // 注意：本题与主站 101 题相同：https://leetcode-cn.com/problems/symmetric-tree/ // Related Topics 树 // 👍 130 👎 0 /* * 剑指 Offer 28 对称的二叉树 * 2021-02-18 11:35:51 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isSymmetric(TreeNode* root) { if(!root) return true; return symmetric(root-\u0026gt;left, root-\u0026gt;right); } bool symmetric(TreeNode* l, TreeNode* r){ if(!l \u0026amp;\u0026amp; !r) return true; if(!l || !r) return false; if(l-\u0026gt;val != r-\u0026gt;val) return false; return symmetric(l-\u0026gt;left, r-\u0026gt;right) \u0026amp;\u0026amp; symmetric(l-\u0026gt;right, r-\u0026gt;left); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-28%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"//请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。 // // 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 // // 1 // / \\ //","title":"[剑指 Offer 28]对称的二叉树"},{"content":"//请完成一个函数，输入一个二叉树，该函数输出它的镜像。 // // 例如输入： // // 4 // / \\ // 2 7 // / \\ / \\ //1 3 6 9 //镜像输出： // // 4 // / \\ // 7 2 // / \\ / \\ //9 6 3 1 // // // // 示例 1： // // 输入：root = [4,2,7,1,3,6,9] //输出：[4,7,2,9,6,3,1] // // // // // 限制： // // 0 \u0026lt;= 节点个数 \u0026lt;= 1000 // // 注意：本题与主站 226 题相同：https://leetcode-cn.com/problems/invert-binary-tree/ // Related Topics 树 // 👍 101 👎 0 /* * 剑指 Offer 27 二叉树的镜像 * 2021-02-18 11:35:20 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* mirrorTree(TreeNode* root) { if(!root) return nullptr; auto l = root-\u0026gt;left; auto r = root-\u0026gt;right; root-\u0026gt;right = mirrorTree(l); root-\u0026gt;left = mirrorTree(r); return root; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-27%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/","summary":"//请完成一个函数，输入一个二叉树，该函数输出它的镜像。 // // 例如输入： // // 4 // / \\ // 2 7 // / \\ / \\ //1 3 6 9 //镜像输出： // // 4 // / \\ // 7 2 //","title":"[剑指 Offer 27]二叉树的镜像"},{"content":"//输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) // // B是A的子结构， 即 A中有出现和B相同的结构和节点值。 // // 例如: //给定的树 A: // // 3 // / \\ // 4 5 // / \\ // 1 2 //给定的树 B： // // 4 // / // 1 //返回 true，因为 B 与 A 的一个子树拥有相同的结构和节点值。 // // 示例 1： // // 输入：A = [1,2,3], B = [3,1] //输出：false // // // 示例 2： // // 输入：A = [3,4,5,1,2], B = [4,1] //输出：true // // 限制： // // 0 \u0026lt;= 节点个数 \u0026lt;= 10000 // Related Topics 树 // 👍 188 👎 0 /* * 剑指 Offer 26 树的子结构 * 2021-02-18 11:35:04 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: bool isSubStructure(TreeNode* A, TreeNode* B) { if (!A || !B) return false; if(isPart(A, B)) return true; return isSubStructure(A-\u0026gt;left, B) || isSubStructure(A-\u0026gt;right, B); } bool isPart(TreeNode* a, TreeNode* b){ if(!b) return true; if(!a) return false; if(a-\u0026gt;val != b-\u0026gt;val) return false; return isPart(a-\u0026gt;left, b-\u0026gt;left) \u0026amp;\u0026amp; isPart(a-\u0026gt;right, b-\u0026gt;right); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-26%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/","summary":"//输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构) // // B是A的子结构， 即 A中有出现和B相同的结构和节点值。","title":"[剑指 Offer 26]树的子结构"},{"content":"//输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 // // 示例1： // // 输入：1-\u0026gt;2-\u0026gt;4, 1-\u0026gt;3-\u0026gt;4 //输出：1-\u0026gt;1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;4 // // 限制： // // 0 \u0026lt;= 链表长度 \u0026lt;= 1000 // // 注意：本题与主站 21 题相同：https://leetcode-cn.com/problems/merge-two-sorted-lists/ // Related Topics 分治算法 // 👍 83 👎 0 /* * 剑指 Offer 25 合并两个排序的链表 * 2021-02-18 11:34:28 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(!l1 || !l2) return l1 ? l1 : l2; ListNode dummy(-1); ListNode* p = \u0026amp;dummy; dummy.next = l1-\u0026gt;val \u0026gt; l2-\u0026gt;val ? l2 : l1; while(l1 \u0026amp;\u0026amp; l2){ if(l1-\u0026gt;val \u0026gt; l2-\u0026gt;val){ ListNode* temp = l2-\u0026gt;next; p-\u0026gt;next = l2; l2 = temp; }else{ ListNode* temp = l1-\u0026gt;next; p-\u0026gt;next = l1; l1 = temp; } p = p-\u0026gt;next; } if(l1) p-\u0026gt;next = l1; if(l2) p-\u0026gt;next = l2; return dummy.next; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-25%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/","summary":"//输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。 // // 示例1： // // 输入：1-\u0026gt;2-\u0026gt;4, 1-\u0026gt;3-\u0026gt;4 //输出：","title":"[剑指 Offer 25]合并两个排序的链表"},{"content":"//定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 // // // // 示例: // // 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL //输出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL // // // // 限制： // // 0 \u0026lt;= 节点个数 \u0026lt;= 5000 // // // // 注意：本题与主站 206 题相同：https://leetcode-cn.com/problems/reverse-linked-list/ // Related Topics 链表 // 👍 171 👎 0 /* * 剑指 Offer 24 反转链表 * 2021-02-18 11:34:23 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* reverseList(ListNode* head) { if(!head || !head-\u0026gt;next) return head; ListNode* newHead = reverseList(head-\u0026gt;next); head-\u0026gt;next-\u0026gt;next = head; head-\u0026gt;next = nullptr; return newHead; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-24%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/","summary":"//定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。 // // // // 示例: // // 输入: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5-\u0026gt;NULL //输出: 5-\u0026gt;4-\u0026gt;3-\u0026gt;2-\u0026gt;1-\u0026gt;NULL // // // // 限制： // // 0 \u0026lt;= 节点","title":"[剑指 Offer 24]反转链表"},{"content":"//输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 // // 例如，一个链表有 6 个节点，从头节点开始，它们的值依次是 1、2、3、4、5、6。这个链表的倒数第 2 个节点是值为 4 的节点。 // // // // 示例： // // //给定一个链表: 1-\u0026gt;2-\u0026gt;3-\u0026gt;4-\u0026gt;5, 和 k = 2. // //返回链表 4-\u0026gt;5. // Related Topics 链表 双指针 // 👍 137 👎 0 /* * 剑指 Offer 22 链表中倒数第k个节点 * 2021-02-18 11:34:11 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* getKthFromEnd(ListNode* head, int k) { if(!head) return nullptr; ListNode* pre = head; while(k--){ if(pre) pre = pre-\u0026gt;next; else return nullptr; } ListNode* cur = head; while(pre){ cur = cur-\u0026gt;next; pre = pre-\u0026gt;next; } return cur; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-22%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","summary":"//输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。 // // 例如，一个链表有","title":"[剑指 Offer 22]链表中倒数第k个节点"},{"content":"//输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 // // // // 示例： // // 输入：nums = [1,2,3,4] //输出：[1,3,2,4] //注：[3,1,2,4] 也是正确的答案之一。 // // // // 提示： // // // 1 \u0026lt;= nums.length \u0026lt;= 50000 // 1 \u0026lt;= nums[i] \u0026lt;= 10000 // // 👍 81 👎 0 /* * 剑指 Offer 21 调整数组顺序使奇数位于偶数前面 * 2021-02-18 11:34:00 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;int\u0026gt; exchange(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int n = nums.size(); int i = 0, j = nums.size() - 1; while(i \u0026lt; j){ while(i \u0026lt; nums.size() \u0026amp;\u0026amp; nums[i] % 2 == 1) i++; while(j \u0026gt;= 0 \u0026amp;\u0026amp; nums[j] % 2 == 0) j--; if(i \u0026lt; j) swap(nums[i], nums[j]); } return nums; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-21%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/","summary":"//输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。 // // // // 示例： // // 输","title":"[剑指 Offer 21]调整数组顺序使奇数位于偶数前面"},{"content":"//请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串\u0026#34;+100\u0026#34;、\u0026#34;5e2\u0026#34;、\u0026#34;-123\u0026#34;、\u0026#34;3.1416\u0026#34;、\u0026#34;-1E-16\u0026#34;、\u0026#34;012 //3\u0026#34;都表示数值，但\u0026#34;12e\u0026#34;、\u0026#34;1a3.14\u0026#34;、\u0026#34;1.2.3\u0026#34;、\u0026#34;+-5\u0026#34;及\u0026#34;12e+5.4\u0026#34;都不是。 // // // Related Topics 数学 // 👍 148 👎 0 /* * 剑指 Offer 20 表示数值的字符串 * 2021-02-18 11:33:50 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /* 先去除行首和行尾空格； 行首如果有一个正负号，直接忽略； 如果字符串为空或只有一个\u0026#39;.\u0026#39;，则不是一个合法数； 循环整个字符串，去掉以下几种情况： (1) \u0026#39;.\u0026#39;或\u0026#39;e\u0026#39;多于1个; (2) \u0026#39;.\u0026#39;在\u0026#39;e\u0026#39;后面出现； (3) \u0026#39;e\u0026#39;后面或前面为空，或者\u0026#39;e\u0026#39;前面紧跟着\u0026#39;.\u0026#39;； (4) \u0026#39;e\u0026#39;后面紧跟着正负号，但正负号后面为空； 剩下的情况都合法； */ class Solution { public: bool isNumber(string s) { int i = 0; while (i \u0026lt; s.size() \u0026amp;\u0026amp; s[i] == \u0026#39; \u0026#39;) i ++ ; int j = s.size() - 1; while (j \u0026gt;= 0 \u0026amp;\u0026amp; s[j] == \u0026#39; \u0026#39;) j -- ; if (i \u0026gt; j) return false; s = s.substr(i, j - i + 1); if (s[0] == \u0026#39;-\u0026#39; || s[0] == \u0026#39;+\u0026#39;) s = s.substr(1); if (s.empty() || s[0] == \u0026#39;.\u0026#39; \u0026amp;\u0026amp; s.size() == 1) return false; int dot = 0, e = 0; for (int i = 0; i \u0026lt; s.size(); i ++ ) { if (s[i] \u0026gt;= \u0026#39;0\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;9\u0026#39;); else if (s[i] == \u0026#39;.\u0026#39;) { dot ++ ; if (e || dot \u0026gt; 1) return false; } else if (s[i] == \u0026#39;e\u0026#39; || s[i] == \u0026#39;E\u0026#39;) { e ++ ; if (i + 1 == s.size() || !i || e \u0026gt; 1 || i == 1 \u0026amp;\u0026amp; s[0] == \u0026#39;.\u0026#39;) return false; if (s[i + 1] == \u0026#39;+\u0026#39; || s[i + 1] == \u0026#39;-\u0026#39;) { if (i + 2 == s.size()) return false; i ++ ; } } else return false; } return true; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-20%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","summary":"//请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串\u0026#34;+100\u0026#34;、\u0026#34;5e2\u0026#34;、\u0026#3","title":"[剑指 Offer 20]表示数值的字符串"},{"content":"//请实现一个函数用来匹配包含\u0026#39;. \u0026#39;和\u0026#39;*\u0026#39;的正则表达式。模式中的字符\u0026#39;.\u0026#39;表示任意一个字符，而\u0026#39;*\u0026#39;表示它前面的字符可以出现任意次（含0次）。在本题中，匹配 //是指字符串的所有字符匹配整个模式。例如，字符串\u0026#34;aaa\u0026#34;与模式\u0026#34;a.a\u0026#34;和\u0026#34;ab*ac*a\u0026#34;匹配，但与\u0026#34;aa.a\u0026#34;和\u0026#34;ab*a\u0026#34;均不匹配。 // // 示例 1: // // 输入: //s = \u0026#34;aa\u0026#34; //p = \u0026#34;a\u0026#34; //输出: false //解释: \u0026#34;a\u0026#34; 无法匹配 \u0026#34;aa\u0026#34; 整个字符串。 // // // 示例 2: // // 输入: //s = \u0026#34;aa\u0026#34; //p = \u0026#34;a*\u0026#34; //输出: true //解释: 因为 \u0026#39;*\u0026#39; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 \u0026#39;a\u0026#39;。因此，字符串 \u0026#34;aa\u0026#34; 可被视为 \u0026#39;a\u0026#39; 重复了一次。 // // // 示例 3: // // 输入: //s = \u0026#34;ab\u0026#34; //p = \u0026#34;.*\u0026#34; //输出: true //解释: \u0026#34;.*\u0026#34; 表示可匹配零个或多个（\u0026#39;*\u0026#39;）任意字符（\u0026#39;.\u0026#39;）。 // // // 示例 4: // // 输入: //s = \u0026#34;aab\u0026#34; //p = \u0026#34;c*a*b\u0026#34; //输出: true //解释: 因为 \u0026#39;*\u0026#39; 表示零个或多个，这里 \u0026#39;c\u0026#39; 为 0 个, \u0026#39;a\u0026#39; 被重复一次。因此可以匹配字符串 \u0026#34;aab\u0026#34;。 // // // 示例 5: // // 输入: //s = \u0026#34;mississippi\u0026#34; //p = \u0026#34;mis*is*p*.\u0026#34; //输出: false // // // s 可能为空，且只包含从 a-z 的小写字母。 // p 可能为空，且只包含从 a-z 的小写字母以及字符 . 和 *，无连续的 \u0026#39;*\u0026#39;。 // // // 注意：本题与主站 10 题相同：https://leetcode-cn.com/problems/regular-expression-matching/ // // Related Topics 动态规划 // 👍 158 👎 0 /* * 剑指 Offer 19 正则表达式匹配 * 2021-02-18 11:32:54 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: bool isMatch(string s, string p) { int m = s.size(); int n = p.size(); vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; dp(m+1, vector\u0026lt;bool\u0026gt;(n + 1, false)); dp[0][0] = true; // dp[i][j] = dp[i-1][j-1] if(p[j-1] != \u0026#39;*\u0026#39; \u0026amp;\u0026amp; s[i-1] == p[j-1] || p[j-1] == \u0026#39;.\u0026#39;) // dp[i][j] = dp[i-1][j] if(p[j-1] == \u0026#39;*\u0026#39; \u0026amp;\u0026amp; (s[i-1] == p[j-2] || p[j-2] == \u0026#39;.\u0026#39;) // dp[i][j] == dp[i][j-2] if(p[i-1] == \u0026#39;*\u0026#39; and repeat 0 times) for(int i = 0;i \u0026lt;= m;i++){ for(int j = 1;j \u0026lt;= n;j++){ if(j \u0026gt; 1 \u0026amp;\u0026amp; p[j-1] == \u0026#39;*\u0026#39;){ bool a = dp[i][j-2]; bool b = i \u0026gt; 0 \u0026amp;\u0026amp; dp[i-1][j] \u0026amp;\u0026amp; (s[i-1] == p[j-2] || p[j-2] == \u0026#39;.\u0026#39;); dp[i][j] = a || b; }else{ dp[i][j] = i \u0026gt; 0 \u0026amp;\u0026amp; dp[i-1][j-1] \u0026amp;\u0026amp; (s[i-1] == p[j-1] || p[j-1] == \u0026#39;.\u0026#39;); } } } return dp[m][n]; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-19%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/","summary":"//请实现一个函数用来匹配包含\u0026#39;. \u0026#39;和\u0026#39;*\u0026#39;的正则表达式。模式中的字符\u0026#39;.\u0026#39;表示任意一个字符","title":"[剑指 Offer 19]正则表达式匹配"},{"content":"//给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 // // 返回删除后的链表的头节点。 // // 注意：此题对比原题有改动 // // 示例 1: // // 输入: head = [4,5,1,9], val = 5 //输出: [4,1,9] //解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -\u0026gt; 1 -\u0026gt; 9. // // // 示例 2: // // 输入: head = [4,5,1,9], val = 1 //输出: [4,5,9] //解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -\u0026gt; 5 -\u0026gt; 9. // // // // // 说明： // // // 题目保证链表中节点的值互不相同 // 若使用 C 或 C++ 语言，你不需要 free 或 delete 被删除的节点 // // Related Topics 链表 // 👍 93 👎 0 /* * 剑指 Offer 18 删除链表的节点 * 2021-02-18 11:32:41 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode* deleteNode(ListNode* head, int val) { ListNode dummy(-1); dummy.next = head; ListNode *p = \u0026amp;dummy; ListNode *cur = p; ListNode *pre = head; while(pre){ if(pre-\u0026gt;val == val){ cur-\u0026gt;next = pre-\u0026gt;next; return p-\u0026gt;next; }else{ pre = pre-\u0026gt;next; cur = cur-\u0026gt;next; } } return p-\u0026gt;next; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-18%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/","summary":"//给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。 // // 返回删除后的链表的头节点。 // // 注意：此题对比原题有改动 // // 示例 1:","title":"[剑指 Offer 18]删除链表的节点"},{"content":"//输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 // // 示例 1: // // 输入: n = 1 //输出: [1,2,3,4,5,6,7,8,9] // // // // // 说明： // // // 用返回一个整数列表来代替打印 // n 为正整数 // // Related Topics 数学 // 👍 82 👎 0 /* * 剑指 Offer 17 打印从1到最大的n位数 * 2021-02-18 11:32:29 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector\u0026lt;int\u0026gt; printNumbers(int n) { vector\u0026lt;int\u0026gt; ans; int pos = 1; for(int i = 1;i \u0026lt;= n;i++) pos *= 10; for(int i = 1;i \u0026lt; pos;i++) ans.push_back(i); return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-17%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/","summary":"//输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。 // // 示例 1: // // 输入: n = 1 //","title":"[剑指 Offer 17]打印从1到最大的n位数"},{"content":"//实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数 //问题。 // // // // 示例 1: // // 输入: 2.00000, 10 //输出: 1024.00000 // // // 示例 2: // // 输入: 2.10000, 3 //输出: 9.26100 // // // 示例 3: // // 输入: 2.00000, -2 //输出: 0.25000 //解释: 2-2 = 1/22 = 1/4 = 0.25 // // // // 说明: // // // -100.0 \u0026lt; x \u0026lt; 100.0 // n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 // // // 注意：本题与主站 50 题相同：https://leetcode-cn.com/problems/powx-n/ // Related Topics 递归 // 👍 118 👎 0 /* * 剑指 Offer 16 数值的整数次方 * 2021-02-18 11:32:22 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: double myPow(double x, int n) { double ans = 1; long long b = abs(n); while(b){ if(b \u0026amp; 1) ans = ans * x; x = x * x; b \u0026gt;\u0026gt;= 1; } if(n \u0026lt; 0) ans = 1 / ans; return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-16%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/","summary":"//实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数 //问题。 // // // // 示例","title":"[剑指 Offer 16]数值的整数次方"},{"content":"//请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 //9，则该函数输出 2。 // // // // 示例 1： // // //输入：00000000000000000000000000001011 //输出：3 //解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 \u0026#39;1\u0026#39;。 // // // 示例 2： // // //输入：00000000000000000000000010000000 //输出：1 //解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 \u0026#39;1\u0026#39;。 // // // 示例 3： // // //输入：11111111111111111111111111111101 //输出：31 //解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 \u0026#39;1\u0026#39;。 // // // // 提示： // // // 输入必须是长度为 32 的 二进制串 。 // // // // // 注意：本题与主站 191 题相同：https://leetcode-cn.com/problems/number-of-1-bits/ // Related Topics 位运算 // 👍 82 👎 0 /* * 剑指 Offer 15 二进制中1的个数 * 2021-02-18 11:32:09 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int hammingWeight(uint32_t n) { int ans = 0; for(int i = 31;i \u0026gt;= 0;i--){ ans += (n \u0026amp; 1); n \u0026gt;\u0026gt;= 1; } return ans; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-15%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/","summary":"//请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输","title":"[剑指 Offer 15]二进制中1的个数"},{"content":"//给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n\u0026gt;1并且m\u0026gt;1），每段绳子的长度记为 k[0],k[1]...k[m - 1] // 。请问 k[0]*k[1]*...*k[m - 1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘 //积是18。 // // 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 // // // // 示例 1： // // 输入: 2 //输出: 1 //解释: 2 = 1 + 1, 1 × 1 = 1 // // 示例 2: // // 输入: 10 //输出: 36 //解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 // // // // 提示： // // // 2 \u0026lt;= n \u0026lt;= 1000 // // // 注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/ // Related Topics 数学 动态规划 // 👍 68 👎 0 /* * 剑指 Offer 14- II 剪绳子 II * 2021-02-18 11:31:50 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int cuttingRope(int length) { if(length \u0026lt; 2) return 0; // if length \u0026gt; 6 result(length) = result(length - 3) * 3; if(length == 2) return 1; if(length == 3) return 2; if(length == 4) return 4; int numOf3 = length / 3; int numOf2 = 0; if (length % 3 == 1) { numOf3--; numOf2 = 2; } if(length % 3 == 2){ numOf2 = 1; } return (long long)qmi(2, numOf2) * qmi(3, numOf3) % mod; } int mod = 1e9 + 7; int qmi(int a, int b){ int result = 1 % mod; while(b){ if(b \u0026amp; 1) result = (long long) result * a % mod; a = (long long) a * a % mod; b \u0026gt;\u0026gt;= 1; } return result; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-14-ii%E5%89%AA%E7%BB%B3%E5%AD%90-ii/","summary":"//给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n\u0026gt;1并且m\u0026gt;1），每段绳子的长度记为 k[0],k[1]...k[m - 1] // 。请问 k[0]*k[1]*...*k[m -","title":"[剑指 Offer 14- II]剪绳子 II"},{"content":"//给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n\u0026gt;1并且m\u0026gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。 //请问 k[0]*k[1]*...*k[m-1] 可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18 //。 // // 示例 1： // // 输入: 2 //输出: 1 //解释: 2 = 1 + 1, 1 × 1 = 1 // // 示例 2: // // 输入: 10 //输出: 36 //解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36 // // 提示： // // // 2 \u0026lt;= n \u0026lt;= 58 // // // 注意：本题与主站 343 题相同：https://leetcode-cn.com/problems/integer-break/ // Related Topics 数学 动态规划 // 👍 157 👎 0 /* * 剑指 Offer 14- I 剪绳子 * 2021-02-18 11:31:30 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int cuttingRope(int length) { if(length \u0026gt; 58 || length \u0026lt; 2) return 0; // if length \u0026gt; 6 result(length) = result(length - 3) * 3; if(length == 2) return 1; if(length == 3) return 2; if(length == 4) return 4; if(length == 5) return 6; if(length == 6) return 9; return cuttingRope(length-3) * 3; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-14-i%E5%89%AA%E7%BB%B3%E5%AD%90/","summary":"//给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n\u0026gt;1并且m\u0026gt;1），每段绳子的长度记为 k[0],k[1]...k[m-1] 。 //请问 k[0]*k[1]*...*k[m-1] 可能","title":"[剑指 Offer 14- I]剪绳子"},{"content":"//地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一 //格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但 //它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？ // // // // 示例 1： // // 输入：m = 2, n = 3, k = 1 //输出：3 // // // 示例 2： // // 输入：m = 3, n = 1, k = 0 //输出：1 // // // 提示： // // // 1 \u0026lt;= n,m \u0026lt;= 100 // 0 \u0026lt;= k \u0026lt;= 20 // // 👍 214 👎 0 /* * 剑指 Offer 13 机器人的运动范围 * 2021-02-18 11:31:20 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int calc(int x, int y){ int res = 0; while(x) res += x % 10, x /= 10; while(y) res += y % 10, y /= 10; return res; } int m, n, k; int movingCount(int _m, int _n, int _k) { result = 0; m = _m, n = _n, k = _k; vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt; visited(m, vector\u0026lt;bool\u0026gt;(n, false)); dfs(0, 0, visited); return result; } int result; int dx[4] = {-1, 0, 1, 0}; int dy[4] = {0, 1, 0, -1}; void dfs(int x, int y, vector\u0026lt;vector\u0026lt;bool\u0026gt;\u0026gt;\u0026amp; visited){ if(visited[x][y]) return ; if(calc(x, y) \u0026gt; k){ visited[x][y] = true; return ; } result ++; visited[x][y] = true; for(int i = 0;i \u0026lt; 4;i++){ int a = x + dx[i], b = y + dy[i]; if(a \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; m \u0026amp;\u0026amp; b \u0026lt; n){ dfs(a, b, visited); } } } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-13%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/","summary":"//地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一 //格（不能移动到方格外","title":"[剑指 Offer 13]机器人的运动范围"},{"content":"//请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果 //一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。 // // [[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;e\u0026#34;], //[\u0026#34;s\u0026#34;,\u0026#34;f\u0026#34;,\u0026#34;c\u0026#34;,\u0026#34;s\u0026#34;], //[\u0026#34;a\u0026#34;,\u0026#34;d\u0026#34;,\u0026#34;e\u0026#34;,\u0026#34;e\u0026#34;]] // // 但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。 // // // // 示例 1： // // //输入：board = [[\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;E\u0026#34;],[\u0026#34;S\u0026#34;,\u0026#34;F\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;S\u0026#34;],[\u0026#34;A\u0026#34;,\u0026#34;D\u0026#34;,\u0026#34;E\u0026#34;,\u0026#34;E\u0026#34;]], word = \u0026#34;AB //CCED\u0026#34; //输出：true // // // 示例 2： // // //输入：board = [[\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;],[\u0026#34;c\u0026#34;,\u0026#34;d\u0026#34;]], word = \u0026#34;abcd\u0026#34; //输出：false // // // // // 提示： // // // 1 \u0026lt;= board.length \u0026lt;= 200 // 1 \u0026lt;= board[i].length \u0026lt;= 200 // // // 注意：本题与主站 79 题相同：https://leetcode-cn.com/problems/word-search/ // Related Topics 深度优先搜索 // 👍 242 👎 0 /* * 剑指 Offer 12 矩阵中的路径 * 2021-02-18 11:30:56 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: bool exist(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string\u0026amp; word) { for(int i = 0;i \u0026lt; board.size();i++){ for(int j = 0;j \u0026lt; board[0].size();j++){ if(board[i][j] == word[0]){ if(dfs(board, word, 0, i, j)) return true; } } } return false; } int dx[4] = {-1, 0, 1, 0}; int dy[4] = {0, 1, 0, -1}; bool dfs(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; board, string\u0026amp; word,int len, int x, int y){ if(len == word.size() - 1 \u0026amp;\u0026amp; board[x][y] == word[len]) return true; if(board[x][y] != word[len]) return false; char temp = board[x][y]; board[x][y] = \u0026#39;@\u0026#39;; for(int i = 0;i \u0026lt; 4;i++){ int a = x + dx[i], b = y + dy[i]; if(a \u0026gt;= 0 \u0026amp;\u0026amp; a \u0026lt; board.size() \u0026amp;\u0026amp; b \u0026gt;= 0 \u0026amp;\u0026amp; b \u0026lt; board[0].size() \u0026amp;\u0026amp; board[a][b] != \u0026#39;@\u0026#39;) if(dfs(board, word, len+1, a, b)) return true; } board[x][y] = temp; return false; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-12%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/","summary":"//请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、","title":"[剑指 Offer 12]矩阵中的路径"},{"content":"//把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2 //] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。 // // 示例 1： // // 输入：[3,4,5,1,2] //输出：1 // // // 示例 2： // // 输入：[2,2,2,0,1] //输出：0 // // // 注意：本题与主站 154 题相同：https://leetcode-cn.com/problems/find-minimum-in-rotated-sor //ted-array-ii/ // Related Topics 二分查找 // 👍 230 👎 0 /* * 剑指 Offer 11 旋转数组的最小数字 * 2021-02-18 11:30:29 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int minArray(vector\u0026lt;int\u0026gt;\u0026amp; numbers) { int k = numbers.size() - 1; while(k \u0026gt; 0 \u0026amp;\u0026amp; numbers[k] == numbers[0]) k--; // 去尾 if(numbers[k] \u0026gt;= numbers[0]) return numbers[0]; int left = 0, right = k; while(left \u0026lt; right){ // 二分 int mid = (left + right) \u0026gt;\u0026gt; 1; if(numbers[mid] \u0026lt; numbers[0]) right = mid; else left = mid + 1; } return numbers[right]; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-11%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/","summary":"//把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 [3,4,5,1,2","title":"[剑指 Offer 11]旋转数组的最小数字"},{"content":"//一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 // // 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 // // 示例 1： // // 输入：n = 2 //输出：2 // // // 示例 2： // // 输入：n = 7 //输出：21 // // // 示例 3： // // 输入：n = 0 //输出：1 // // 提示： // // // 0 \u0026lt;= n \u0026lt;= 100 // // // 注意：本题与主站 70 题相同：https://leetcode-cn.com/problems/climbing-stairs/ // // // Related Topics 递归 // 👍 119 👎 0 /* * 剑指 Offer 10- II 青蛙跳台阶问题 * 2021-02-18 11:30:15 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int mod = 1e9 + 7; int numWays(int n) { if(n == 0) return 1; if(n == 1) return 1; if(n == 2) return 2; int a = 1, b = 2; int temp; for(int i = 3;i \u0026lt;= n;i++){ temp = b % mod ; b = (a + b) % mod; a = temp; } return b; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-10-ii%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/","summary":"//一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 // // 答案需要取模 1e9+7（1000000","title":"[剑指 Offer 10- II]青蛙跳台阶问题"},{"content":"//写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下： // // //F(0) = 0, F(1) = 1 //F(N) = F(N - 1) + F(N - 2), 其中 N \u0026gt; 1. // // 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。 // // 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 // // // // 示例 1： // // //输入：n = 2 //输出：1 // // // 示例 2： // // //输入：n = 5 //输出：5 // // // // // 提示： // // // 0 \u0026lt;= n \u0026lt;= 100 // // Related Topics 递归 // 👍 102 👎 0 /* * 剑指 Offer 10- I 斐波那契数列 * 2021-02-18 11:30:00 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int fib(int n) { if( n == 0) return 0; if( n == 1) return 1; if( n == 2) return 1; int a = 1, b = 1; int temp; for(int i = 3;i \u0026lt;= n;i++){ temp = b % (1000000007); b = (a + b) % (1000000007); a = temp; } return b; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-10-i%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/","summary":"//写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下： // // //F(0) = 0, F(1) = 1 //F(N) = F(N - 1) + F(N -","title":"[剑指 Offer 10- I]斐波那契数列"},{"content":"//用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的 //功能。(若队列中没有元素，deleteHead 操作返回 -1 ) // // // // 示例 1： // // 输入： //[\u0026#34;CQueue\u0026#34;,\u0026#34;appendTail\u0026#34;,\u0026#34;deleteHead\u0026#34;,\u0026#34;deleteHead\u0026#34;] //[[],[3],[],[]] //输出：[null,null,3,-1] // // // 示例 2： // // 输入： //[\u0026#34;CQueue\u0026#34;,\u0026#34;deleteHead\u0026#34;,\u0026#34;appendTail\u0026#34;,\u0026#34;appendTail\u0026#34;,\u0026#34;deleteHead\u0026#34;,\u0026#34;deleteHead\u0026#34;] //[[],[],[5],[2],[],[]] //输出：[null,-1,null,null,5,2] // // // 提示： // // // 1 \u0026lt;= values \u0026lt;= 10000 // 最多会对 appendTail、deleteHead 进行 10000 次调用 // // Related Topics 栈 设计 // 👍 177 👎 0 /* * 剑指 Offer 09 用两个栈实现队列 * 2021-02-18 11:29:45 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class CQueue { public: stack\u0026lt;int\u0026gt; stk; stack\u0026lt;int\u0026gt; cache; CQueue() { } void cp(stack\u0026lt;int\u0026gt;\u0026amp; a, stack\u0026lt;int\u0026gt;\u0026amp; b){ while(a.size()) b.push(a.top()),a.pop(); } void appendTail(int value) { stk.push(value); } int deleteHead() { if(cache.empty() \u0026amp;\u0026amp; stk.empty()) return -1; if(!cache.empty()){ int result = cache.top(); cache.pop(); return result; }else{ cp(stk, cache); int result = cache.top(); cache.pop(); return result; } } }; /** * Your CQueue object will be instantiated and called as such: * CQueue* obj = new CQueue(); * obj-\u0026gt;appendTail(value); * int param_2 = obj-\u0026gt;deleteHead(); */ //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-09%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/","summary":"//用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的 //功能。(若队列中没有","title":"[剑指 Offer 09]用两个栈实现队列"},{"content":"//输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 // // // // 例如，给出 // // 前序遍历 preorder = [3,9,20,15,7] //中序遍历 inorder = [9,3,15,20,7] // // 返回如下的二叉树： // // 3 // / \\ // 9 20 // / \\ // 15 7 // // // // 限制： // // 0 \u0026lt;= 节点个数 \u0026lt;= 5000 // // // // 注意：本题与主站 105 题重复：https://leetcode-cn.com/problems/construct-binary-tree-from- //preorder-and-inorder-traversal/ // Related Topics 树 递归 // 👍 318 👎 0 /* * 剑指 Offer 07 重建二叉树 * 2021-02-18 11:29:29 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: unordered_map\u0026lt;int, int\u0026gt; mp; TreeNode* buildTree(vector\u0026lt;int\u0026gt;\u0026amp; preorder, vector\u0026lt;int\u0026gt;\u0026amp; inorder) { int m = preorder.size(); int n = inorder.size(); if(m != n) return nullptr; for(int i = 0;i \u0026lt; inorder.size();i++) mp[inorder[i]] = i; return build(preorder, 0, m-1, inorder, 0, n-1); } TreeNode* build(vector\u0026lt;int\u0026gt;\u0026amp; pre, int pl, int pr, vector\u0026lt;int\u0026gt;\u0026amp; ino, int il, int ir){ if(pl \u0026gt; pr) return nullptr; TreeNode *root = new TreeNode(pre[pl]); int pos = mp[pre[pl]]; root-\u0026gt;left = build(pre, pl + 1, pl + pos - il, ino, il, pos -1); root-\u0026gt;right = build(pre, pl + pos -il + 1, pr, ino, pos + 1, ir); return root; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-07%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/","summary":"//输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。 // // // // 例如，给出 // // 前序","title":"[剑指 Offer 07]重建二叉树"},{"content":"//输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 // // // // 示例 1： // // 输入：head = [1,3,2] //输出：[2,3,1] // // // // 限制： // // 0 \u0026lt;= 链表长度 \u0026lt;= 10000 // Related Topics 链表 // 👍 100 👎 0 /* * 剑指 Offer 06 从尾到头打印链表 * 2021-02-18 11:29:03 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) /** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: vector\u0026lt;int\u0026gt; reversePrint(ListNode* head) { vector\u0026lt;int\u0026gt; ans; ListNode* p = head; while(p){ ans.push_back(p-\u0026gt;val); p = p-\u0026gt;next; } return vector\u0026lt;int\u0026gt;(ans.rbegin(), ans.rend()); } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-06%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/","summary":"//输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。 // // // // 示例 1： // // 输入：head = [1,3,2] //输出：[2,3,1] // // //","title":"[剑指 Offer 06]从尾到头打印链表"},{"content":"//请实现一个函数，把字符串 s 中的每个空格替换成\u0026#34;%20\u0026#34;。 // // // // 示例 1： // // 输入：s = \u0026#34;We are happy.\u0026#34; //输出：\u0026#34;We%20are%20happy.\u0026#34; // // // // 限制： // // 0 \u0026lt;= s 的长度 \u0026lt;= 10000 // 👍 71 👎 0 /* * 剑指 Offer 05 替换空格 * 2021-02-18 11:28:56 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: string replaceSpace(string s) { string res; for(int i = 0;i \u0026lt; s.size();i++) if(s[i] == \u0026#39; \u0026#39;) res += \u0026#34;%20\u0026#34;; else res += s[i]; return res; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-05%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/","summary":"//请实现一个函数，把字符串 s 中的每个空格替换成\u0026#34;%20\u0026#34;。 // // // // 示例 1： // // 输入：s = \u0026#34;We are happy.\u0026#34; //输出：\u0026#34;We%2","title":"[剑指 Offer 05]替换空格"},{"content":"//在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个 //整数，判断数组中是否含有该整数。 // // // // 示例: // // 现有矩阵 matrix 如下： // // //[ // [1, 4, 7, 11, 15], // [2, 5, 8, 12, 19], // [3, 6, 9, 16, 22], // [10, 13, 14, 17, 24], // [18, 21, 23, 26, 30] //] // // // 给定 target = 5，返回 true。 // // 给定 target = 20，返回 false。 // // // // 限制： // // 0 \u0026lt;= n \u0026lt;= 1000 // // 0 \u0026lt;= m \u0026lt;= 1000 // // // // 注意：本题与主站 240 题相同：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/ // Related Topics 数组 双指针 // 👍 226 👎 0 /* * 剑指 Offer 04 二维数组中的查找 * 2021-02-18 11:28:36 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: bool findNumberIn2DArray(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix, int target) { int n = matrix.size(); if(!n) return false; int m = matrix[0].size(); if(!m) return false; int i = 0, j = m - 1; while(i \u0026lt; n \u0026amp;\u0026amp; j \u0026gt;= 0){ if(matrix[i][j] == target) return true; else if(matrix[i][j] \u0026lt; target) i++; else j--; } return false; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-04%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/","summary":"//在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二","title":"[剑指 Offer 04]二维数组中的查找"},{"content":"//找出数组中重复的数字。 // // //在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请 //找出数组中任意一个重复的数字。 // // 示例 1： // // 输入： //[2, 3, 1, 0, 2, 5, 3] //输出：2 或 3 // // // // // 限制： // // 2 \u0026lt;= n \u0026lt;= 100000 // Related Topics 数组 哈希表 // 👍 271 👎 0 /* * 剑指 Offer 03 数组中重复的数字 * 2021-02-18 11:26:59 * @author oxygenbytes */ #include \u0026#34;leetcode.h\u0026#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int findRepeatNumber(vector\u0026lt;int\u0026gt;\u0026amp; nums) { int i = 0; while(i \u0026lt; nums.size()){ if(nums[i] == i){ i++; continue; } if(nums[i] == nums[nums[i]]) return nums[i]; swap(nums[i], nums[nums[i]]); } return -1; } }; //leetcode submit region end(Prohibit modification and deletion) ","permalink":"https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-03%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/","summary":"//找出数组中重复的数字。 // // //在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了","title":"[剑指 Offer 03]数组中重复的数字"},{"content":"一、解决的问题 由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。\nDocker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其他机器中。\n二、与虚拟机的比较 虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。\n启动速度 启动虚拟机需要启动虚拟机的操作系统，再启动应用，这个过程非常慢；\n而启动 Docker 相当于启动宿主操作系统上的一个进程。\n占用资源 虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU，一台机器只能开启几十个的虚拟机。\n而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。\n三、优势 除了启动速度快以及占用资源少之外，Docker 具有以下优势：\n更容易迁移 提供一致性的运行环境，可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。\n更容易维护 使用分层技术和镜像，使得应用可以更容易复用重复部分。复用程度越高，维护工作也越容易。\n更容易扩展 可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。\n四、使用场景 持续集成 持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。\nDocker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。\n提供可伸缩的云服务 根据应用的负载情况，可以很容易地增加或者减少 Docker。\n搭建微服务架构 Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。\n五、镜像与容器 镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。\n镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。\n构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。\nUbuntu上docker的安装和配置 脚本如下：\n#!/bin/sh # Shell script to add docker-ce to Deepin Linux repositories # Remove old docker sudo apt-get remove -y docker docker-engine docker.io containerd runc # Install dependencies sudo apt-get install -y apt-transport-https ca-certificates curl gnupg2 software-properties-common # Add GPG and fingerprint curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add - sudo apt-key fingerprint 0EBFCD88 # Add debian repository in deepin sources list printf \u0026#39;deb [arch=amd64] https://download.docker.com/linux/debian buster stable\\n\u0026#39; \\ | sudo tee /etc/apt/sources.list.d/docker-ce.list # Update packages and install sudo apt-get update -y sudo apt-get install -y docker-ce # Add current user to the docker users group (OPTIONAL) sudo usermod -aG docker $(whoami) sudo groupadd docker sudo gpasswd -a $USER docker newgrp docker docker ps sudo vim /etc/docker/daemon.json 编辑daemon.json文件并配置容器镜像\n{ \u0026#34;registry-mirrors\u0026#34;: [ \u0026#34;https://hub-mirror.c.163.com\u0026#34;, \u0026#34;https://mirror.baidubce.com\u0026#34; ] } ","permalink":"https://oxygenbytes.github.io/posts/linux/docker/","summary":"一、解决的问题 由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。 Docker 主要解决环境配置","title":"Docker 学习"},{"content":"Git 学习 主要记录一些git学习的笔记内容\ngit学习链接\ngit分支管理 新建分支 git checkout -b branchname 切换分支 git checkout branchname 查看分支 git branch 比如你现在在dev，克隆下来的是主分支(main)\n如果你要进行什么修改，可以建一个新的分之，比如按照今天的日期\ngit checkout -b 190721 git checkout 190721 # 这样就切换到了新分支 新建git仓库，并且推送到github # create a new repository on the command line github官方指导 git init # 仓库初始化，初始化对象是当前目录 git init newrepo # 初始化特定文件夹，并且在newrepo中出现一个.git目录 git add * # 将当前目录中所有文件纳入版本控制，提交到暂存区 git commit -m \u0026#34;first commit\u0026#34; # 提交到版本库 git remote add origin git@github.com:cogitates/Mynote.git # 连接远程仓库 git push -u origin master # 将本地的仓库推送到远程仓库 当系统重装后，如何连接git和github github官方参考链接\n先下载git\nsudo apt-get git # deepin sudo pacman -S git #manjaro 然后为本地 git 配置全局的 user 与 email 参数。\n$ git config ‐‐global user.name \u0026#34;your github account name\u0026#34; $ git config ‐‐global user.email \u0026#34;your github account email\u0026#34; 为了在后续操作中我们能将本地仓库的代码推送至 github 的仓库上,我们需要在本地生成 SSH 秘钥,并将公钥保存到 github 账户信息中,这样我们在本地提交的时候 github 就能通 过本地的私钥与公钥进行校验。\n$ ssh‐keygen ‐t rsa ‐C \u0026#34;your github account email\u0026#34; 复制当前主目录下~/.ssh/id_rsa.pub，只需要把公钥的内容提交给 github 。\n进入Github的个人setting 界面,选择 SSH and GPG keys ,点击 New SSH key ,在展开的窗口中填写密钥信息,title 可以随意，方便自己管理即可,key 那一栏则把刚刚生成的 id_rsa.pub 的内容复制进去。最后点击按钮添加。\n测试是否连接到github\nssh -T git@github.com 问题一\n$ ssh -vT git@github.com \u0026gt; ... \u0026gt; Agent admitted failure to sign using the key. \u0026gt; debug1: No more authentication methods to try. \u0026gt; Permission denied (publickey). 采取措施\n# star图片t the ssh-agent in the background $ eval \u0026#34;$(ssh-agent -s)\u0026#34; \u0026gt; Agent pid 59566 $ ssh-add \u0026gt; Enter passphrase for /home/you/.ssh/id_rsa: [tippy tap] \u0026gt; Identity added: /home/you/.ssh/id_rsa (/home/you/.ssh/id_rsa) 问题二\nermissions 0777 for \u0026#39;~/.ssh/id_rsa\u0026#39; are too open 采取措施\nchmod -R 700 id_rsa id_rsa.pub known_hosts passwd 版本回退 git reset --hard HEAD^回退到上一版本 git reset --hard HEAD^回退到上上版本 git reset --hard HEAD~100回退到上100个版本 git reset --hard 具体版本号回退到具体版本号 记录每一次命令：git reflog git checkout -- readme.txt： 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 ","permalink":"https://oxygenbytes.github.io/posts/linux/git/","summary":"Git 学习 主要记录一些git学习的笔记内容 git学习链接 git分支管理 新建分支 git checkout -b branchname 切换分支 git checkout branchname 查看分支 git branch 比如你现在在dev，克隆下来的是","title":"Git 学习"},{"content":"一、常用操作以及概念 快捷键 Tab：命令和文件名补全； Ctrl+C：中断正在运行的程序； Ctrl+D：结束键盘输入（End Of File，EOF） 求助 1. \u0026ndash;help 指令的基本用法与选项介绍。\n2. man man 是 manual 的缩写，将指令的具体信息显示出来。\n当执行man date时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下：\n代号 类型 1 用户在 shell 环境中可以操作的指令或者可执行文件 5 配置文件 8 系统管理员可以使用的管理指令 3. info info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以进行跳转。\n4. doc /usr/share/doc 存放着软件的一整套说明文件。\n关机 1. who 在关机前需要先使用 who 命令查看有没有其它用户在线。\n2. sync 为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘上，因此关机之前需要先进行 sync 同步操作。\n3. shutdown # shutdown [-krhc] 时间 [信息] -k ： 不会关机，只是发送警告信息，通知所有在线的用户 -r ： 将系统的服务停掉后就重新启动 -h ： 将系统的服务停掉后就立即关机 -c ： 取消已经在进行的 shutdown 指令内容 PATH 可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。\n/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin sudo sudo 允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令。\nVIM 三个模式 一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容； 编辑模式（Insert mode）：按下 \u0026ldquo;i\u0026rdquo; 等按键之后进入，可以对文本进行编辑； 指令列模式（Bottom-line mode）：按下 \u0026ldquo;:\u0026rdquo; 按键之后进入，用于保存退出等操作。 在指令列模式下，有以下命令用于离开或者保存文件。\n命令 作用 :w 写入磁盘 :w! 当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关 :q 离开 :q! 强制离开不保存 :wq 写入磁盘后离开 :wq! 强制写入磁盘后离开 二、磁盘 磁盘接口 1. IDE IDE（ATA）全称 Advanced Technology Attachment，接口速度最大为 133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代。\n2. SATA SATA 全称 Serial ATA，也就是使用串口的 ATA 接口，抗干扰性强，且对数据线的长度要求比 ATA 低很多，支持热插拔等功能。SATA-II 的接口速度为 300MiB/s，而新的 SATA-III 标准可达到 600MiB/s 的传输速度。SATA 的数据线也比 ATA 的细得多，有利于机箱内的空气流通，整理线材也比较方便。\n3. SCSI SCSI 全称是 Small Computer System Interface（小型机系统接口），经历多代的发展，从早期的 SCSI-II 到目前的 Ultra320 SCSI 以及 Fiber-Channel（光纤通道），接口型式也多种多样。SCSI 硬盘广为工作站级个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速 15000rpm 的高转速，且传输时 CPU 占用率较低，但是单价也比相同容量的 ATA 及 SATA 硬盘更加昂贵。\n4. SAS SAS（Serial Attached SCSI）是新一代的 SCSI 技术，和 SATA 硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb/s。此外也透过缩小连接线改善系统内部空间等。\n磁盘的文件名 Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下：\nIDE 磁盘：/dev/hd[a-d] SATA/SCSI/SAS 磁盘：/dev/sd[a-p] 其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关。\n三、分区 分区表 磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。\n1. MBR MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。\n分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其它扇区用记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。\nLinux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。\n2. GPT 不同的磁盘有不同的扇区大小，例如 512 bytes 和最新磁盘的 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小为 512 bytes。\nGPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。\nGPT 没有扩展分区概念，都是主分区，每个 LAB 可以分 4 个分区，因此总共可以分 4 * 32 = 128 个分区。\nMBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 233 TB = 8 ZB。\n开机检测程序 1. BIOS BIOS（Basic Input/Output System，基本输入输出系统），它是一个固件（嵌入在硬件中的软件），BIOS 程序存放在断电后内容不会丢失的只读内存中。\nBIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的主要开机记录（MBR），由主要开机记录（MBR）执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。\n主要开机记录（MBR）中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现了多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动开机管理程序时，就可以通过选单选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。\n安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉主要开机记录（MBR），而 Linux 可以选择将开机管理程序安装在主要开机记录（MBR）或者其它分区的启动扇区，并且可以设置开机管理程序的选单。\n2. UEFI BIOS 不可以读取 GPT 分区表，而 UEFI 可以。\n四、文件系统 分区与文件系统 对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。\n组成 最主要的几个组成部分如下：\ninode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号； block：记录文件的内容，文件太大时，会占用多个 block。 除此之外还包括：\nsuperblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等； block bitmap：记录 block 是否被使用的位域。 文件读取 对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中去查找文件内容所在的所有 block，然后把所有 block 的内容读出来。\n而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。\n磁盘碎片 指一个文件内容所在的 block 过于分散。\nblock 在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。\n大小 1KB 2KB 4KB 最大单一文件 16GB 256GB 2TB 最大文件系统 2TB 8TB 16TB 一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。\ninode inode 具体包含以下信息：\n权限 (read/write/excute)； 拥有者与群组 (owner/group)； 容量； 建立或状态改变的时间 (ctime)； 最近一次的读取时间 (atime)； 最近修改的时间 (mtime)； 定义文件特性的旗标 (flag)，如 SetUID\u0026hellip;； 该文件真正内容的指向 (pointer)。 inode 具有以下特点：\n每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)； 每个文件都仅会占用一个 inode。 inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用是指，让 inode 记录的引用 block 块记录引用信息。\n目录 建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。\n可以看出文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的 w 权限有关。\n日志 如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。\next3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。\n挂载 挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。\n目录配置 为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：\n/ (root, 根目录) /usr (unix software resource)：所有系统默认软件都会安装到这个目录； /var (variable)：存放系统或程 五、文件 文件属性 用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。\n使用 ls 查看一个文件时，会显示一个文件的信息，例如 drwxr-xr-x. 3 root root 17 May 6 00:14 .config，对这个信息的解释如下：\ndrwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段 3：链接数 root：文件拥有者 root：所属群组 17：文件大小 May 6 00:14：文件最后被修改的时间 .config：文件名 常见的文件类型及其含义有：\nd：目录 -：文件 l：链接文件 9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。\n文件时间有以下三种：\nmodification time (mtime)：文件的内容更新就会更新； status time (ctime)：文件的状态（权限、属性）更新就会更新； access time (atime)：读取文件时就会更新。 文件与目录的基本操作 1. ls 列出文件或者目录的信息，目录的信息就是其中包含的文件。\n# ls [-aAdfFhilnrRSt] file|dir -a ：列出全部的文件 -d ：仅列出目录本身 -l ：以长数据串行列出，包含文件的属性与权限等等数据 2. cd 更换当前目录。\ncd [相对路径或绝对路径] 3. mkdir 创建目录。\n# mkdir [-mp] 目录名称 -m ：配置目录权限 -p ：递归创建目录 4. rmdir 删除目录，目录必须为空。\nrmdir [-p] 目录名称 -p ：递归删除目录 5. touch 更新文件时间或者建立新文件。\n# touch [-acdmt] filename -a ： 更新 atime -c ： 更新 ctime，若该文件不存在则不建立新文件 -m ： 更新 mtime -d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=\u0026#34;日期或时间\u0026#34; -t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm] 6. cp 复制文件。\n如果源文件有两个以上，则目的文件一定要是目录才行。\ncp [-adfilprsu] source destination -a ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明 -d ：若来源文件为链接文件，则复制链接文件属性而非文件本身 -i ：若目标文件已经存在时，在覆盖前会先询问 -p ：连同文件的属性一起复制过去 -r ：递归持续复制 -u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制 --preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了 7. rm 删除文件。\n# rm [-fir] 文件或目录 -r ：递归删除 8. mv 移动文件。\n# mv [-fiu] source destination # mv [options] source1 source2 source3 .... directory -f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 修改权限 可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。\n# chmod [-R] xyz dirname/filename 示例：将 .bashrc 文件的权限修改为 -rwxr-xr\u0026ndash;。\n# chmod 754 .bashrc 也可以使用符号来设定权限。\n# chmod [ugoa] [+-=] [rwx] dirname/filename - u：拥有者 - g：所属群组 - o：其他人 - a：所有人 - +：添加权限 - -：移除权限 - =：设定权限 示例：为 .bashrc 文件的所有用户添加写权限。\n# chmod a+w .bashrc 文件默认权限 文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。 目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。 可以通过 umask 设置或者查看文件的默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r\u0026ndash;。\n目录的权限 文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。\n目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。\n链接 # ln [-sf] source_filename dist_filename -s ：默认是 hard link，加 -s 为 symbolic link -f ：如果目标文件存在时，先删除目标文件 1. 实体链接 在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。\n删除任意一个条目，文件还是存在，只要引用数量不为 0。\n有以下限制：不能跨越文件系统、不能对目录进行链接。\n# ln /etc/crontab . # ll -i /etc/crontab crontab 34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab 34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab 2. 符号链接 符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。\n当源文件被删除了，链接文件就打不开了。\n可以为目录建立链接。\n# ll -i /etc/crontab /root/crontab2 34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab 53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -\u0026gt; /etc/crontab 获取文件内容 1. cat 取得文件内容。\n# cat [-AbEnTv] filename -n ：打印出行号，连同空白行也会有行号，-b 不会 2. tac 是 cat 的反向操作，从最后一行开始打印。\n3. more 和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。\n4. less 和 more 类似，但是多了一个向前翻页的功能。\n5. head 取得文件前几行。\n# head [-n number] filename -n ：后面接数字，代表显示几行的意思 6. tail 是 head 的反向操作，只是取得是后几行。\n7. od 以字符或者十六进制的形式显示二进制文件。\n指令与文件搜索 1. which 指令搜索。\n# which [-a] command -a ：将所有指令列出，而不是只列第一个 2. whereis 文件搜索。速度比较快，因为它只搜索几个特定的目录。\n# whereis [-bmsu] dirname/filename 3. locate 文件搜索。可以用关键字或者正则表达式进行搜索。\nlocate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。\n# locate [-ir] keyword -r：正则表达式 4. find 文件搜索。可以使用文件的属性和权限进行搜索。\n# find [basedir] [option] example: find . -name \u0026#34;shadow*\u0026#34; ① 与时间有关的选项\n-mtime n ：列出在 n 天前的那一天修改过内容的文件 -mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件 -mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件 -newer file ： 列出比 file 更新的文件 +4、4 和 -4 的指示的时间范围如下：\n② 与文件拥有者和所属群组有关的选项\n-uid n -gid n -user name -group name -nouser ：搜索拥有者不存在 /etc/passwd 的文件 -nogroup：搜索所属群组不存在于 /etc/group 的文件 ③ 与文件权限和名称有关的选项\n-name filename -size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k -type TYPE -perm mode ：搜索权限等于 mode 的文件 -perm -mode ：搜索权限包含 mode 的文件 -perm /mode ：搜索权限包含任一 mode 的文件 六、压缩与打包 压缩文件名 Linux 底下有很多压缩文件名，常见的如下：\n扩展名 压缩程序 *.Z compress *.zip zip *.gz gzip *.bz2 bzip2 *.xz xz *.tar tar 程序打包的数据，没有经过压缩 *.tar.gz tar 程序打包的文件，经过 gzip 的压缩 *.tar.bz2 tar 程序打包的文件，经过 bzip2 的压缩 *.tar.xz tar 程序打包的文件，经过 xz 的压缩 压缩指令 1. gzip gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。\n经过 gzip 压缩过，源文件就不存在了。\n有 9 个不同的压缩等级可以使用。\n可以使用 zcat、zmore、zless 来读取压缩文件的内容。\n$ gzip [-cdtv#] filename -c ：将压缩的数据输出到屏幕上 -d ：解压缩 -t ：检验压缩文件是否出错 -v ：显示压缩比等信息 -# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6 2. bzip2 提供比 gzip 更高的压缩比。\n查看命令：bzcat、bzmore、bzless、bzgrep。\n$ bzip2 [-cdkzv#] filename -k ：保留源文件 3. xz 提供比 bzip2 更佳的压缩比。\n可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。\n查看命令：xzcat、xzmore、xzless、xzgrep。\n$ xz [-dtlkc#] filename 打包 压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gip、bzip2、xz 将打包文件进行压缩。\n$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename... ==打包压缩 $ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件] ==查看 $ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录] ==解压缩 -z ：使用 zip； -j ：使用 bzip2； -J ：使用 xz； -c ：新建打包文件； -t ：查看打包文件里面有哪些文件； -x ：解打包或解压缩的功能； -v ：在压缩/解压缩的过程中，显示正在处理的文件名； -f : filename：要处理的文件； -C 目录 ： 在特定目录解压缩。 使用方式 命令 打包压缩 tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 查 看 tar -jtv -f filename.tar.bz2 解压缩 tar -jxv -f filename.tar.bz2 -C 要解压缩的目录 七、Bash 可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。\n特性 命令历史：记录使用过的命令 命令与文件补全：快捷键：tab 命名别名：例如 lm 是 ls -al 的别名 shell scripts 通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件 变量操作 对一个变量赋值直接使用 =。\n对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；\n输出变量使用 echo 命令。\n$ x=abc $ echo $x $ echo ${x} 变量内容如果有空格，必须使用双引号或者单引号。\n双引号内的特殊字符可以保留原本特性，例如 x=\u0026ldquo;lang is $LANG\u0026rdquo;，则 x 的值为 lang is zh_TW.UTF-8； 单引号内的特殊字符就是特殊字符本身，例如 x=\u0026lsquo;lang is $LANG\u0026rsquo;，则 x 的值为 lang is $LANG。 可以使用 `指令` 或者 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。\n可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。\nBash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令：\n$ declare [-aixr] variable -a ： 定义为数组类型 -i ： 定义为整数类型 -x ： 定义为环境变量 -r ： 定义为 readonly 类型 使用 [ ] 来对数组进行索引操作：\n$ array[1]=a $ array[2]=b $ echo ${array[1]} 指令搜索顺序 以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ； 由别名找到该指令来执行； 由 Bash 内置的指令来执行； 按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。 数据流重定向 重定向指的是使用文件代替标准输入、标准输出和标准错误输出。\n1 代码 运算符 标准输入 (stdin) 0 \u0026lt; 或 \u0026laquo; 标准输出 (stdout) 1 \u0026gt; 或 \u0026raquo; 标准错误输出 (stderr) 2 2\u0026gt; 或 2\u0026raquo; 其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。\n可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。\n如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2\u0026gt;\u0026amp;1 表示将标准错误输出转换为标准输出。\n$ find /home -name .bashrc \u0026gt; list 2\u0026gt;\u0026amp;1 八、管道指令 管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。\n在命令之间使用 | 分隔各个管道命令。\n$ ls -al /etc | less 提取指令 cut 对数据进行切分，取出想要的部分。\n切分过程一行一行地进行。\n$ cut -d ：分隔符 -f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间 -c ：以字符为单位取出区间 示例 1：last 显示登入者的信息，取出用户名。\n$ last root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33) root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16) $ last | cut -d \u0026#39; \u0026#39; -f 1 示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。\n$ export declare -x HISTCONTROL=\u0026#34;ignoredups\u0026#34; declare -x HISTSIZE=\u0026#34;1000\u0026#34; declare -x HOME=\u0026#34;/home/dmtsai\u0026#34; declare -x HOSTNAME=\u0026#34;study.centos.vbird\u0026#34; .....(其他省略)..... $ export | cut -c 12- 排序指令 sort 用于排序。\n$ sort [-fbMnrtuk] [file or stdin] -f ：忽略大小写 -b ：忽略最前面的空格 -M ：以月份的名字来排序，例如 JAN，DEC -n ：使用数字 -r ：反向排序 -u ：相当于 unique，重复的内容只出现一次 -t ：分隔符，默认为 tab -k ：指定排序的区间 示例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。\n$ cat /etc/passwd | sort -t \u0026#39;:\u0026#39; -k 3 root❌0:0:root:/root:/bin/bash dmtsai❌1000:1000:dmtsai:/home/dmtsai:/bin/bash alex❌1001:1002::/home/alex:/bin/bash arod❌1002:1003::/home/arod:/bin/bash uniq 可以将重复的数据只取一个。\n$ uniq [-ic] -i ：忽略大小写 -c ：进行计数 示例：取得每个人的登录总次数\n$ last | cut -d \u0026#39; \u0026#39; -f 1 | sort | uniq -c 1 6 (unknown 47 dmtsai 4 reboot 7 root 1 wtmp 双向输出重定向 输出重定向会将输出内容重定向到文件中，而 tee 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。\n$ tee [-a] file 字符转换指令 tr 用来删除一行中的字符，或者对字符进行替换。\n$ tr [-ds] SET1 ... -d ： 删除行中 SET1 这个字符串 示例，将 last 输出的信息所有小写转换为大写。\n$ last | tr \u0026#39;[a-z]\u0026#39; \u0026#39;[A-Z]\u0026#39; col 将 tab 字符转为空格字符。\n$ col [-xb] -x ： 将 tab 键转换成对等的空格键 expand 将 tab 转换一定数量的空格，默认是 8 个。\n$ expand [-t] file -t ：tab 转为空格的数量 join 将有相同数据的那一行合并在一起。\n$ join [-ti12] file1 file2 -t ：分隔符，默认为空格 -i ：忽略大小写的差异 -1 ：第一个文件所用的比较字段 -2 ：第二个文件所用的比较字段 paste 直接将两行粘贴在一起。\n$ paste [-d] file1 file2 -d ：分隔符，默认为 tab 分区指令 split 将一个文件划分成多个文件。\n$ split [-bl] file PREFIX -b ：以大小来进行分区，可加单位，例如 b, k, m 等 -l ：以行数来进行分区。 - PREFIX ：分区文件的前导名称 九、正则表达式 grep g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。\n$ grep [-acinv] [--color=auto] 搜寻字符串 filename -c ： 统计个数 -i ： 忽略大小写 -n ： 输出行号 -v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行 --color=auto ：找到的关键字加颜色显示 示例：把含有 the 字符串的行提取出来（注意默认会有 \u0026ndash;color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串）\n$ grep -n \u0026#39;the\u0026#39; regular_express.txt 8:I can\u0026#39;t finish the test. 12:the symbol \u0026#39;*\u0026#39; is represented as start. 15:You are the best is mean you are the no. 1. 16:The world Happy is the same with \u0026#34;glad\u0026#34;. 18:google is the best tools for search keyword 因为 { 和 } 在 shell 是有特殊意义的，因此必须要使用转义字符进行转义。\n$ grep -n \u0026#39;go\\{2,5\\}g\u0026#39; regular_express.txt printf 用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。\n$ printf \u0026#39;%10s %5i %5i %5i %8.2f \\n\u0026#39; $(cat printf.txt) DmTsai 80 60 92 77.33 VBird 75 55 80 70.00 Ken 60 90 70 73.33 awk 是由 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。\nawk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。\n示例：取出最近五个登录用户的用户名和 IP\n$ last -n 5 dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22) dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12) dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14) dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15) $ last -n 5 | awk \u0026#39;{print $1 \u0026#34;\\t\u0026#34; $3}\u0026#39; 可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。\n$ awk \u0026#39;条件类型 1 {动作 1} 条件类型 2 {动作 2} ...\u0026#39; filename 示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。\n$ cat /etc/passwd | awk \u0026#39;BEGIN {FS=\u0026#34;:\u0026#34;} $3 \u0026lt; 10 {print $1 \u0026#34;\\t \u0026#34; $3}\u0026#39; root 0 bin 1 daemon 2 awk 变量：\n变量名称 代表意义 NF 每一行拥有的字段总数 NR 目前所处理的是第几行数据 FS 目前的分隔字符，默认是空格键 示例：显示正在处理的行号以及每一行有多少字段\n$ last -n 5 | awk \u0026#39;{print $1 \u0026#34;\\t lines: \u0026#34; NR \u0026#34;\\t columns: \u0026#34; NF}\u0026#39; dmtsai lines: 1 columns: 10 dmtsai lines: 2 columns: 10 dmtsai lines: 3 columns: 10 dmtsai lines: 4 columns: 10 dmtsai lines: 5 columns: 9 十、进程管理 查看进程 1. ps 查看某个时间点的进程信息\n示例一：查看自己的进程\n# ps -l 示例二：查看系统所有进程\n# ps aux 示例三：查看特定的进程\n# ps aux | grep threadx 2. pstree 查看进程树\n示例：查看所有进程树\n# pstree -A 3. top 实时显示进程信息\n示例：两秒钟刷新一次\n# top -d 2 4. netstat 查看占用端口的进程\n示例：查看特定端口的进程\n# netstat -anp | grep port 进程状态 状态 说明 R running or runnable (on run queue) D uninterruptible sleep (usually I/O) S interruptible sleep (waiting for an event to complete) Z zombie (terminated but not reaped by its parent) T stopped (either by a job control signal or because it is being traced) SIGCHLD 当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：\n得到 SIGCHLD 信号； waitpid() 或者 wait() 调用会返回。 其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。\n在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。\nwait() pid_t wait(int *status) 父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。\n如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。\n参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。\nwaitpid() pid_t waitpid(pid_t pid, int *status, int options) 作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。\npid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。\noptions 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。\n孤儿进程 一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。\n孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。\n由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。\n僵尸进程 一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。\n僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。\n系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。\n要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。\n参考资料 鸟哥. 鸟 哥 的 Linux 私 房 菜 基 础 篇 第 三 版[J]. 2009. Linux 平台上的软件包管理 Linux 之守护进程、僵死进程与孤儿进程 What is the difference between a symbolic link and a hard link? Linux process states GUID Partition Table 详解 wait 和 waitpid 函数 IDE、SATA、SCSI、SAS、FC、SSD 硬盘类型介绍 Akai IB-301S SCSI Interface for S2800,S3000 Parallel ATA ADATA XPG SX900 256GB SATA 3 SSD Review – Expanded Capacity and SandForce Driven Speed Decoding UCS Invicta – Part 1 硬盘 Difference between SAS and SATA BIOS File system design case studies Programming Project #4 FILE SYSTEM DESIGN github: https://github.com/sjsdfg/CS-Notes-PDF\n","permalink":"https://oxygenbytes.github.io/posts/linux/linux/","summary":"一、常用操作以及概念 快捷键 Tab：命令和文件名补全； Ctrl+C：中断正在运行的程序； Ctrl+D：结束键盘输入（End Of File，EOF）","title":"Linux 学习"},{"content":"二分算法 二分模板 二分模板一共有两个，分别适用于不同情况。\n版本1 当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。 C++ 代码模板：\nint bsearch_1(int l, int r) { while (l \u0026lt; r) { int mid = l + r \u0026gt;\u0026gt; 1; if (check(mid)) r = mid; else l = mid + 1; } return l; } 版本2 当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。 C++ 代码模板：\nint bsearch_2(int l, int r) { while (l \u0026lt; r) { int mid = l + r + 1 \u0026gt;\u0026gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } 使用心的 假设有一个总区间，经由我们的 check 函数判断后，可分成两部分， 若以o作 true，\u0026hellip;..作 false 示意较好识别\n如果我们的目标是下面这个v，使用模板 1\n................vooooooooo\n假设经由 check 划分后，整个区间的属性与目标v如下，则使用模板 2\noooooooov................\n模板1就是在满足chek()的区间内找到左边界，模板2在满足check()的区间内找到右边界。\n二分可以将求解类型的问题 转换为 判定型问题\n实数域上的二分算法 实数域上的二分较为简单，确定好需要的的精度 eps, 以 left + eps \u0026lt; right 为循环条件，每次根据在 mid 上根据判定选择 left = mid, right = mid 分支之一即可。\ndouble binary_search(double left, double right){ while(left + 1e-5 \u0026lt; right){ double mid = (left + right) / 2; if(check(mid)) left = mid; else right = mid; } return mid; } 参考 链接：https://www.acwing.com/blog/content/31/\n","permalink":"https://oxygenbytes.github.io/posts/algorithms/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/","summary":"二分算法 二分模板 二分模板一共有两个，分别适用于不同情况。 版本1 当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r","title":"二分算法"},{"content":"一、概览 Java 的 I/O 大概可以分成以下几类：\n磁盘操作：File 字节操作：InputStream 和 OutputStream 字符操作：Reader 和 Writer 对象操作：Serializable 网络操作：Socket 新的输入/输出：NIO 二、磁盘操作 File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。\n递归地列出一个目录下所有文件：\npublic static void listAllFiles(File dir) { if (dir == null || !dir.exists()) { return; } if (dir.isFile()) { System.out.println(dir.getName()); return; } for (File file : dir.listFiles()) { listAllFiles(file); } } 从 Java7 开始，可以使用 Paths 和 Files 代替 File。\n三、字节操作 实现文件复制 public static void copyFile(String src, String dist) throws IOException { FileInputStream in = new FileInputStream(src); FileOutputStream out = new FileOutputStream(dist); byte[] buffer = new byte[20 * 1024]; int cnt; // read() 最多读取 buffer.length 个字节 // 返回的是实际读取的个数 // 返回 -1 的时候表示读到 eof，即文件尾 while ((cnt = in.read(buffer, 0, buffer.length)) != -1) { out.write(buffer, 0, cnt); } in.close(); out.close(); } 装饰者模式 Java I/O 使用了装饰者模式来实现。以 InputStream 为例，\nInputStream 是抽象组件； FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作； FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。 实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。\nFileInputStream fileInputStream = new FileInputStream(filePath); BufferedInputStream bufferedInputStream = new BufferedInputStream(fileInputStream); DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。\n四、字符操作 编码与解码 编码就是把字符转换为字节，而解码是把字节重新组合成字符。\n如果编码和解码过程使用不同的编码方式那么就出现了乱码。\nGBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节； UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节； UTF-16be 编码中，中文字符和英文字符都占 2 个字节。 UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。\nJava 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。\nString 的编码方式 String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。\nString str1 = \u0026#34;中文\u0026#34;; byte[] bytes = str1.getBytes(\u0026#34;UTF-8\u0026#34;); String str2 = new String(bytes, \u0026#34;UTF-8\u0026#34;); System.out.println(str2); 在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。\nbyte[] bytes = str1.getBytes(); Reader 与 Writer 不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。\nInputStreamReader 实现从字节流解码成字符流； OutputStreamWriter 实现字符流编码成为字节流。 实现逐行输出文本文件的内容 public static void readFileContent(String filePath) throws IOException { FileReader fileReader = new FileReader(filePath); BufferedReader bufferedReader = new BufferedReader(fileReader); String line; while ((line = bufferedReader.readLine()) != null) { System.out.println(line); } // 装饰者模式使得 BufferedReader 组合了一个 Reader 对象 // 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法 // 因此只要一个 close() 调用即可 bufferedReader.close(); } 五、对象操作 序列化 序列化就是将一个对象转换成字节序列，方便存储和传输。\n序列化：ObjectOutputStream.writeObject() 反序列化：ObjectInputStream.readObject() 不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。\nSerializable 序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。\npublic static void main(String[] args) throws IOException, ClassNotFoundException { A a1 = new A(123, \u0026#34;abc\u0026#34;); String objectFile = \u0026#34;file/a1\u0026#34;; ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(objectFile)); objectOutputStream.writeObject(a1); objectOutputStream.close(); ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(objectFile)); A a2 = (A) objectInputStream.readObject(); objectInputStream.close(); System.out.println(a2); } private static class A implements Serializable { private int x; private String y; A(int x, String y) { this.x = x; this.y = y; } @Override public String toString() { return \u0026#34;x = \u0026#34; + x + \u0026#34; \u0026#34; + \u0026#34;y = \u0026#34; + y; } } transient transient 关键字可以使一些属性不会被序列化。\nArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。\nprivate transient Object[] elementData; 六、网络操作 Java 中的网络支持：\nInetAddress：用于表示网络上的硬件资源，即 IP 地址； URL：统一资源定位符； Sockets：使用 TCP 协议实现网络通信； Datagram：使用 UDP 协议实现网络通信。 同步和异步：同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO 操作并等待或者轮询的去查看IO 操作是否就绪，而异步是指用户进程触发IO 操作以后便开始做自己的事情，而当IO 操作已经完成的时候会得到IO 完成的通知。\n以银行取款为例：\n同步 ： 自己亲自出马持银行卡到银行取钱（使用同步 IO 时，Java 自己处理IO 读写）；\n异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO 时，Java 将 IO 读写委托给OS 处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS 需要支持异步IO操作API）；\n阻塞和非阻塞：阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作方法的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入方法会立即返回一个状态值。\n以银行取款为例：\n阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）；\n非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器通知可读写时再继续进行读写，不断循环直到读写完成）\nInetAddress 没有公有的构造函数，只能通过静态方法来创建实例。\nInetAddress.getByName(String host); InetAddress.getByAddress(byte[] address); URL 可以直接从 URL 中读取字节流数据。\npublic static void main(String[] args) throws IOException { URL url = new URL(\u0026#34;http://www.baidu.com\u0026#34;); /* 字节流 */ InputStream is = url.openStream(); /* 字符流 */ InputStreamReader isr = new InputStreamReader(is, \u0026#34;utf-8\u0026#34;); /* 提供缓存功能 */ BufferedReader br = new BufferedReader(isr); String line; while ((line = br.readLine()) != null) { System.out.println(line); } br.close(); } Sockets ServerSocket：服务器端类 Socket：客户端类 服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。 Datagram DatagramSocket：通信类 DatagramPacket：数据包类 七、NIO 新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。\n流与块 I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。\n面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。\n面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。\nI/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。\n通道与缓冲区 1. 通道 通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。\n通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。\n通道包括以下类型：\nFileChannel：从文件中读写数据； DatagramChannel：通过 UDP 读写网络中数据； SocketChannel：通过 TCP 读写网络中数据； ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。 2. 缓冲区 发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。\n缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。\n缓冲区包括以下类型：\nByteBuffer CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer 缓冲区状态变量 capacity：最大容量； position：当前已经读写的字节数； limit：还可以读写的字节数。 文件 NIO 实例 以下展示了使用 NIO 快速复制文件的实例：\npublic static void fastCopy(String src, String dist) throws IOException { /* 获得源文件的输入字节流 */ FileInputStream fin = new FileInputStream(src); /* 获取输入字节流的文件通道 */ FileChannel fcin = fin.getChannel(); /* 获取目标文件的输出字节流 */ FileOutputStream fout = new FileOutputStream(dist); /* 获取输出字节流的文件通道 */ FileChannel fcout = fout.getChannel(); /* 为缓冲区分配 1024 个字节 */ ByteBuffer buffer = ByteBuffer.allocateDirect(1024); while (true) { /* 从输入通道中读取数据到缓冲区中 */ int r = fcin.read(buffer); /* read() 返回 -1 表示 EOF */ if (r == -1) { break; } /* 切换读写 */ buffer.flip(); /* 把缓冲区的内容写入输出文件中 */ fcout.write(buffer); /* 清空缓冲区 */ buffer.clear(); } } 选择器 NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。\nNIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。\n通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。\n因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。\n应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。\n1. 创建选择器 Selector selector = Selector.open(); 2. 将通道注册到选择器上 ServerSocketChannel ssChannel = ServerSocketChannel.open(); ssChannel.configureBlocking(false); ssChannel.register(selector, SelectionKey.OP_ACCEPT); 通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。\n在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：\nSelectionKey.OP_CONNECT SelectionKey.OP_ACCEPT SelectionKey.OP_READ SelectionKey.OP_WRITE 它们在 SelectionKey 的定义如下：\npublic static final int OP_READ = 1 \u0026lt;\u0026lt; 0; public static final int OP_WRITE = 1 \u0026lt;\u0026lt; 2; public static final int OP_CONNECT = 1 \u0026lt;\u0026lt; 3; public static final int OP_ACCEPT = 1 \u0026lt;\u0026lt; 4; 可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：\nint interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE; 3. 监听事件 int num = selector.select(); 使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。\n4. 获取到达的事件 Set\u0026lt;SelectionKey\u0026gt; keys = selector.selectedKeys(); Iterator\u0026lt;SelectionKey\u0026gt; keyIterator = keys.iterator(); while (keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if (key.isAcceptable()) { // ... } else if (key.isReadable()) { // ... } keyIterator.remove(); } 5. 事件循环 因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。\nwhile (true) { int num = selector.select(); Set\u0026lt;SelectionKey\u0026gt; keys = selector.selectedKeys(); Iterator\u0026lt;SelectionKey\u0026gt; keyIterator = keys.iterator(); while (keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if (key.isAcceptable()) { // ... } else if (key.isReadable()) { // ... } keyIterator.remove(); } } 套接字 NIO 实例 public class NIOServer { public static void main(String[] args) throws IOException { Selector selector = Selector.open(); ServerSocketChannel ssChannel = ServerSocketChannel.open(); ssChannel.configureBlocking(false); ssChannel.register(selector, SelectionKey.OP_ACCEPT); ServerSocket serverSocket = ssChannel.socket(); InetSocketAddress address = new InetSocketAddress(\u0026#34;127.0.0.1\u0026#34;, 8888); serverSocket.bind(address); while (true) { selector.select(); Set\u0026lt;SelectionKey\u0026gt; keys = selector.selectedKeys(); Iterator\u0026lt;SelectionKey\u0026gt; keyIterator = keys.iterator(); while (keyIterator.hasNext()) { SelectionKey key = keyIterator.next(); if (key.isAcceptable()) { ServerSocketChannel ssChannel1 = (ServerSocketChannel) key.channel(); // 服务器会为每个新连接创建一个 SocketChannel SocketChannel sChannel = ssChannel1.accept(); sChannel.configureBlocking(false); // 这个新连接主要用于从客户端读取数据 sChannel.register(selector, SelectionKey.OP_READ); } else if (key.isReadable()) { SocketChannel sChannel = (SocketChannel) key.channel(); System.out.println(readDataFromSocketChannel(sChannel)); sChannel.close(); } keyIterator.remove(); } } } private static String readDataFromSocketChannel(SocketChannel sChannel) throws IOException { ByteBuffer buffer = ByteBuffer.allocate(1024); StringBuilder data = new StringBuilder(); while (true) { buffer.clear(); int n = sChannel.read(buffer); if (n == -1) { break; } buffer.flip(); int limit = buffer.limit(); char[] dst = new char[limit]; for (int i = 0; i \u0026lt; limit; i++) { dst[i] = (char) buffer.get(i); } data.append(dst); buffer.clear(); } return data.toString(); } } public class NIOClient { public static void main(String[] args) throws IOException { Socket socket = new Socket(\u0026#34;127.0.0.1\u0026#34;, 8888); OutputStream out = socket.getOutputStream(); String s = \u0026#34;hello world\u0026#34;; out.write(s.getBytes()); out.close(); } } 内存映射文件 内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。\n向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。\n下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。\nMappedByteBuffer mbb = fc.map(FileChannel.MapMode.READ_WRITE, 0, 1024); 对比 NIO 与普通 I/O 的区别主要有以下两点：\nNIO 是非阻塞的； NIO 面向块，I/O 面向流。 ","permalink":"https://oxygenbytes.github.io/posts/java/java-io/","summary":"一、概览 Java 的 I/O 大概可以分成以下几类： 磁盘操作：File 字节操作：InputStream 和 OutputStream 字符操作：Reader 和 Writer 对象操作：Seriali","title":"Java IO"},{"content":"一、数据类型 基本类型 byte/8 char/16 short/16 int/32 float/32 long/64 double/64 boolean/~ boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。\n数据类型转换 从高到低转换 强制转换 从低到高转换 自动转换\nint i = 128; byte b = (byte)i; double d = i; 包装类型 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。\nInteger x = 2; // 装箱 int y = x; // 拆箱 缓存池 new Integer(123) 与 Integer.valueOf(123) 的区别在于：\nnew Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 Integer x = new Integer(123); Integer y = new Integer(123); System.out.println(x == y); // false Integer z = Integer.valueOf(123); Integer k = Integer.valueOf(123); System.out.println(z == k); // true valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。\npublic static Integer valueOf(int i) { if (i \u0026gt;= IntegerCache.low \u0026amp;\u0026amp; i \u0026lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); } 在 Java 8 中，Integer 缓存池的大小默认为 -128~127。\nstatic final int low = -128; static final int high; static final Integer cache[]; static { // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(\u0026#34;java.lang.Integer.IntegerCache.high\u0026#34;); if (integerCacheHighPropValue != null) { try { int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); } catch( NumberFormatException nfe) { // If the property cannot be parsed into an int, ignore it. } } high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k \u0026lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high \u0026gt;= 127; } 编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。\nInteger m = 123; Integer n = 123; System.out.println(m == n); // true 基本类型对应的缓冲池如下：\nboolean values true and false all byte values short values between -128 and 127 int values between -128 and 127 char in the range \\u0000 to \\u007F 在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。\n二、String 概览 String 被声明为 final，因此它不可被继承。\n在 Java 8 中，String 内部使用 char 数组存储数据。\npublic final class String implements java.io.Serializable, Comparable\u0026lt;String\u0026gt;, CharSequence { /** The value is used for character storage. */ private final char value[]; } value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。\n不可变的好处 1. 可以缓存 hash 值\n因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。\n2. String Pool 的需要\n如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。\n3. 安全性\nString 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。\n4. 线程安全\nString 不可变性天生具备线程安全，可以在多个线程中安全地使用。\nString, StringBuffer and StringBuilder 1. 可变性\nString 不可变 StringBuffer 和 StringBuilder 可变 2. 线程安全\nString 不可变，因此是线程安全的 StringBuilder 不是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步 String Pool 字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。\n当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。\n下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。\nString s1 = new String(\u0026#34;aaa\u0026#34;); String s2 = new String(\u0026#34;aaa\u0026#34;); System.out.println(s1 == s2); // false String s3 = s1.intern(); String s4 = s1.intern(); System.out.println(s3 == s4); // true 如果是采用 \u0026ldquo;bbb\u0026rdquo; 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。\nString s5 = \u0026#34;bbb\u0026#34;; String s6 = \u0026#34;bbb\u0026#34;; System.out.println(s5 == s6); // true new String(\u0026ldquo;abc\u0026rdquo;) 使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 \u0026ldquo;abc\u0026rdquo; 字符串对象）。\n\u0026ldquo;abc\u0026rdquo; 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 \u0026ldquo;abc\u0026rdquo; 字符串字面量； 而使用 new 的方式会在堆中创建一个字符串对象。 创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。\npublic class NewStringTest { public static void main(String[] args) { String s = new String(\u0026#34;abc\u0026#34;); } } 使用 javap -verbose 进行反编译，得到以下内容：\n// ... Constant pool: // ... #2 = Class #18 // java/lang/String #3 = String #19 // abc // ... #18 = Utf8 java/lang/String #19 = Utf8 abc // ... public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=3, locals=2, args_size=1 0: new #2 // class java/lang/String 3: dup 4: ldc #3 // String abc 6: invokespecial #4 // Method java/lang/String.\u0026#34;\u0026lt;init\u0026gt;\u0026#34;:(Ljava/lang/String;)V 9: astore_1 // ... 在 Constant Pool 中，#19 存储这字符串字面量 \u0026ldquo;abc\u0026rdquo;，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。\n以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。\npublic String(String original) { this.value = original.value; this.hash = original.hash; } 三、运算 参数传递 Java 的参数是以值传递的形式传入方法中，而不是引用传递。\n以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。\npublic class Dog { String name; Dog(String name) { this.name = name; } String getName() { return this.name; } void setName(String name) { this.name = name; } String getObjectAddress() { return super.toString(); } } public class PassByValueExample { public static void main(String[] args) { Dog dog = new Dog(\u0026#34;A\u0026#34;); System.out.println(dog.getObjectAddress()); // Dog@4554617c func(dog); System.out.println(dog.getObjectAddress()); // Dog@4554617c System.out.println(dog.getName()); // A } private static void func(Dog dog) { System.out.println(dog.getObjectAddress()); // Dog@4554617c dog = new Dog(\u0026#34;B\u0026#34;); System.out.println(dog.getObjectAddress()); // Dog@74a14482 System.out.println(dog.getName()); // B } } 如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。\nclass PassByValueExample { public static void main(String[] args) { Dog dog = new Dog(\u0026#34;A\u0026#34;); func(dog); System.out.println(dog.getName()); // B } private static void func(Dog dog) { dog.setName(\u0026#34;B\u0026#34;); } } StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?\nfloat 与 double Java 不能隐式执行向下转型，因为这会使得精度降低。\n1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。\n// float f = 1.1; 1.1f 字面量才是 float 类型。\nfloat f = 1.1f; 隐式类型转换 因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。\nshort s1 = 1; // s1 = s1 + 1; 但是使用 += 或者 ++ 运算符可以执行隐式类型转换。\ns1 += 1; // s1++; 上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：\ns1 = (short) (s1 + 1); StackOverflow : Why don\u0026rsquo;t Java\u0026rsquo;s +=, -=, *=, /= compound assignment operators require casting?\nswitch 从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。\nString s = \u0026#34;a\u0026#34;; switch (s) { case \u0026#34;a\u0026#34;: System.out.println(\u0026#34;aaa\u0026#34;); break; case \u0026#34;b\u0026#34;: System.out.println(\u0026#34;bbb\u0026#34;); break; } switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。\n// long x = 111; // switch (x) { // Incompatible types. Found: \u0026#39;long\u0026#39;, required: \u0026#39;char, byte, short, int, Character, Byte, Short, Integer, String, or an enum\u0026#39; // case 111: // System.out.println(111); // break; // case 222: // System.out.println(222); // break; // } StackOverflow : Why can\u0026rsquo;t your switch statement data type be long, Java?\n四、继承 访问权限 Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。\n可以对类或类中的成员（字段以及方法）加上访问修饰符。\n类可见表示其它类可以用这个类创建实例对象。 成员可见表示其它类可以用这个类的实例对象访问到该成员； protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。\n设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。\n如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。\n字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。\npublic class AccessExample { public String id; } 可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。\npublic class AccessExample { private int id; public String getId() { return id + \u0026#34;\u0026#34;; } public void setId(String id) { this.id = Integer.valueOf(id); } } 但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。\npublic class AccessWithInnerClassExample { private class InnerClass { int x; } private InnerClass innerClass; public AccessWithInnerClassExample() { innerClass = new InnerClass(); } public int getValue() { return innerClass.x; // 直接访问 } } 抽象类与接口 1. 抽象类\n抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。\n抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。\npublic abstract class AbstractClassExample { protected int x; private int y; public abstract void func1(); public void func2() { System.out.println(\u0026#34;func2\u0026#34;); } } public class AbstractExtendClassExample extends AbstractClassExample { @Override public void func1() { System.out.println(\u0026#34;func1\u0026#34;); } } // AbstractClassExample ac1 = new AbstractClassExample(); // \u0026#39;AbstractClassExample\u0026#39; is abstract; cannot be instantiated AbstractClassExample ac2 = new AbstractExtendClassExample(); ac2.func1(); 2. 接口\n接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。\n从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。\n接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。\n接口的字段默认都是 static 和 final 的。\npublic interface InterfaceExample { void func1(); default void func2(){ System.out.println(\u0026#34;func2\u0026#34;); } int x = 123; // int y; // Variable \u0026#39;y\u0026#39; might not have been initialized public int z = 0; // Modifier \u0026#39;public\u0026#39; is redundant for interface fields // private int k = 0; // Modifier \u0026#39;private\u0026#39; not allowed here // protected int l = 0; // Modifier \u0026#39;protected\u0026#39; not allowed here // private void fun3(); // Modifier \u0026#39;private\u0026#39; not allowed here } public class InterfaceImplementExample implements InterfaceExample { @Override public void func1() { System.out.println(\u0026#34;func1\u0026#34;); } } // InterfaceExample ie1 = new InterfaceExample(); // \u0026#39;InterfaceExample\u0026#39; is abstract; cannot be instantiated InterfaceExample ie2 = new InterfaceImplementExample(); ie2.func1(); System.out.println(InterfaceExample.x); 3. 比较\n从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。 4. 使用选择\n使用接口：\n需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法； 需要使用多重继承。 使用抽象类：\n需要在几个相关的类中共享代码。 需要能控制继承来的成员的访问权限，而不是都为 public。 需要继承非静态和非常量字段。 在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。\n深入理解 abstract class 和 interface When to Use Abstract Class and Interface super 访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。 访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。 public class SuperExample { protected int x; protected int y; public SuperExample(int x, int y) { this.x = x; this.y = y; } public void func() { System.out.println(\u0026#34;SuperExample.func()\u0026#34;); } } public class SuperExtendExample extends SuperExample { private int z; public SuperExtendExample(int x, int y, int z) { super(x, y); this.z = z; } @Override public void func() { super.func(); System.out.println(\u0026#34;SuperExtendExample.func()\u0026#34;); } } SuperExample e = new SuperExtendExample(1, 2, 3); e.func(); SuperExample.func() SuperExtendExample.func() 重写与重载 1. 重写（Override）\n存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。\n为了满足里式替换原则，重写有有以下两个限制：\n子类方法的访问权限必须大于等于父类方法； 子类方法的返回类型必须是父类方法返回类型或为其子类型。 使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。\n2. 重载（Overload）\n存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。\n应该注意的是，返回值不同，其它都相同不算是重载。\n3. 实例\nclass A { public String show(D obj) { return (\u0026#34;A and D\u0026#34;); } public String show(A obj) { return (\u0026#34;A and A\u0026#34;); } } class B extends A { public String show(B obj) { return (\u0026#34;B and B\u0026#34;); } public String show(A obj) { return (\u0026#34;B and A\u0026#34;); } } class C extends B { } class D extends B { } public class Test { public static void main(String[] args) { A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(a1.show(b)); // A and A System.out.println(a1.show(c)); // A and A System.out.println(a1.show(d)); // A and D System.out.println(a2.show(b)); // B and A System.out.println(a2.show(c)); // B and A System.out.println(a2.show(d)); // A and D System.out.println(b.show(b)); // B and B System.out.println(b.show(c)); // B and B System.out.println(b.show(d)); // A and D } } 涉及到重写时，方法调用的优先级为：\nthis.show(O) super.show(O) this.show((super)O) super.show((super)O) 五、Object 通用方法 概览 public native int hashCode() public boolean equals(Object obj) protected native Object clone() throws CloneNotSupportedException public String toString() public final native Class\u0026lt;?\u0026gt; getClass() protected void finalize() throws Throwable {} public final native void notify() public final native void notifyAll() public final native void wait(long timeout) throws InterruptedException public final void wait(long timeout, int nanos) throws InterruptedException public final void wait() throws InterruptedException equals() 1. 等价关系\nⅠ 自反性\nx.equals(x); // true Ⅱ 对称性\nx.equals(y) == y.equals(x); // true Ⅲ 传递性\nif (x.equals(y) \u0026amp;\u0026amp; y.equals(z)) x.equals(z); // true; Ⅳ 一致性\n多次调用 equals() 方法结果不变\nx.equals(y) == x.equals(y); // true Ⅴ 与 null 的比较\n对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false\nx.equals(null); // false; 2. 等价与相等\n对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。 对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。 Integer x = new Integer(1); Integer y = new Integer(1); System.out.println(x.equals(y)); // true System.out.println(x == y); // false 3. 实现\n检查是否为同一个对象的引用，如果是直接返回 true； 检查是否是同一个类型，如果不是，直接返回 false； 将 Object 对象进行转型； 判断每个关键域是否相等。 public class EqualExample { private int x; private int y; private int z; public EqualExample(int x, int y, int z) { this.x = x; this.y = y; this.z = z; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; EqualExample that = (EqualExample) o; if (x != that.x) return false; if (y != that.y) return false; return z == that.z; } } hashCode() hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。\n在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。\n下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。\nEqualExample e1 = new EqualExample(1, 1, 1); EqualExample e2 = new EqualExample(1, 1, 1); System.out.println(e1.equals(e2)); // true HashSet\u0026lt;EqualExample\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); set.add(e1); set.add(e2); System.out.println(set.size()); // 2 理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。\n一个数与 31 相乘可以转换成移位和减法：31*x == (x\u0026lt;\u0026lt;5)-x，编译器会自动进行这个优化。\n@Override public int hashCode() { int result = 17; result = 31 * result + x; result = 31 * result + y; result = 31 * result + z; return result; } toString() 默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。\npublic class ToStringExample { private int number; public ToStringExample(int number) { this.number = number; } } ToStringExample example = new ToStringExample(123); System.out.println(example.toString()); ToStringExample@4554617c clone() 1. cloneable\nclone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。\npublic class CloneExample { private int a; private int b; } CloneExample e1 = new CloneExample(); // CloneExample e2 = e1.clone(); // \u0026#39;clone()\u0026#39; has protected access in \u0026#39;java.lang.Object\u0026#39; 重写 clone() 得到以下实现：\npublic class CloneExample { private int a; private int b; @Override public CloneExample clone() throws CloneNotSupportedException { return (CloneExample)super.clone(); } } CloneExample e1 = new CloneExample(); try { CloneExample e2 = e1.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } java.lang.CloneNotSupportedException: CloneExample 以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。\n应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。\npublic class CloneExample implements Cloneable { private int a; private int b; @Override public Object clone() throws CloneNotSupportedException { return super.clone(); } } 2. 浅拷贝\n拷贝对象和原始对象的引用类型引用同一个对象。\npublic class ShallowCloneExample implements Cloneable { private int[] arr; public ShallowCloneExample() { arr = new int[10]; for (int i = 0; i \u0026lt; arr.length; i++) { arr[i] = i; } } public void set(int index, int value) { arr[index] = value; } public int get(int index) { return arr[index]; } @Override protected ShallowCloneExample clone() throws CloneNotSupportedException { return (ShallowCloneExample) super.clone(); } } ShallowCloneExample e1 = new ShallowCloneExample(); ShallowCloneExample e2 = null; try { e2 = e1.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } e1.set(2, 222); System.out.println(e2.get(2)); // 222 3. 深拷贝\n拷贝对象和原始对象的引用类型引用不同对象。\npublic class DeepCloneExample implements Cloneable { private int[] arr; public DeepCloneExample() { arr = new int[10]; for (int i = 0; i \u0026lt; arr.length; i++) { arr[i] = i; } } public void set(int index, int value) { arr[index] = value; } public int get(int index) { return arr[index]; } @Override protected DeepCloneExample clone() throws CloneNotSupportedException { DeepCloneExample result = (DeepCloneExample) super.clone(); result.arr = new int[arr.length]; for (int i = 0; i \u0026lt; arr.length; i++) { result.arr[i] = arr[i]; } return result; } } DeepCloneExample e1 = new DeepCloneExample(); DeepCloneExample e2 = null; try { e2 = e1.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } e1.set(2, 222); System.out.println(e2.get(2)); // 2 4. clone() 的替代方案\n使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。\npublic class CloneConstructorExample { private int[] arr; public CloneConstructorExample() { arr = new int[10]; for (int i = 0; i \u0026lt; arr.length; i++) { arr[i] = i; } } public CloneConstructorExample(CloneConstructorExample original) { arr = new int[original.arr.length]; for (int i = 0; i \u0026lt; original.arr.length; i++) { arr[i] = original.arr[i]; } } public void set(int index, int value) { arr[index] = value; } public int get(int index) { return arr[index]; } } CloneConstructorExample e1 = new CloneConstructorExample(); CloneConstructorExample e2 = new CloneConstructorExample(e1); e1.set(2, 222); System.out.println(e2.get(2)); // 2 六、关键字 final 1. 数据\n声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。\n对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。 final int x = 1; // x = 2; // cannot assign value to final variable \u0026#39;x\u0026#39; final A y = new A(); y.a = 1; 2. 方法\n声明方法不能被子类重写。\nprivate 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。\n3. 类\n声明类不允许被继承。\nstatic 1. 静态变量\n静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。 public class A { private int x; // 实例变量 private static int y; // 静态变量 public static void main(String[] args) { // int x = A.x; // Non-static field \u0026#39;x\u0026#39; cannot be referenced from a static context A a = new A(); int x = a.x; int y = A.y; } } 2. 静态方法\n静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。\npublic abstract class A { public static void func1(){ } // public abstract static void func2(); // Illegal combination of modifiers: \u0026#39;abstract\u0026#39; and \u0026#39;static\u0026#39; } 只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。\npublic class A { private static int x; private int y; public static void func1(){ int a = x; // int b = y; // Non-static field \u0026#39;y\u0026#39; cannot be referenced from a static context // int b = this.y; // \u0026#39;A.this\u0026#39; cannot be referenced from a static context } } 3. 静态语句块\n静态语句块在类初始化时运行一次。\npublic class A { static { System.out.println(\u0026#34;123\u0026#34;); } public static void main(String[] args) { A a1 = new A(); A a2 = new A(); } } 123 4. 静态内部类\n非静态内部类依赖于外部类的实例，而静态内部类不需要。\npublic class OuterClass { class InnerClass { } static class StaticInnerClass { } public static void main(String[] args) { // InnerClass innerClass = new InnerClass(); // \u0026#39;OuterClass.this\u0026#39; cannot be referenced from a static context OuterClass outerClass = new OuterClass(); InnerClass innerClass = outerClass.new InnerClass(); StaticInnerClass staticInnerClass = new StaticInnerClass(); } } 静态内部类不能访问外部类的非静态的变量和方法。\n5. 静态导包\n在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。\nimport static com.xxx.ClassName.* 6. 初始化顺序\n静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。\npublic static String staticField = \u0026#34;静态变量\u0026#34;; static { System.out.println(\u0026#34;静态语句块\u0026#34;); } public String field = \u0026#34;实例变量\u0026#34;; { System.out.println(\u0026#34;普通语句块\u0026#34;); } 最后才是构造函数的初始化。\npublic InitialOrderTest() { System.out.println(\u0026#34;构造函数\u0026#34;); } 存在继承的情况下，初始化顺序为：\n父类（静态变量、静态语句块） 子类（静态变量、静态语句块） 父类（实例变量、普通语句块） 父类（构造函数） 子类（实例变量、普通语句块） 子类（构造函数） 七、反射 每个类都有一个 Class 对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。\n类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 Class.forName(\u0026quot;com.mysql.jdbc.Driver\u0026quot;) 这种方式来控制类的加载，该方法会返回一个 Class 对象。\n反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。\nClass 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：\nField ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段； Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法； Constructor ：可以用 Constructor 创建新的对象。 反射的优点：\n可扩展性 ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。 类浏览器和可视化开发环境 ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。 调试器和测试工具 ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。 反射的缺点：\n尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。\n性能开销 ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。\n安全限制 ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。\n内部暴露 ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。\n八、异常 Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： Error 和 Exception。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：\n受检异常 ：需要用 try\u0026hellip;catch\u0026hellip; 语句捕获并进行处理，并且可以从异常中恢复； 非受检异常 ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。 九、泛型 public class Box\u0026lt;T\u0026gt; { // T stands for \u0026#34;Type\u0026#34; private T t; public void set(T t) { this.t = t; } public T get() { return t; } } 十、注解 Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。\n十一、其他 Java 与 C++ 的区别 Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。 Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。 Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。 Java 支持自动垃圾回收，而 C++ 需要手动回收。 Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。 Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。 Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。 Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。 JRE or JDK JRE is the JVM program, Java application need to run on JRE. JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler \u0026ldquo;javac\u0026rdquo; Java变量命名规范 所有变量、方法、类名见名知意 类成员变量：首字母小写和驼峰原则：monthSalary,除了第一个单词以外，其他单词首字母大写 局部变量：首字母小写和驼峰原则 常量：大写字母和下划线：MAX_VALUE 类名：首字母大写和驼峰原则:Man,GoodMan 方法名：首字母小写和驼峰原则：getClass();\n","permalink":"https://oxygenbytes.github.io/posts/java/java-%E5%9F%BA%E7%A1%80/","summary":"一、数据类型 基本类型 byte/8 char/16 short/16 int/32 float/32 long/64 double/64 boolean/~ boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean","title":"Java 基础"},{"content":"一、概览 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。\n1. Set TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。\nHashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。\nLinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。\n2. List ArrayList：基于动态数组实现，支持随机访问。\nVector：和 ArrayList 类似，但它是线程安全的。\nLinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。\n3. Queue LinkedList：可以用它来实现双向队列。\nPriorityQueue：基于堆结构实现，可以用它来实现优先队列。\nMap TreeMap：基于红黑树实现。\nHashMap：基于哈希表实现。\nHashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。\nLinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。\n二、容器中的设计模式 迭代器模式 Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。\n从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。\nList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;a\u0026#34;); list.add(\u0026#34;b\u0026#34;); for (String item : list) { System.out.println(item); } 适配器模式 java.util.Arrays#asList() 可以把数组类型转换为 List 类型。\n@SafeVarargs public static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; asList(T... a) 应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。\nInteger[] arr = {1, 2, 3}; List list = Arrays.asList(arr); 也可以使用以下方式调用 asList()：\nList list = Arrays.asList(1, 2, 3); 三、源码分析 如果没有特别说明，以下源码分析基于 JDK 1.8。\n在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。\nArrayList 1. 概览 实现了 RandomAccess 接口，因此支持随机访问。这是理所当然的，因为 ArrayList 是基于数组实现的。\npublic class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements List\u0026lt;E\u0026gt;, RandomAccess, Cloneable, java.io.Serializable 数组的默认大小为 10。\nprivate static final int DEFAULT_CAPACITY = 10; 2. 扩容 添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1)，也就是旧容量的 1.5 倍。\n扩容操作需要调用 Arrays.copyOf() 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。\npublic boolean add(E e) { ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; } private void ensureCapacityInternal(int minCapacity) { if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) { minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); } ensureExplicitCapacity(minCapacity); } private void ensureExplicitCapacity(int minCapacity) { modCount++; // overflow-conscious code if (minCapacity - elementData.length \u0026gt; 0) grow(minCapacity); } private void grow(int minCapacity) { // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity \u0026gt;\u0026gt; 1); if (newCapacity - minCapacity \u0026lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE \u0026gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); } 3. 删除元素 需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。\npublic E remove(int index) { rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved \u0026gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; } 4. Fail-Fast modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。\n在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。\nprivate void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{ // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i\u0026lt;size; i++) { s.writeObject(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } 5. 序列化 ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。\n保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。\ntransient Object[] elementData; // non-private to simplify nested class access ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。\nprivate void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { elementData = EMPTY_ELEMENTDATA; // Read in size, and any hidden stuff s.defaultReadObject(); // Read in capacity s.readInt(); // ignored if (size \u0026gt; 0) { // be like clone(), allocate array based upon size not capacity ensureCapacityInternal(size); Object[] a = elementData; // Read in all elements in the proper order. for (int i=0; i\u0026lt;size; i++) { a[i] = s.readObject(); } } } private void writeObject(java.io.ObjectOutputStream s) throws java.io.IOException{ // Write out element count, and any hidden stuff int expectedModCount = modCount; s.defaultWriteObject(); // Write out size as capacity for behavioural compatibility with clone() s.writeInt(size); // Write out all elements in the proper order. for (int i=0; i\u0026lt;size; i++) { s.writeObject(elementData[i]); } if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } } 序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。\nArrayList list = new ArrayList(); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file)); oos.writeObject(list); Vector 1. 同步 它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。\npublic synchronized boolean add(E e) { modCount++; ensureCapacityHelper(elementCount + 1); elementData[elementCount++] = e; return true; } public synchronized E get(int index) { if (index \u0026gt;= elementCount) throw new ArrayIndexOutOfBoundsException(index); return elementData(index); } 2. 与 ArrayList 的比较 Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制； Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。 3. 替代方案 可以使用 Collections.synchronizedList(); 得到一个线程安全的 ArrayList。\nList\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;String\u0026gt; synList = Collections.synchronizedList(list); 也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。\nList\u0026lt;String\u0026gt; list = new CopyOnWriteArrayList\u0026lt;\u0026gt;(); CopyOnWriteArrayList 读写分离 写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。\n写操作需要加锁，防止并发写入时导致写入数据丢失。\n写操作结束之后需要把原始数组指向新的复制数组。\npublic boolean add(E e) { final ReentrantLock lock = this.lock; lock.lock(); try { Object[] elements = getArray(); int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; } finally { lock.unlock(); } } final void setArray(Object[] a) { array = a; } @SuppressWarnings(\u0026#34;unchecked\u0026#34;) private E get(Object[] a, int index) { return (E) a[index]; } 适用场景 CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。\n但是 CopyOnWriteArrayList 有其缺陷：\n内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右； 数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。 所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。\nLinkedList 1. 概览 基于双向链表实现，使用 Node 存储链表节点信息。\nprivate static class Node\u0026lt;E\u0026gt; { E item; Node\u0026lt;E\u0026gt; next; Node\u0026lt;E\u0026gt; prev; } 每个链表存储了 first 和 last 指针：\ntransient Node\u0026lt;E\u0026gt; first; transient Node\u0026lt;E\u0026gt; last; 2. 与 ArrayList 的比较 ArrayList 基于动态数组实现，LinkedList 基于双向链表实现； ArrayList 支持随机访问，LinkedList 不支持； LinkedList 在任意位置添加删除元素更快。 HashMap 为了便于理解，以下源码分析以 JDK 1.7 为主。\n1. 存储结构 内部包含了一个 Entry 类型的数组 table。\ntransient Entry[] table; Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值相同的 Entry。\nstatic class Entry\u0026lt;K,V\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; { final K key; V value; Entry\u0026lt;K,V\u0026gt; next; int hash; Entry(int h, K k, V v, Entry\u0026lt;K,V\u0026gt; n) { value = v; next = n; key = k; hash = h; } public final K getKey() { return key; } public final V getValue() { return value; } public final V setValue(V newValue) { V oldValue = value; value = newValue; return oldValue; } public final boolean equals(Object o) { if (!(o instanceof Map.Entry)) return false; Map.Entry e = (Map.Entry)o; Object k1 = getKey(); Object k2 = e.getKey(); if (k1 == k2 || (k1 != null \u0026amp;\u0026amp; k1.equals(k2))) { Object v1 = getValue(); Object v2 = e.getValue(); if (v1 == v2 || (v1 != null \u0026amp;\u0026amp; v1.equals(v2))) return true; } return false; } public final int hashCode() { return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue()); } public final String toString() { return getKey() + \u0026#34;=\u0026#34; + getValue(); } } 2. 拉链法的工作原理 HashMap\u0026lt;String, String\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;K1\u0026#34;, \u0026#34;V1\u0026#34;); map.put(\u0026#34;K2\u0026#34;, \u0026#34;V2\u0026#34;); map.put(\u0026#34;K3\u0026#34;, \u0026#34;V3\u0026#34;); 新建一个 HashMap，默认大小为 16； 插入 \u0026lt;K1,V1\u0026gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。 插入 \u0026lt;K2,V2\u0026gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。 插入 \u0026lt;K3,V3\u0026gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 \u0026lt;K2,V2\u0026gt; 前面。 应该注意到链表的插入是以头插法方式进行的，例如上面的 \u0026lt;K3,V3\u0026gt; 不是插在 \u0026lt;K2,V2\u0026gt; 后面，而是插入在链表头部。\n查找需要分成两步进行：\n计算键值对所在的桶； 在链表上顺序查找，时间复杂度显然和链表的长度成正比。 3. put 操作 public V put(K key, V value) { if (table == EMPTY_TABLE) { inflateTable(threshold); } // 键为 null 单独处理 if (key == null) return putForNullKey(value); int hash = hash(key); // 确定桶下标 int i = indexFor(hash, table.length); // 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value for (Entry\u0026lt;K,V\u0026gt; e = table[i]; e != null; e = e.next) { Object k; if (e.hash == hash \u0026amp;\u0026amp; ((k = e.key) == key || key.equals(k))) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; // 插入新键值对 addEntry(hash, key, value, i); return null; } HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。\nprivate V putForNullKey(V value) { for (Entry\u0026lt;K,V\u0026gt; e = table[0]; e != null; e = e.next) { if (e.key == null) { V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; } } modCount++; addEntry(0, null, value, 0); return null; } 使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。\nvoid addEntry(int hash, K key, V value, int bucketIndex) { if ((size \u0026gt;= threshold) \u0026amp;\u0026amp; (null != table[bucketIndex])) { resize(2 * table.length); hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); } createEntry(hash, key, value, bucketIndex); } void createEntry(int hash, K key, V value, int bucketIndex) { Entry\u0026lt;K,V\u0026gt; e = table[bucketIndex]; // 头插法，链表头部指向新的键值对 table[bucketIndex] = new Entry\u0026lt;\u0026gt;(hash, key, value, e); size++; } Entry(int h, K k, V v, Entry\u0026lt;K,V\u0026gt; n) { value = v; next = n; key = k; hash = h; } 4. 确定桶下标 很多操作都需要先确定一个键值对所在的桶下标。\nint hash = hash(key); int i = indexFor(hash, table.length); 4.1 计算 hash 值\nfinal int hash(Object k) { int h = hashSeed; if (0 != h \u0026amp;\u0026amp; k instanceof String) { return sun.misc.Hashing.stringHash32((String) k); } h ^= k.hashCode(); // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h \u0026gt;\u0026gt;\u0026gt; 20) ^ (h \u0026gt;\u0026gt;\u0026gt; 12); return h ^ (h \u0026gt;\u0026gt;\u0026gt; 7) ^ (h \u0026gt;\u0026gt;\u0026gt; 4); } public final int hashCode() { return Objects.hashCode(key) ^ Objects.hashCode(value); } 4.2 取模\n令 x = 1\u0026laquo;4，即 x 为 2 的 4 次方，它具有以下性质：\nx : 00010000 x-1 : 00001111 令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：\ny : 10110010 x-1 : 00001111 y\u0026amp;(x-1) : 00000010 这个性质和 y 对 x 取模效果是一样的：\ny : 10110010 x : 00010000 y%x : 00000010 我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。\n确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。\nstatic int indexFor(int h, int length) { return h \u0026amp; (length-1); } 5. 扩容-基本原理 设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。\n为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。\n和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。\n参数 含义 capacity table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。 size 键值对数量。 threshold size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。 loadFactor 装载因子，table 能够使用的比例，threshold = capacity * loadFactor。 static final int DEFAULT_INITIAL_CAPACITY = 16; static final int MAXIMUM_CAPACITY = 1 \u0026lt;\u0026lt; 30; static final float DEFAULT_LOAD_FACTOR = 0.75f; transient Entry[] table; transient int size; int threshold; final float loadFactor; transient int modCount; 从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。\nvoid addEntry(int hash, K key, V value, int bucketIndex) { Entry\u0026lt;K,V\u0026gt; e = table[bucketIndex]; table[bucketIndex] = new Entry\u0026lt;\u0026gt;(hash, key, value, e); if (size++ \u0026gt;= threshold) resize(2 * table.length); } 扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。\nvoid resize(int newCapacity) { Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) { threshold = Integer.MAX_VALUE; return; } Entry[] newTable = new Entry[newCapacity]; transfer(newTable); table = newTable; threshold = (int)(newCapacity * loadFactor); } void transfer(Entry[] newTable) { Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j \u0026lt; src.length; j++) { Entry\u0026lt;K,V\u0026gt; e = src[j]; if (e != null) { src[j] = null; do { Entry\u0026lt;K,V\u0026gt; next = e.next; int i = indexFor(e.hash, newCapacity); e.next = newTable[i]; newTable[i] = e; e = next; } while (e != null); } } } 6. 扩容-重新计算桶下标 在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。\n假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：\ncapacity : 00010000 new capacity : 00100000 对于一个 Key，\n它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样； 如果为 1，那么得到的结果为原来的结果 +16。 7. 计算数组容量 HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。\n先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：\nmask |= mask \u0026gt;\u0026gt; 1 11011000 mask |= mask \u0026gt;\u0026gt; 2 11111110 mask |= mask \u0026gt;\u0026gt; 4 11111111 mask+1 是大于原始数字的最小的 2 的 n 次方。\nnum 10010000 mask+1 100000000 以下是 HashMap 中计算数组容量的代码：\nstatic final int tableSizeFor(int cap) { int n = cap - 1; n |= n \u0026gt;\u0026gt;\u0026gt; 1; n |= n \u0026gt;\u0026gt;\u0026gt; 2; n |= n \u0026gt;\u0026gt;\u0026gt; 4; n |= n \u0026gt;\u0026gt;\u0026gt; 8; n |= n \u0026gt;\u0026gt;\u0026gt; 16; return (n \u0026lt; 0) ? 1 : (n \u0026gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; } 8. 链表转红黑树 从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。\n9. 与 HashTable 的比较 HashTable 使用 synchronized 来进行同步。 HashMap 可以插入键为 null 的 Entry。 HashMap 的迭代器是 fail-fast 迭代器。 HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。 ConcurrentHashMap 1. 存储结构 static final class HashEntry\u0026lt;K,V\u0026gt; { final int hash; final K key; volatile V value; volatile HashEntry\u0026lt;K,V\u0026gt; next; } ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。\nSegment 继承自 ReentrantLock。\nstatic final class Segment\u0026lt;K,V\u0026gt; extends ReentrantLock implements Serializable { private static final long serialVersionUID = 2249069246763182397L; static final int MAX_SCAN_RETRIES = Runtime.getRuntime().availableProcessors() \u0026gt; 1 ? 64 : 1; transient volatile HashEntry\u0026lt;K,V\u0026gt;[] table; transient int count; transient int modCount; transient int threshold; final float loadFactor; } final Segment\u0026lt;K,V\u0026gt;[] segments; 默认的并发级别为 16，也就是说默认创建 16 个 Segment。\nstatic final int DEFAULT_CONCURRENCY_LEVEL = 16; 2. size 操作 每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。\n/** * The number of elements. Accessed only either within locks * or among other volatile reads that maintain visibility. */ transient int count; 在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。\nConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。\n尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。\n如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。\n/** * Number of unsynchronized retries in size and containsValue * methods before resorting to locking. This is used to avoid * unbounded retries if tables undergo continuous modification * which would make it impossible to obtain an accurate result. */ static final int RETRIES_BEFORE_LOCK = 2; public int size() { // Try a few times to get accurate count. On failure due to // continuous async changes in table, resort to locking. final Segment\u0026lt;K,V\u0026gt;[] segments = this.segments; int size; boolean overflow; // true if size overflows 32 bits long sum; // sum of modCounts long last = 0L; // previous sum int retries = -1; // first iteration isn\u0026#39;t retry try { for (;;) { // 超过尝试次数，则对每个 Segment 加锁 if (retries++ == RETRIES_BEFORE_LOCK) { for (int j = 0; j \u0026lt; segments.length; ++j) ensureSegment(j).lock(); // force creation } sum = 0L; size = 0; overflow = false; for (int j = 0; j \u0026lt; segments.length; ++j) { Segment\u0026lt;K,V\u0026gt; seg = segmentAt(segments, j); if (seg != null) { sum += seg.modCount; int c = seg.count; if (c \u0026lt; 0 || (size += c) \u0026lt; 0) overflow = true; } } // 连续两次得到的结果一致，则认为这个结果是正确的 if (sum == last) break; last = sum; } } finally { if (retries \u0026gt; RETRIES_BEFORE_LOCK) { for (int j = 0; j \u0026lt; segments.length; ++j) segmentAt(segments, j).unlock(); } } return overflow ? Integer.MAX_VALUE : size; } 3. JDK 1.8 的改动 JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。\nJDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。\n并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。\nLinkedHashMap 存储结构 继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。\npublic class LinkedHashMap\u0026lt;K,V\u0026gt; extends HashMap\u0026lt;K,V\u0026gt; implements Map\u0026lt;K,V\u0026gt; 内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。\n/** * The head (eldest) of the doubly linked list. */ transient LinkedHashMap.Entry\u0026lt;K,V\u0026gt; head; /** * The tail (youngest) of the doubly linked list. */ transient LinkedHashMap.Entry\u0026lt;K,V\u0026gt; tail; accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。\nfinal boolean accessOrder; LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。\nvoid afterNodeAccess(Node\u0026lt;K,V\u0026gt; p) { } void afterNodeInsertion(boolean evict) { } afterNodeAccess() 当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。\nvoid afterNodeAccess(Node\u0026lt;K,V\u0026gt; e) { // move node to last LinkedHashMap.Entry\u0026lt;K,V\u0026gt; last; if (accessOrder \u0026amp;\u0026amp; (last = tail) != e) { LinkedHashMap.Entry\u0026lt;K,V\u0026gt; p = (LinkedHashMap.Entry\u0026lt;K,V\u0026gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else { p.before = last; last.after = p; } tail = p; ++modCount; } } afterNodeInsertion() 在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。\nevict 只有在构建 Map 的时候才为 false，在这里为 true。\nvoid afterNodeInsertion(boolean evict) { // possibly remove eldest LinkedHashMap.Entry\u0026lt;K,V\u0026gt; first; if (evict \u0026amp;\u0026amp; (first = head) != null \u0026amp;\u0026amp; removeEldestEntry(first)) { K key = first.key; removeNode(hash(key), key, null, false, true); } } removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。\nprotected boolean removeEldestEntry(Map.Entry\u0026lt;K,V\u0026gt; eldest) { return false; } LRU 缓存 以下是使用 LinkedHashMap 实现的一个 LRU 缓存：\n设定最大缓存空间 MAX_ENTRIES 为 3； 使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序； 覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。 class LRUCache\u0026lt;K, V\u0026gt; extends LinkedHashMap\u0026lt;K, V\u0026gt; { private static final int MAX_ENTRIES = 3; protected boolean removeEldestEntry(Map.Entry eldest) { return size() \u0026gt; MAX_ENTRIES; } LRUCache() { super(MAX_ENTRIES, 0.75f, true); } } public static void main(String[] args) { LRUCache\u0026lt;Integer, String\u0026gt; cache = new LRUCache\u0026lt;\u0026gt;(); cache.put(1, \u0026#34;a\u0026#34;); cache.put(2, \u0026#34;b\u0026#34;); cache.put(3, \u0026#34;c\u0026#34;); cache.get(1); cache.put(4, \u0026#34;d\u0026#34;); System.out.println(cache.keySet()); } [3, 1, 4] WeakHashMap 存储结构 WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。\nWeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。\nprivate static class Entry\u0026lt;K,V\u0026gt; extends WeakReference\u0026lt;Object\u0026gt; implements Map.Entry\u0026lt;K,V\u0026gt; ConcurrentCache Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。\nConcurrentCache 采取的是分代缓存：\n经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）； 不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。 当调用 get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。 当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。 public final class ConcurrentCache\u0026lt;K, V\u0026gt; { private final int size; private final Map\u0026lt;K, V\u0026gt; eden; private final Map\u0026lt;K, V\u0026gt; longterm; public ConcurrentCache(int size) { this.size = size; this.eden = new ConcurrentHashMap\u0026lt;\u0026gt;(size); this.longterm = new WeakHashMap\u0026lt;\u0026gt;(size); } public V get(K k) { V v = this.eden.get(k); if (v == null) { v = this.longterm.get(k); if (v != null) this.eden.put(k, v); } return v; } public void put(K k, V v) { if (this.eden.size() \u0026gt;= size) { this.longterm.putAll(this.eden); this.eden.clear(); } this.eden.put(k, v); } } ","permalink":"https://oxygenbytes.github.io/posts/java/java-%E5%AE%B9%E5%99%A8/","summary":"一、概览 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。 1. Set TreeSet：基于红黑树实","title":"Java 容器"},{"content":" HTTP请求过程 以www.baidu.com为例子\n1.chrome自己的缓存,存留时间大概1min\nNotes:chrome://net-internals/#dns中查询 2.chrome搜索操作系统自身的DNS缓存(浏览器没有找到缓存或者缓存已经失效)\n3.读取本地的HOST文件\n4.浏览器发起一个DNS的一个系统调用\n​\t- 宽带运营商服务器查看本身的本地缓存\n​\t- 运营商服务器发起一个迭代DNS解析请求(-\u0026gt;根-\u0026gt;顶级域名地址-\u0026gt;目标)\n​\t- 运营商服务器把结果返回给操作系统内核,同时缓存起来\n​\t- 操作系统内核把结果返回浏览器\n​\t- 最终浏览器拿到了www.baidu.com对应的IP地址\n5.建立TCP/IP连接\nTCP/IP连接,属于计算机网络的事情,包括运输层的连续ARQ协议,TCP/UDP等,以及IP层路由选择算法(RIP,OSPF),ARP地址解析,再往下CSMA/CD(载波监听,碰撞检测)以及CSMA/CA等\u0026hellip;\n6.TCP/IP 链接建立起来之后,浏览器就可以向服务器发送HTTP请求了使用了.比如说,用HTTP的GET方法请求一个根域名的一个域名,协议可以采用HTTP1.0的一个协议(HTTP1.1 是保持连接,与此有所不同,对于同义词请求中,可以同时包含)\n7.服务器端接受到了这个请求,根据路径参数,经过后端的一些处理后,把处理后的一个结果的数据返回给浏览器,如果是百度的页面,就会把完整的HTML页面代码返回给浏览器\n8.浏览器拿到了完整的HTML页面代码,在解析和渲染这个页面的时候,里面的JS,CSS, 图片静态资源,他们同样也是一个个的HTTP请求,都需要经过上述的主要七个步骤\n9.浏览器根据拿到的资源对页面进行渲染,最终把一个完整的页面呈现给了用户.\n心跳机制简介 在分布式系统中，分布在不同主机上的节点需要检测其他节点的状态，如服务器节点需要检测从节点是否失效。为了检测对方节点的有效性，每隔固定时间就发送一个固定信息给对方，对方回复一个固定信息，如果长时间没有收到对方的回复，则断开与对方的连接。\n发包方既可以是服务端，也可以是客户端，这要看具体实现。因为是每隔固定时间发送一次，类似心跳，所以发送的固定信息称为心跳包。心跳包一般为比较小的包，可根据具体实现。心跳包主要应用于长连接的保持与短线链接。\n一般而言，应该客户端主动向服务器发送心跳包，因为服务器向客户端发送心跳包会影响服务器的性能。\nTCP和UDP的区别 1.对比 UDP TCP 是否连接 无连接 面向连接 是否可靠 不可靠传输，不使用流量控制和拥塞控制 可靠传输，使用流量控制和拥塞控制 连接对象个数 支持一对一，一对多，多对一和多对多交互通信 只能是一对一通信 传输方式 面向报文 面向字节流 首部开销 首部开销小，仅 8 字节 首部最小 20 字节，最大 60 字节 适用场景 适用于实时应用（IP 电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输 2.总结 TCP 向上层提供面向连接的可靠服务 ，UDP 向上层提供无连接不可靠服务。 虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为 对数据准确性要求高，速度可以相对较慢的，可以选用 TCP 流量控制和拥塞控制 拥塞控制 网络拥塞现象是指到达通信子网中某一部分的分组数量过多,使得该部分网络来不及处理,以致引起这部分乃至整个网络性能下降的现象,严重时甚至会导致网络通信业务陷入停顿,即出现死锁现象。拥塞控制是处理网络拥塞现象的一种机制。 流量控制 数据的传送与接收过程当中很可能出现收方来不及接收的情况,这时就需要对发方进行控制,以免数据丢失。 多线程如何同步 windows 线程同步有四种方式：临界区、内核对象、互斥量、信号量。\nLinux 线程同步有最常用的是：互斥锁、条件变量和信号量。\n进程间通讯的方式有哪些，各有什么优缺点 进程间通信 Linux 进程间通信（IPC）以下以几部分发展而来： 早期UNIX进程间通信、基于System V进程间通信、基于Socket进程间通信和POSIX进程间通信。 UNIX进程间通信方式包括：管道、FIFO、信号。 System V进程间通信方式包括：System V消息队列、System V信号灯、System V共享内存、 POSIX进程间通信包括：posix消息队列、posix信号灯、posix共享内存。 现在linux使用的进程间通信方式： （1）管道（pipe）和有名管道（FIFO） （2）信号（signal） （3）消息队列 （4）共享内存 （5）信号量 （6）套接字（socket)\ntcp连接建立的时候3次握手，断开连接的4次握手的具体过程 建立连接采用的3次握手协议，具体是指： 第一次握手是客户端connect连接到server，server accept client的请求之后，向client端发送一个消息，相当于说我都准备好了，你连接上我了，这是第二次握手，第3次握手就是client向server发送的，就是对第二次握手消息的确认。之后client和server就开始通讯了。 断开连接的4次握手,具体如下： 断开连接的一端发送close请求是第一次握手，另外一端接收到断开连接的请求之后需要对close进行确认，发送一个消息，这是第二次握手，发送了确认消息之后还要向对端发送close消息，要关闭对对端的连接，这是第3次握手，而在最初发送断开连接的一端接收到消息之后，进入到一个很重要的状态time_wait状态，这个状态也是面试官经常问道的问题，最后一次握手是最初发送断开连接的一端接收到消息之后。对消息的确认。\nepoll与select的区别 select在一个进程中打开的最大fd是有限制的，由FD_SETSIZE设置，默认值是2048。不过 epoll则没有这个限制，它所支持的fd上限是最大可以打开文件的数目，这个数字一般远大于2048，一般来说内存越大，fd上限越大，1G内存都能达到大约10w左右。\nselect的轮询机制是系统会去查找每个fd是否数据已准备好，当fd很多的时候，效率当然就直线下降了，epoll采用基于事件的通知方式，一旦某个fd数据就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，而不需要不断的去轮询查找就绪的描述符，这就是epoll高效最本质的原因。\n无论是select还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的，而select则做了不必要的拷贝\nepoll中et和lt的区别与实现原理 LT：水平触发，效率会低于ET触发，尤其在大并发，大流量的情况下。但是LT对代码编写要求比较低，不容易出现问题。LT模式服务编写上的表现是：只要有数据没有被获取，内核就不断通知你，因此不用担心事件丢失的情况。 ET：边缘触发，效率非常高，在并发，大流量的情况下，会比LT少很多epoll的系统调用，因此效率高。但是对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况。\nconnect方法会阻塞，请问有什么方法可以避免其长时间阻塞？ 答:最通常的方法最有效的是加定时器；也可以采用非阻塞模式。\n网络中，如果客户端突然掉线或者重启，服务器端怎么样才能立刻知道？ 答:若客户端掉线或者重新启动，服务器端会收到复位信号，每一种tcp/ip得实现不一样，控制机制也不一样。\n在子网210.27.48.21/30种有多少个可用地址？分别是什么？ 简: 30表示的是网络号(network number)是30位，剩下2位中11是广播(broadcast)地址，00是multicast地址，只有01和10可以作为host address。\n详: 210.27.48.21/30代表的子网的网络号是30位，即网络号是210.27.48.21 \u0026amp; 255.255.255.251=210.27.48.20，此子网的地址空间是2位，即可以有4个地址：210.27.48.20, 210.27.48.21, 210.27.48.22, 210.27.48.23。第一个地址的主机号(host number/id)是0，而主机号0代表的是multicast地址。最后一个地址的最后两位是11，主机号每一位都为1代表的是广播(broadcast)地址。所以只有中间两个地址可以给host使用。其实那个问题本身不准确，广播或multicast地止也是可以使用的地址，所以回答4也应该正确，当然问的人也可能是想要你回答2。我个人觉得最好的回答是一个广播地址，一个multicast地址，2个unicast地址。\nTTL是什么？有什么用处，通常那些工具会用到它？（ping? traceroute? ifconfig? netstat?） 简:TTL是Time To Live，一般是hup count，每经过一个路由就会被减去一，如果它变成0，包会被丢掉。它的主要目的是防止包在有回路的网络上死转，浪费网络资源。ping和traceroute用到它。\n详:TTL是Time To Live，目前是hup count，当包每经过一个路由器它就会被减去一，如果它变成0，路由器就会把包丢掉。IP网络往往带有环(loop)，比如子网A和子网B有两个路由器相连，它就是一个loop。TTL的主要目的是防止包在有回路的网络上死转，因为包的TTL最终后变成0而使得此包从网上消失(此时往往路由器会送一个ICMP包回来，traceroute就是根据这个做的)。ping会送包出去，所以里面有它，但是ping不一定非要不可它。traceroute则是完全因为有它才能成的。ifconfig是用来配置网卡的，netstat -rn 是用来列路由表的，所以都用不着它\n路由表示做什么用的？在linux环境中怎么来配置一条默认路由？ 简:路由表是用来决定如何将包从一个子网传送到另一个子网的，换局话说就是用来决定从一个网卡接收到的包应该送的哪一张网卡上的。在Linux上可以用“route add default gw \u0026lt;默认路由器IP\u0026gt;”来配置一条默认路由。\n详:路由表是用来决定如何将包从一个子网传送到另一个子网的，换局话说就是用来决定从一个网卡接收到的包应该送的哪一张网卡上的。路由表的每一行至少有目标网络号、netmask、到这个子网应该使用的网卡。当路由器从一个网卡接收到一个包时，它扫描路由表的每一行，用里面的netmask和包里的目标IP地址做并逻辑运算(\u0026amp;)找出目标网络号，如果此网络号和这一行里的网络号相同就将这条路由保留下来做为备用路由，如果已经有备用路由了就在这两条路由里将网络号最长的留下来，另一条丢掉，如此接着扫描下一行直到结束。如果扫描结束任没有找到任何路由，就用默认路由。确定路由后，直接将包送到对应的网卡上去。在具体的实现中，路由表可能包含更多的信息为选路由算法的细节所用。题外话：路由算法其实效率很差，而且不scalable，解决办法是使用IP交换机，比如MPLS。 在Linux上可以用“route add default gw \u0026lt;默认路由器IP\u0026gt;”来配置一条默认路由。\n在网络中有两台主机A和B，并通过路由器和其他交换设备连接起来，已经确认物理连接正确无误，怎么来测试这两台机器是否连通？如果不通，怎么来判断故障点？怎么排除故障？ 答:测试这两台机器是否连通：从一台机器ping另一台机器 如果ping不通，用traceroute可以确定是哪个路由器不能连通，然后再找问题是在交换设备/hup/cable等。\n网络编程中设计并发服务器，使用多进程与多线程 ，请问有什么区别？ 答案一: 1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。 2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。 两者都可以提高程序的并发度，提高程序运行效率和响应时间。 线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。\n答案二: 根本区别就一点：用多进程每个进程有自己的地址空间(address space)，线程则共享地址空间。所有其它区别都是由此而来的： 1。速度：线程产生的速度快，线程间的通讯快、切换快等，因为他们在同一个地址空间内。 2。资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。 3。同步问题：线程使用公共变量/内存时需要使用同步机制还是因为他们在同一个地址空间内。 等等\n网络编程的一般步骤 对于TCP连接： 1.服务器端1）创建套接字create；2）绑定端口号bind；3）监听连接listen；4）接受连接请求accept，并返回新的套接字；5）用新返回的套接字recv/send；6）关闭套接字。 2.客户端1）创建套接字create; 2）发起建立连接请求connect; 3）发送/接收数据send/recv；4）关闭套接字。 TCP总结： Server端：create \u0026ndash; bind \u0026ndash; listen\u0026ndash; accept\u0026ndash; recv/send\u0026ndash; close Client端：create\u0026mdash;\u0026mdash;- conncet\u0026mdash;\u0026mdash;send/recv\u0026mdash;\u0026mdash;close.\n对于UDP连接： 1.服务器端:1）创建套接字create；2）绑定端口号bind；3）接收/发送消息recvfrom/sendto；4）关闭套接字。 2.客户端:1）创建套接字create；2）发送/接收消息sendto/recvfrom；3）关闭套接字. UDP总结: Server端：create\u0026mdash;-bind \u0026mdash;-recvfrom/sendto\u0026mdash;-close Client端：create\u0026mdash;- sendto/recvfrom\u0026mdash;-close.\nTCP的重发机制是怎么实现的？ 1.滑动窗口机制，确立收发的边界，能让发送方知道已经发送了多少（已确认）、尚未确认的字节数、尚待发送的字节数；让接收方知道（已经确认收到的字节数）。\n2.选择重传，用于对传输出错的序列进行重传。\nTCP为什么不是两次连接？而是三次握手？ 如果A与B两个进程通信，如果仅是两次连接。可能出现的一种情况就是：A发送完请报文以后，由于网络情况不好，出现了网络拥塞，即B延时很长时间后收到报文，即此时A将此报文认定为失效的报文。B收到报文后，会向A发起连接。此时两次握手完毕，B会认为已经建立了连接可以通信，B会一直等到A发送的连接请求，而A对失效的报文回复自然不会处理。依次会陷入B忙等的僵局，造成资源的浪费。\nconnect方法会阻塞，请问有什么方法可以避免其长时间阻塞？ 可以考虑采用异步传输机制，同步传输与异步传输的主要区别在于同步传输中，如果调用recvfrom后会一致阻塞运行，从而导致调用线程暂停运行；异步传输机制则不然，会立即返回。\n网络编程中设计并发服务器，使用多进程与多线程，请问有什么区别？ 答案一: 1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。 2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。两者都可以提高程序的并发度，提高程序运行效率和响应时间。 线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。 答案二: 根本区别就一点：用多进程每个进程有自己的地址空间(address space)，线程则共享地址空间。所有其它区别都是由此而来的： 1。速度：线程产生的速度快，线程间的通讯快、切换快等，因为他们在同一个地址空间内。 2。资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。 3。同步问题：线程使用公共变量/内存时需要使用同步机制还是因为他们在同一个地址空间内。 等等\n流量控制和拥塞控制的实现机制 拥塞控制 网络拥塞现象是指到达通信子网中某一部分的分组数量过多,使得该部分网络来不及处理,以致引起这部分乃至整个网络性能下降的现象,严重时甚至会导致网络通信业务陷入停顿,即出现死锁现象。拥塞控制是处理网络拥塞现象的一种机制。 流量控制 数据的传送与接收过程当中很可能出现收方来不及接收的情况,这时就需要对发方进行控制,以免数据丢失。 流量控制机制： 流量控制用于防止在端口阻塞的情况下丢帧，这种方法是当发送或接收缓冲区开始溢出时通过将阻塞信号发送回源地址实现的。流量控制可以有效的防止由于网络中瞬间的大量数据对网络带来的冲击，保证用户网络高效而稳定的运行。\n多线程如何同步： 在这里简单说一下linux多线程同步的方法吧（win上有一定的差别，也有一定的累似） 1：线程数据，每个线程数据创建一个键，它和这个键相关联，在各个线程里，都使用这个键来指代线程数据，但在不同的线程里，这个键代表的数据是不同的，在同一个线程里，它代表同样的数据内容。以此来达到线程安全的目的。 2：互斥锁，就是在各个线程要使用的一些公共数据之前加锁，使用之后释放锁，这个是非常常用的线程安全控制的方法，而频繁的加解锁也对效率有一定的影响。 3：条件变量，而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其它的某个线程改变了条件变量，它将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。一般说来，条件变量被用来进行线程间的同步。 4：信号量，信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。当公共资源增加时，调用函数sem_post（）增加信号量。只有当信号量值大于０时，才能使用公共资源，使用后，函数sem_wait（）减少信号量。函数sem_trywait（）和函数pthread_ mutex_trylock（）起同样的作用，它是函数sem_wait（）的非阻塞版本 另外pthread_join也可以等待一个线程的终止。\n进程间通讯的方式有哪些，各有什么优缺点 进程间通信主要包括管道, 系统IPC(包括消息队列,信号量,共享存储), socket.\n管道包括三种:1)普通管道PIPE, 通常有种限制,一是半双工,只能单向传输;二是只能在父子进程间使用. 2)流管道s_pipe: 去除了第一种限制,可以双向传输. 3)命名管道:name_pipe, 去除了第二种限制,可以在许多并不相关的进程之间进行通讯.\n系统IPC的三种方式类同,都是使用了内核里的标识符来识别\n管道: 优点是所有的UNIX实现都支持, 并且在最后一个访问管道的进程终止后,管道就被完全删除;缺陷是管道只允许单向传输或者用于父子进程之间\n系统IPC: 优点是功能强大,能在毫不相关进程之间进行通讯; 缺陷是关键字KEY_T使用了内核标识,占用了内核资源,而且只能被显式删除,而且不能使用SOCKET的一些机制,例如select,epoll等.\nsocket可以跨网络通讯，其他进程间通讯的方式都不可以，只能是本机进程通讯。\ntcp连接建立的时候3次握手的具体过程，以及其中的每一步是为什么 建立连接采用的3次握手协议，具体是指： 第一次握手是客户端connect连接到server，server accept client的请求之后，向client端发送一个消息，相当于说我都准备好了，你连接上我了，这是第二次握手，第3次握手就是client向server发送的，就是对第二次握手消息的确认。之后client和server就开始通讯了。\ntcp断开连接的具体过程，其中每一步是为什么那么做 断开连接的4次握手,具体如下： 断开连接的一端发送close请求是第一次握手，另外一端接收到断开连接的请求之后需要对close进行确认，发送一个消息，这是第二次握手，发送了确认消息之后还要向对端发送close消息，要关闭对对端的连接，这是第3次握手，而在最初发送断开连接的一端接收到消息之后，进入到一个很重要的状态time_wait状态，这个状态也是面试官经常问道的问题，最后一次握手是最初发送断开连接的一端接收到消息之后。对消息的确认。\nsocket编程，如果client断电了，服务器如何快速知道？？？ 有以下几个技术： 使用定时器（适合有数据流动的情况）； 使用socket选项SO_KEEPALIVE（适合没有数据流动的情况）;\nfork()一子进程程后 父进程癿全局变量能不能使用？？？ fork后子进程将会拥有父进程的几乎一切资源，父子进程的都各自有自己的全局变量。不能通用，不同于线程。对于线程，各个线程共享全局变量。\n4G的long型整数中找到一个最大的，如何做？？？？ 我的想法是要找到最大的肯定要遍历所有的数的，而且不能将数据全部读入内存，可能不足。算法的时间复杂度肯定是O（n） 感觉就是遍历，比较。。。。还能怎么改进呢？？？？ 可以改进的地方，就是读入内存的时候，一次多读些。。。。 需 要注意的就是每次从磁盘上尽量多读一些数到内存区，然后处理完之后再读入一批。减少IO次数，自然能够提高效率。而对于类快速排序方法，稍微要麻烦一些： 分批读入，假设是M个数，然后从这M个数中选出n个最大的数缓存起来，直到所有的N个数都分批处理完之后，再将各批次缓存的n个数合并起来再进行一次类快 速排序得到最终的n个最大的数就可以了。在运行过程中，如果缓存数太多，可以不断地将多个缓存合并，保留这些缓存中最大的n个数即可。由于类快速排序的时 间复杂度是O（N），这样分批处理再合并的办法，依然有极大的可能会比堆和败者树更优。当然，在空间上会占用较多的内存。\n此题还有个变种，就是寻找K个最大或者最小的数。有以下几种算法： 容量为K的最大堆/最小堆，假设K可以装入内存； 如果N个数可以装入内存，且都小于MAX，那么可以开辟一个MAX大的数组，类似计数排序。。。从数组尾部扫描K个最大的数，头部扫描K个最小的数。\ntcp三次握手的过程，accept发生在三次握手哪个阶段？ 三次握手：C\u0026mdash;\u0026ndash;\u0026gt;SYN K S\u0026mdash;\u0026mdash;\u0026gt;ACK K+1 SYN J C\u0026mdash;\u0026mdash;-\u0026gt;ACK J+1\nDONE! client 的 connect 引起3次握手 server 在socket， bind， listen后，阻塞在accept，三次握手完成后，accept返回一个fd， 因此accept发生在三次握手之后。。。。。。\nTcp流，udp的数据报，之间有什么区别，为什么TCP要叫做数据流？ TCP本身是面向连接的协议，S和C之间要使用TCP，必须先建立连接，数据就在该连接上流动，可以是双向的，没有边界。所以叫数据流 ，占系统资源多 UDP不是面向连接的，不存在建立连接，释放连接，每个数据包都是独立的包，有边界，一般不会合并。 TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证\nvolatile的含义。 变量可能在编译器的控制或监控之外改变，告诉编译器不要优化该变量，如被系统时钟更新的变量。\n100亿个数，求最大的1万个数，并说出算法的时间复杂度。 用小根堆来实现。注意是小根堆， 读入1万个数，然后做 时间复杂度是O（NlogK）\n设计一个洗牌的算法，并说出算法的时间复杂度。 第一种： for i:=1 to n do swap(a[i], a[random(1,n)]); // 凑合，但不是真正随机 第二种： for i:=1 to n do swap(a[i], a[random(i,n)]); // 真正的随机算法 其中，random(a,b)函数用于返回一个从a到b（包括a和b）的随机整数。 至于怎么证明上两个算法，没想好。 算法复杂度是O（n。。。），要研究下random的实现。\n流量控制与拥塞控制的区别，节点计算机怎样感知网络拥塞了？ 拥塞控制是把整体看成一个处理对象的，流量控制是对单个的节点。 感知的手段应该不少，比如在TCP协议里，TCP报文的重传本身就可以作为拥塞的依据。依据这样的原理， 应该可以设计出很多手段。\nTCP通讯中，select到读事件，但是读到的数据量是0，为什么，如何解决? select 返回0代表超时。select出错返回-1。\nselect到读事件，但是读到的数据量为0，说明对方已经关闭了socket的读端。本端关闭读即可。\n当select出错时，会将接口置为可读又可写。这时就要通过判断select的返回值为-1来区分。\n","permalink":"https://oxygenbytes.github.io/posts/java/java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/","summary":"HTTP请求过程 以www.baidu.com为例子 1.chrome自己的缓存,存留时间大概1min Notes:chrome://net-in","title":"Java 网络编程"},{"content":"二叉树的遍历算法是理解递归和搜索的关键算法，也可以用来思考程序状态问题和分类讨论思想。\n二叉树的先序遍历 非递归版本\nclass Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { if(!root) return {}; vector\u0026lt;int\u0026gt; result; stack\u0026lt;TreeNode*\u0026gt; s; TreeNode* ptr = root; while(!s.empty() || ptr){ if(ptr){ result.push_back(ptr-\u0026gt;val); s.push(ptr); ptr = ptr-\u0026gt;left; }else{ ptr = s.top();s.pop(); ptr = ptr-\u0026gt;right; } } return result; } }; 递归版本\nclass Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; dfs(root, result); return result; } private: void dfs(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res){ if(root){ dfs(root-\u0026gt;left,res); dfs(root-\u0026gt;right, res); res.push_back(root-\u0026gt;val); } } }; 中序遍历 非递归版本\nclass Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; if(!root) return result; stack\u0026lt;TreeNode*\u0026gt; s; TreeNode* ptr = root; while(!s.empty() || ptr){ // 指针不空或者stack不空 if(ptr){ // 1. 指针不空，stack空 2.指针不空，stack不空 s.push(ptr); ptr = ptr -\u0026gt; left; }else{ // 3. 指针空，stack不空 4. 指针空，stack空（这种情况进不了while循环的） ptr = s.top();s.pop(); result.push_back(ptr-\u0026gt;val); ptr = ptr-\u0026gt;right; } } return result; } }; 递归版本\nclass Solution { public: vector\u0026lt;int\u0026gt; inorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; dfs(root, result); return result; } private: void dfs(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res){ if(root){ dfs(root-\u0026gt;left,res); res.push_back(root-\u0026gt;val); dfs(root-\u0026gt;right, res); } } }; 后序遍历 非递归版本\nclass Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { if(!root) return {}; stack\u0026lt;pair\u0026lt;TreeNode*,bool\u0026gt;\u0026gt; s; vector\u0026lt;int\u0026gt; result; TreeNode* ptr = root; while(!s.empty() || ptr){ if(ptr){ s.push(make_pair(ptr,false)); ptr = ptr-\u0026gt;left; }else{ auto now = s.top();s.pop(); if(now.second == false){ s.push(make_pair(now.first,true)); ptr = now.first-\u0026gt;right; }else{ result.push_back(now.first-\u0026gt;val); } } } return result; } }; 递归版本\nclass Solution { public: vector\u0026lt;int\u0026gt; postorderTraversal(TreeNode* root) { vector\u0026lt;int\u0026gt; result; dfs(root, result); return result; } private: void dfs(TreeNode* root, vector\u0026lt;int\u0026gt;\u0026amp; res){ if(root){ dfs(root-\u0026gt;left,res); dfs(root-\u0026gt;right, res); res.push_back(root-\u0026gt;val); } } }; ","permalink":"https://oxygenbytes.github.io/posts/algorithms/binarytreetraversal/","summary":"二叉树的遍历算法是理解递归和搜索的关键算法，也可以用来思考程序状态问题和分类讨论思想。 二叉树的先序遍历 非递归版本 class Solution { public: vector\u0026lt;int\u0026gt; preorderTraversal(TreeNode* root) { if(!root) return {}; vector\u0026lt;int\u0026gt; result; stack\u0026lt;TreeNode*\u0026gt;","title":"二叉树的遍历算法"},{"content":"刷题时生成C++文件 我以前经常在Vscode中刷leetcode题目，但这种方式的代码不够规范，也比较耗时，因为主力语言是 C++ ,所以现在在 Clion 中利用 leetcode 插件来生成代码。个人认为 C++ 的代码和命名方式优雅。所以决定在博客的 leetcode 板块中使用 C++ 的代码格式。\n其中 Clion 插件 leetcode 的代码模板如下：\n// CodeFileName: [$!{question.frontendQuestionId}]${question.title} //CodeTemplate: /* --- title: \u0026#34;[$!{question.frontendQuestionId}]${question.title}\u0026#34; date: $!velocityTool.date()+08:00 draft: false tags: - Leetcode --- */ ${question.content} /* * ${question.frontendQuestionId} ${question.title} * $!velocityTool.date() * @author oxygenbytes */ \\#include \u0026#34;leetcode.h\u0026#34; ${question.code} 其中的 leetcode.h 文件包含了常用头文件和基本数据结构，如下所示：\n// // Created by zxq on 2020/8/13. // #ifndef LEETCODE_LEETCODE_H #define LEETCODE_LEETCODE_H #endif //LEETCODE_LEETCODE_H #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; // Definition for a binary tree node. struct TreeNode { int val; TreeNode *left; TreeNode *right; TreeNode(int x) : val(x), left(NULL), right(NULL) {} }; // Definition for singly-linked list. struct ListNode { int val; ListNode *next; ListNode() : val(0), next(nullptr) {} ListNode(int x) : val(x), next(nullptr) {} ListNode(int x, ListNode *next) : val(x), next(next) {} }; class Node { public: int val; Node* left; Node* right; Node* random; Node* next; Node() {} Node(int _val) { val = _val; left = NULL; right = NULL; random = NULL; next = NULL; } Node(int _val, Node* _left, Node* _right) { val = _val; left = _left; right = _right; } }; 将C++文件转化为MarkDown文件 将待转化的C++文件都拷贝至某一文件夹中，利用 bash 脚本进行文件转化\n#!/usr/bin/bash # sample usage # ./cpp2md.sh ./temp path=$1 cd $path rename \u0026#39;s/\\.cpp/\\.md/\u0026#39; * # change file name ls -R *.md \u0026gt; filename.txt cat filename.txt | while read line do sed -i -e \u0026#39;1d\u0026#39; \u0026#34;$line\u0026#34; # delete /* sed -i \u0026#39;8s/\\*\\//\\`\\`\\`cpp/\u0026#39; \u0026#34;$line\u0026#34; # delete */ and add ```cpp sed -i \u0026#39;$a \\`\\`\\`\u0026#39; \u0026#34;$line\u0026#34; # add ``` in the end of file done 最后的效果就像博客中这样，尚有待改进\n","permalink":"https://oxygenbytes.github.io/leetcode/leetcodeformat/","summary":"刷题时生成C++文件 我以前经常在Vscode中刷leetcode题目，但这种方式的代码不够规范，也比较耗时，因为主力语言是 C++ ,所以现在在 Clion 中","title":"关于博客的Leetcode代码的格式和生成"},{"content":"安装 Termux 是一款基于 Android 平台的开源 Linux 终端模拟器，使用 pkg(apt) 进行软件包的管理。可以在 Google play 安装最新版的 termux 和 termux-API 。Termux 支持缩放手势来调整字体大小，长按屏幕可以调出菜单选项，可以实现粘贴复制等操作。侧边栏可以新建、切换、重命名会话session。\n安装常用的基本软件\npkg install termux-api vim -y 配置ssh 首先PC端需要安装 openssh-client, termux中安装 openssh。\n# PC端 sudo apt-get install openssh-client # termux中 pkg install openssh # PC端生成ssh秘钥 ssh-keygen # Termux开启ssh服务 sshd # 将PC端 ~/.ssh/ 目录下的id_rsa.pub中的内容写入termux中的 ~/.ssh/authorized_keys文件内 # 注意： PC端 ~/.ssh/know_hosts文件中不应有与termux的ssh进程重复的条目 # 一旦出现 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! 的提示，删除PC端 ~/.ssh/know_hosts文件中的对应条目即可 新版本的 termux 已经支持 ssh 的密码登录，可以使用 passwd 初始化 ssh 密码\n定制常用按键 # 新建并编辑配置文件 vim ~/.termux/termux.properties 内容为：\nextra-keys = [ \\ [\u0026#39;ESC\u0026#39;,\u0026#39;|\u0026#39;,\u0026#39;CTRL\u0026#39;,\u0026#39;HOME\u0026#39;,\u0026#39;UP\u0026#39;,\u0026#39;END\u0026#39;,\u0026#39;~\u0026#39;,\u0026#39;DEL\u0026#39;], \\ [\u0026#39;TAB\u0026#39;,\u0026#39;/\u0026#39;,\u0026#39;\u0026gt;\u0026#39;,\u0026#39;LEFT\u0026#39;,\u0026#39;DOWN\u0026#39;,\u0026#39;RIGHT\u0026#39;,\u0026#39;BACKSLASH\u0026#39;,\u0026#39;BKSP\u0026#39;] \\ ] # 重启键盘就会出现，上述键位出现次数高，常用，建议添加 配置剪切板共享 # clipboard alias cg=\u0026#39;termux-clipboard-get\u0026#39; alias cs=\u0026#39;termux-clipboard-set\u0026#39; ​``` ### 配置zsh\u0026amp;\u0026amp;oh-my-zsh ```bash pkg install zsh sh -c \u0026#34;$(curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh)\u0026#34; vim .zshrc # 修改主题为random 配置Chfs # 电脑上下载chfs-linux-arm64-2.0.zip # 网址： https://iscute.cn/tar/chfs/2.0/chfs-linux-arm64-2.0.zip # 使用scp命令将下载的电脑上的文件传输给termux，在PC端执行： scp -P 8022 chfs-linux-arm64-2.0.zip u0_a165@192.168.43.1:~/.chfs unzip chfs-linux-arm64-2.0.zip 编写脚本\n#!/data/data/com.termux/files/usr/bin/bash # 参考自：https://github.com/zsxwz/zstermux/blob/master/chfs.sh # 记得授予termux访问文件的权限 if ! [ -x \u0026#34;$(command -v screen)\u0026#34; ] ; then apt install screen -y fi if [ ! -x \u0026#34;$(command -v chfs)\u0026#34; ] ; then cd ~/.chfs chmod +x chfs mv chfs /data/data/com.termux/files/usr/bin/chfs read -p \u0026#34;请输入用户名:\u0026#34; name echo \u0026#34;$name\u0026#34; \u0026gt; name var1=$(cat name) read -p \u0026#34;请输入密码:\u0026#34; password echo \u0026#34;$password\u0026#34; |base64 -i \u0026gt; password var2=$(base64 -d password) screen -dmS chfs chfs --port=1234 --path=\u0026#34;/sdcard\u0026#34; --rule=\u0026#34;::r|$var1:$var2:rwd\u0026#34; echo -e \u0026#34;\\033[31m请用chrome浏览器打开，127.0.0.1:1234\\033[0m\u0026#34;dd echo \u0026#34;\u0026#34; am start -a android.intent.action.VIEW -d http://127.0.0.1:1234 else cd ~/.chfs var1=$(cat name) var2=$(base64 -d password) screen -dmS chfs chfs --port=1234 --path=\u0026#34;/sdcard\u0026#34; --rule=\u0026#34;::r|$var1:$var2:rwd\u0026#34; fi exit 修改脚本权限并执行脚本\nchmod +x chfs.sh ./chfs.sh bash chfs.sh # 浏览器打开 http://127.0.0.1:1234 查看是否配置成功 # 当打开chfs服务后，就可以在局域网中利用：\u0026lt;ip\u0026gt;:\u0026lt;port\u0026gt; ip=手机ip，port=1234 访问手机文件了 利用SCP进行局域网文件传输 修改 ~/.zshrc alias tomix2=\u0026#34;~/.ssh/tomix2.sh\u0026#34; ~/.ssh/tomix2.sh 的脚本内容为 # 其中8022是termux默认的ssh端口 # u0_a165是安装termux时安卓系统分配的虚拟用户 # 192.168.43.1是安卓手机的局域网ip scp -P 8022 $1 u0_a165@192.168.43.1:/sdcard/ termux备份 # Backing up # In this example, a backup of both home and sysroot will be shown. The resulting archive will be stored on your shared storage (/sdcard) and compressed with gzip. # 1. Ensure that storage permission is granted: termux-setup-storage # 2. Go to Termux base directory: cd /data/data/com.termux/files # 3. Backing up files: tar -zcvf /sdcard/termux-backup.tar.gz home usr # Backup should be finished without any error. # Restoring #Here will be assumed that you have backed up both home and usr directory into same archive. Please note that all files would be overwritten during the process. # 1. Ensure that storage permission is granted: termux-setup-storage # 2. Go to Termux base directory: cd /data/data/com.termux/files # 3. Extract home and usr with overwriting everything and deleting stale files: tar -zxf /sdcard/termux-backup.tar.gz --recursive-unlink --preserve-permissions # Now close Termux with the \u0026#34;exit\u0026#34; button from notification and open it again. ","permalink":"https://oxygenbytes.github.io/posts/linux/termux/","summary":"安装 Termux 是一款基于 Android 平台的开源 Linux 终端模拟器，使用 pkg(apt) 进行软件包的管理。可以在 Google play 安装最新版的 termux 和 termux-API 。Termux 支持缩放手势来调整字体大小，长按","title":"Termux 使用指南"},{"content":"1p 什么是向量？ 定义坐标系 物理系，计算机系，数学系对向量的不同认识 向量可以是任何东西，只要保证两个向量相加以及数字与向量想成是有意义的即可。 可以将向量看作一种运动。从运动的角度定义向量加法和数乘运算。标量对向量而言，作用就是缩放。 2p 向量的线性组合，张成的空间和基 作为标量的向量坐标\n将向量的每个坐标看作一个标量，考虑它们如何拉伸或压缩一个向量\n引入单位向量作为坐标系的基，基向量是坐标缩放的对象\n定义向量的线性组合：两个数乘向量的和被称为这两个向量的线性组合\n定义向量张成的空间(span)：所有可以表示为给定向量线性组合的向量的集合成为给定向量张成的空间\n定义线性相关和线性无关：N个向量可以张成的空间为N维空间，则这N个向量是线性无关的，否则是线性相关的。\n定义空间的一组基：张成该空间的一个线性无关向量的集合。\n3p 矩阵与空间线性变换 “变换”实际上就是函数，它接受输入内容并输出对应结果，而在线性变换中输入的是向量，输出的也是一个向量，这中间的这个函数就是变换矩阵。 线性变换的几何约束：线性变换必须满足两点要求，首先变换前后直线依旧是直线，其次 原点保持不变 。值得注意的是不仅仅要考虑水平与竖直的直线变换前后是否依旧是直线，还要考虑对角线的不是水平的线。线性变换应该是一种 保持网格平行且等距分布 的变换。 记录两个基向量i帽和j帽变换后的位置，其他向量都会随之而动；只要记录了变换后的i帽和j帽，我们就可以推断出任意向量在变换之后的位置，完全不必观察变换本身是什么样。 矩阵：矩阵只是一个记号，它含有描述一个线性变换的信息。向量的列可以理解为变换后对应原基向量的一组基。 4p 矩阵乘法与线性复合变换 两个矩阵相乘有着几何意义，也就是两个线性变换相继作用。乘积需要从右向左读，首先应用右侧矩阵所描述的变换，然后再应用左侧矩阵所描述的变换，它起源于函数的记号，每次将两个函数复合时，你总是要从右向左读。 5p 三维空间中的线性变换 三维空间的概念可以由二维推广得到。 三维线性变换由基向量的去向完全决定，只考虑跟踪这些基向量的话会更容易观察这些线性变换。 6p 行列式 矩阵的行列式可以衡量矩阵对应的线性变换对空间的缩放程度。 对二维空间来说，线性变换改变面积的比例，被称为这个变换的行列式。 只需要检验一个矩阵的行列式是否为0，我们就能了解这个矩阵所代表的变换是否将空间压缩到更小的维度上。 完整概念下的行列式是允许出现负值的，这和定向的概念有关，当空间定向改变的情况发生时，行列式为负，但是行列式的绝对值依然表示区域面积的缩放比例。行列式在三维空间中的意义仍然是变换前后的缩放比例，但在三维空间中表现为体积的缩放。 7p 逆矩阵，列空间，零空间 总的来说， $A^{-1}$ 是满足以下性质的唯一变换，首先应用 $A$ 代表的变换，再应用 $A^{-1}$ 代表的变换，你会回到原始状态。两个变换相继作用在代数上体现为矩阵乘法。 $A^{-1}A$ 等于一个“什么都不做”的矩阵。 如果变换后的向量落在某个二维平面上，所以说 “秩”代表着变换后空间的维数 ，意味着基向量仍旧能张成整个二维空间。 不管是一条直线、一个平面还是三维空间等，所有可能的变换结果的集合，被称为矩阵的“列空间”。换句话说，列空间就是矩阵的列所张成的空间。所以更精确的秩的定义是列空间的维数。 对一个满秩变换来说，唯一能在变换后落在原点的就是零向量自身，如果一个三维线性变换将空间压缩到一条直线上，那么就有一整个平面上的向量在变换后落在原点，变换后落在原点的向量的集合，被称为矩阵的“零空间”或“核”。 每个线性方程组都有一个线性变换与之联系。矩阵 $A$ 代表一种线性变换。 ，所以求解 $Ax=v$ 意味着我们去寻找一个向量 $x$，使得它在变换后与 $v$ 重合。 每个方程组都有一个线性变换与之联系，当逆变换存在时，你就能用这个逆变换求解方程组，否则，列空间的概念让我们清楚什么时候存在解，零空间的概念有助于我们理解所有可能的解的集合是什么样的。 8p 非方阵 一个 $3×2$ 矩阵，这个矩阵的列空间，是三维空间中一个过原点的二维平面，但是这个矩阵仍然是满秩的，因为列空间的维数与输入空间的维数相等。它的几何意义是将二维空间映射到三维空间上，矩阵有两列表明输入空间有两个基向量，有三行表明每一个基向量在变换后都用三个独立的坐标来描述。可以理解为将二维坐标系扩充为三维。 9p 点积与对偶性 多维空间到一维空间（数轴）的线性变换，有不少函数能够接收二维向量并输出一个数。 两个向量点乘，就是将其中一个向量转化为线性变换。 向量仿佛是一个特定变换的概念性记号。对一般人类来说，想象空间中的向量比想象这个空间移动到数轴上更加容易。 10p 叉积 假如你有两个向量 $\\vec v$ 和 $\\vec w$ ，考虑它们所张成的平行四边形， $\\vec v$ 和 $\\vec w$ 的叉积，就是这个平行四边形的面积。我们还要考虑定向问题，大致来讲，如果 $\\vec v$ 在 $\\vec w$ 的右侧，那么$\\vec v$ 叉乘 $\\vec w$ 为正，并且值等于平行四边形的面积。但是如果 $\\vec v$ 在 $\\vec w$ 的左侧那么 $\\vec v$ 叉乘 $\\vec w$ 为负，即平行四边形面积的相反数。注意，这就是说顺序会对叉积有影响。 真正的叉积是通过两个三维向量生成一个新的三维向量。这个向量的长度就是平行四边形的面积，而这个向量的方向与平行四边形（所在的面）垂直。 对于给定的向量 $\\vec v$ 和 $\\vec w$ ,其对应着唯一一个叉积向量 $\\vec x$ 。对于任意的向量 $\\vec u$ 而言，$\\vec u,\\vec v,\\vec w$ 三个向量组成的六面体的体积（行列式值）等于$\\vec x$ 与 $\\vec u$ 点积的结果。这也就是为什么可以使用行列式来记忆叉积。而使用 $\\vec i,\\vec j,\\vec k$ 的单位向量的作用仅仅是根据 $\\vec u$ 向量的坐标值将 $\\vec u $ 向量化。 11p 基变换 空间的原点重合，但是基向量不同。所有基向量在其自身的坐标系中都是单位向量。 现在给定两个坐标系，一个是我们的坐标系，另外一个是詹妮佛的坐标系。在不同坐标系之间进行转化的时候可以使用矩阵向量乘法。转移矩阵 用我们的语言表达詹妮佛的基向量，称为基变换。反之，转移矩阵的逆，表示用詹妮佛的基底表示我们的基底，可以实现从詹妮佛的矩阵向我们矩阵的变换。 一个矩阵的列为詹妮弗的基向量，这个矩阵可以看作一个线性变换，它将我们的基向量i帽和j帽，也就是我们眼中的 $(1, 0)$ 和 $(0, 1)$ ，变换为用詹妮弗的基向量描述的我们的 $(1, 0)$ 和 $(0, 1)$ 。 理解 $A^{-1}MA$ 的意义。 $M$ 是在我们的空间描述某一特定的线性变换。$A$ 是从詹妮佛坐标系向我们坐标系进行基变换的转移矩阵，$A^{-1}$ 是从我们坐标系向詹妮佛坐标系进行基变换的转移矩阵。最终 $A^{-1}MA$ 就是用詹妮佛坐标系描述的同样意义的线性变换。 $A^{-1}MA\\vec x = \\vec b$ 中对于詹妮佛空间的向量 $\\vec x$ 而言，首先左乘基变换矩阵，那么$\\vec x$ 就会变成用我们空间描述的向量；接着左乘线性变换矩阵，即在我们的空间进行线性变换 $M$ ,并且变换后的结果向量依然用我们的空间描述；最后左乘基变换矩阵的逆阵，结果向量就成为了使用詹妮佛空间描述的向量。 表达式中 $A^{-1}MA$ 暗示着一种数学上的转移作用。两侧的矩阵完成了视角上的转换。 12p 特征向量和特征值 一个向量张成的空间是当前向量所在的直线。 对于某个特定的线性变换，在变换前后，大部分向量都在变换中离开了其张成的空间，但是某些特殊向量的确落在它们张成的空间里，这意味着矩阵对它们的作用仅仅是拉伸或者压缩而已，如同一个标量一样。这些特殊向量就被称为变换的“特征向量”，每个特征向量都有一个所属的值，被称为“特征值”，即衡量特征向量在变换中拉伸或压缩比例的因子。 处理 $A\\vec x = \\lambda \\vec x$ 这个式子，在满足这个式子的时候，其中$\\vec x$ 是 $A$ 的特征向量，$\\lambda$ 是A的特征向量。 如果我们的基向量刚好是特征向量，那么对于这个线性变换来说，其对应的矩阵为对角矩阵（所有的基向量都是特征向量）。 对角矩阵有很多良好的性质。其中一个重要的方面是，矩阵与自己多次相乘的结果更容易计算，因为对角矩阵仅仅让基向量与某个特征值相乘。上一节的基变换，描述的是如何在另一个坐标系中表达当前坐标系所描述的变换。 $A^{-1}MA$ 取出你想用作新基的向量的坐标，在这里指的是两个特征向量，然后将坐标作为一个矩阵的列，这个矩阵就是基变换矩阵（ $M$ ），在右侧写下基变换矩阵（$A$），在左侧写下基变换矩阵的逆（$A^{-1}$），当你将原始的变换夹在两个矩阵中间时，所得的矩阵代表的是同一个变换，不过是从新基向量所构成的坐标系的角度来看的。 一组基向量（同样是特征向量）构成的集合被称为一组“特征基”。如果你要计算这个矩阵的n次幂，一种更容易的做法是先变换到特征基，在那个坐标系中计算n次幂，然后转换回标准坐标系。 13p 抽象向量空间 数学中有很多类似向量的事物。只要所处理对象，具有合理的数乘和加和概念，不管是空间中的箭头、一组数还是函数集合，线性代数中所有关于向量、线性变换和其他的概念都应该适用于它。这些类似向量的事物，它们构成的集合被称为向量空间。 在数学的表达中，我们倾向于得到用普适的概念，而普适的代价就是抽象。 14p 番外之伴随矩阵的几何意义 伴随矩阵 $A^{-1}$ 是求逆矩阵时 $A^{-1}$ 的一个过程量。为什么要费劲周折地求逆矩阵 $A^{-1}$ 呢，为了解方程。 $A\\vec x = \\vec b \\Rightarrow \\vec x = \\vec bA^{-1}$ 从上面公式可以看出，当经过 $A^{-1}$ 和 $A$ 的复合变换之后，新的向量空间与原来形状相似，但是拉伸为原来的 $|A|$ 倍, $A^{*}A = AA^{*} = |A|E$ 。\n伴随矩阵起的作用应该是将A对应的变换效果正规化，将所有维度变成同等层次。由上面的公式可以知道，这种正规化建立在对每个维度都扩展到原来的$|A|$ 倍（因为矩阵乘以一个数是针对矩阵中的每一个向量）。\n如果A中存在一个维度被压缩（即 $r(A) = n-1$，则 $|A|=0$ ,那么这种正规化将会把所有维度压缩为0，因为只有之前被 $A$ 压缩的维度无法继续被 $A^{*}$ 压缩，因此 $r(A^{*}) = 1$ 。\n如果A中存在多于一个维度被压缩（即 $r(A) \u0026lt; n-1$，则 $|A|=0$ ,那么这种正规化将会把所有维度压缩为0，因此 $r(A^{*}) = 0$ 。\n15p 番外之理解二次型 一般的，将含有 $N$ 个变量的的二次齐次函数成为二次型， $$ q_A(x_1,\\ldots,x_n) = \\sum_{i=1}^{n}\\sum_{j=1}^{n}a_{ij}{x_i}{x_j} = \\mathbf x^\\mathrm{T} A \\mathbf x $$\n称为二次型。二次型可以用矩阵表示，其中$\\matrix A$ 是对称矩阵。\n二次型讨论的主要问题是：寻求可逆的线性变换 $$ \\begin {cases} x_1 = c_{11}y_1+c_{12}y_{2}+\\ldots+c_{1n}y_{n},\\newline x_2 = c_{21}y_1+c_{22}y_{2}+\\ldots+c_{2n}y_{n},\\newline \\space\\space\\space\\space \\ldots\\ldots\\ldots\\ldots\\newline x_n = c_{n1}y_1+c_{n2}y_{2}+\\ldots+c_{nn}y_{n}\\newline \\end {cases} $$ 使二次型只含有平方项 $$\\lambda_1 \\vec x_1^2 + \\lambda_2 \\vec x_2^2 + \\ldots + \\lambda_n \\vec x_n^2$$ 。\n把可逆变换记作 $\\mathbf x = \\matrix C\\mathbf y$ ,因此可以得到 $$ f = \\mathbf x^\\mathrm{T} A \\mathbf x = (\\matrix C\\mathbf y)^{T}\\mathbf A \\mathbf (\\matrix C\\mathbf y) = \\mathbf y^{T}(\\matrix C\\mathbf A \\mathbf \\matrix C)\\mathbf y $$\n","permalink":"https://oxygenbytes.github.io/posts/math/linearalgebra/","summary":"1p 什么是向量？ 定义坐标系 物理系，计算机系，数学系对向量的不同认识 向量可以是任何东西，只要保证两个向量相加以及数字与向量想成是有意义的即可。 可","title":"线性代数的本质"},{"content":" 传输层：TCP和UDP 什么是三次握手？ 什么是四次挥手？ TCP如何实现流量控制？ TCP的拥塞控制是怎么实现的？ TCP与UDP的区别 TCP如何保证传输的可靠性 应用层：HTTP和HTTPS HTTP和HTTPS有什么区别？ GET与POST的区别？ Session与Cookie的区别？ 从输入网址到获得页面的过程 (越详细越好)？ HTTP请求有哪些常见状态码？ 什么是RIP (距离矢量路由协议)? 计算机网络体系结构 网络层协议 IP地址的分类？ 什么叫划分子网？ 什么是ARP协议？ 什么是NAT (网络地址转换)？ 什么是三次握手 (three-way handshake)？ 第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态； 第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态； 第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。 TCP建立连接可以两次握手吗？为什么? 不可以。有两个原因： 首先，可能会出现已失效的连接请求报文段又传到了服务器端。\nclient 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。\n其次，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。\n可以采用四次握手吗？为什么？ 可以。但是会降低传输的效率。 四次握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。\n第三次握手中，如果客户端的ACK未送达服务器，会怎样？ Server端：\n由于Server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。 Client端，两种情况：\n在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取 ACK number，进入 establish 状态 在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包应答。 如果已经建立了连接，但客户端出现了故障怎么办？ 服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。\n初始序列号是什么？ TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002\u0026hellip;三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。\n什么是四次挥手？ 第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态； 第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。 第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态； 第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。 因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。\n如果第二次挥手时服务器的ACK没有送达客户端，会怎样？ 客户端没有收到ACK确认，会重新发送FIN请求。\n客户端TIME_WAIT状态的意义是什么？ 第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。\nMSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。\nTCP如何实现流量控制？ 使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。\n发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。\n什么是零窗口（接收窗口为0时会怎样）？ 如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。\nTCP的拥塞控制是怎么实现的？ 拥塞控制主要由四个算法组成：慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）\n慢启动：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍\n拥塞避免：当拥塞窗口的大小达到慢开始门限(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS.\n无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。（这是不使用快重传的情况）\n快重传：快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。\n快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。\n也有的快重传是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3*MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些。\nTCP与UDP的区别 TCP是面向连接的，UDP是无连接的； UDP发送数据之前不需要建立连接\nTCP是可靠的，UDP不可靠；\nUDP接收方收到报文后，不需要给出任何确认\nTCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；\nTCP是面向字节流的，UDP是面向报文的； 面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。\nTCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；\nTCP首部开销（20字节）比UDP首部开销（8字节）要大\nUDP 的主机不需要维持复杂的连接状态表\n什么时候选择TCP，什么时候选UDP？ 对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失\nHTTP可以使用UDP吗？ HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠\n面向连接和无连接的区别 无连接的网络服务（数据报服务）\u0026ndash; 面向连接的网络服务（虚电路服务）\n虚电路服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证；\n数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃；\nTCP如何保证传输的可靠性 数据包校验 对失序数据包重新排序（TCP报文具有序列号） 丢弃重复数据 应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）； 超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据； 流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出 HTTP和HTTPS有什么区别？ 端口不同：HTTP使用的是80端口，HTTPS使用443端口； HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全； HTTPS由于加密解密会带来更大的CPU和内存开销； HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买 Https的连接过程？ 客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）； 服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，加密公钥（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）； 客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配； 如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个随机密钥（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行摘要计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器； 服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器； 浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密 总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。\n输入 www.baidu.com，怎么变成 https://www.baidu.com 的，怎么确定用HTTP还是HTTPS？ 一种是原始的302跳转，服务器把所有的HTTp流量跳转到HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。 解决方法是引入HSTS机制，用户浏览器在访问站点的时候强制使用HTTPS。\n什么是对称加密、非对称加密？区别是什么？ 对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4 非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA 区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥） 数字签名、报文摘要的原理 发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文。 摘要算法:MD5、SHA GET与POST的区别？ GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的； GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源； 请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中； 安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高； GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据； GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制 Session与Cookie的区别？ Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案\nCookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Sessionid查看状态。保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。\n从输入网址到获得页面的过程 (越详细越好)？ 浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询； 浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手； TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求； 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器； 浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源； 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。 HTTP请求有哪些常见状态码？ 2xx状态码：操作成功。200 OK 3xx状态码：重定向。301 永久重定向；302暂时重定向 4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found； 5xx状态码：服务端错误。500服务器内部错误；501服务不可用 什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？ 每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。\n（PS：RIP是应用层协议：https://www.zhihu.com/question/19645407）\n实现简单，开销小 随着网络规模扩大开销也会增大； 最大距离为15，限制了网络的规模； 当网络出现故障时，要经过较长的时间才能将此信息传递到所有路由器 计算机网络体系结构 Physical, Data Link, Network, Transport, Application 应用层：常见协议： FTP(21端口)：文件传输协议 SSH(22端口)：远程登陆 TELNET(23端口)：远程登录 SMTP(25端口)：发送邮件 POP3(110端口)：接收邮件 HTTP(80端口)：超文本传输协议 DNS(53端口)：运行在UDP上，域名解析服务 传输层：TCP/UDP 网络层：IP、ARP、NAT、RIP\u0026hellip; 路由器、交换机位于哪一层？\n路由器网络层，根据IP地址进行寻址； 交换机数据链路层，根据MAC地址进行寻址 IP地址的分类？ 路由器仅根据网络号net-id来转发分组，当分组到达目的网络的路由器之后，再按照主机号host-id将分组交付给主机；同一网络上的所有主机的网络号相同。\n什么叫划分子网？ 从主机号host-id借用若干个比特作为子网号subnet-id；子网掩码：网络号和子网号都为1，主机号为0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。\n什么是ARP协议 (Address Resolution Protocol)？ ARP协议完成了IP地址与物理地址的映射。每一个主机都设有一个 ARP 高速缓存，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就向所在的局域网发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。\n如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。\n什么是NAT (Network Address Translation, 网络地址转换)？ 用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。\n","permalink":"https://oxygenbytes.github.io/posts/linux/computernetwork/","summary":"传输层：TCP和UDP 什么是三次握手？ 什么是四次挥手？ TCP如何实现流量控制？ TCP的拥塞控制是怎么实现的？ TCP与UDP的区别 TCP如何保","title":"计算机网络中的经典问题"},{"content":"深搜和广搜是最重要的几种算法之一，理解深搜和广搜的关键在于理解 递归 ， 状态机 ， 容器适配器--堆\u0026amp;\u0026amp;栈 和 集合分类 四个概念。\n在搜索中，节点的状态有很多种(节点的状态此时主要根据操作来定义)，比如：未被访问的节点，被访问但是后续仍要用于寻找相邻节点的点，被访问并且后续不会被用到的点。其中，第二类点仍有使用的必要，因此将之放入特定容器，也就是队列或者栈。\n深度优先搜索 深度优先搜索是一种用于遍历或搜索图或者树的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。\n// 深度优先搜索 vector\u0026lt;int\u0026gt; G[MAX]; bool visit[MAX]; stack\u0026lt;int\u0026gt; stack; void DFS(int u){ visit[u] = 1; for(int i = 0;i \u0026lt; G[u].size();i++){ // 邻接关系 int v = G[u][i]; if(!visit[v]){ DFS(v); } } } void Dfs(int u){ visit[u] = 1; stack.push(u); while(!stack.empty()){ int u = stack.top(); stack.pop(); for(int i = 0;i \u0026lt; G[u].size();i++){ // 邻接关系 int v = G[u][i]; if(!visit[v]){ visit[v] = 1; stack.push(v); } } } } 深度搜索的逻辑是这样的：将被访问但是后续仍要用于寻找相邻节点的点存入栈容器，这样的话，最先被访问的节点将是最后用于寻找相邻节点的点。也就实现了所谓的回溯。\n| A B C D E F G H I\n\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\u0026gt; 访问顺序\n| A B C D E F G H I\n\u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;- 寻找邻接点的顺序\n广度优先搜索 广度优先搜索算法（英语：Breadth-First-Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。属于盲目搜索。\n// 深度优先搜索 vector\u0026lt;int\u0026gt; G[MAX]; bool visit[MAX]; stack\u0026lt;int\u0026gt; stack; void DFS(int u){ visit[u] = 1; for(int i = 0;i \u0026lt; G[u].size();i++){ // 邻接关系 int v = G[u][i]; if(!visit[v]){ DFS(v); } } } void Dfs(int u){ visit[u] = 1; stack.push(u); while(!stack.empty()){ int u = stack.top(); stack.pop(); for(int i = 0;i \u0026lt; G[u].size();i++){ // 邻接关系 int v = G[u][i]; if(!visit[v]){ visit[v] = 1; stack.push(v); } } } } 广度搜索的逻辑是这样的：将被访问但是后续仍要用于寻找相邻节点的点存入队列容器，这样的话，最先被访问的节点将是最先用于寻找相邻节点的点。\nA B C D E F G H I\n\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\u0026gt; 访问顺序\nA B C D E F G H I\n\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash;\u0026gt; 寻找邻接点的顺序\n","permalink":"https://oxygenbytes.github.io/posts/algorithms/bfsdfs/","summary":"深搜和广搜是最重要的几种算法之一，理解深搜和广搜的关键在于理解 递归 ， 状态机 ， 容器适配器--堆\u0026amp;\u0026amp;栈 和 集合分类 四个概念。 在搜索","title":"深搜\u0026\u0026广搜"},{"content":"内存模型所要表达的内容主要是这么描述： 一个内存操作的效果，在其他线程中的可见性问题。\nC++ 内存模型 C分为四个区：堆，栈，静态全局变量区，常量区\nC++内存分为5个区域（堆栈全常代）：\n堆 heap ： 由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露” 栈 stack ： 是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。 存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。 全局/静态存储区 （.bss段和.data段） ： 全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。 常量存储区 （.rodata段） ： 存放常量，不允许修改（通过非正当手段也可以修改） 代码区 （.text段） ： 存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区） 根据c/c++对象生命周期不同，c/c++的内存模型有三种不同的内存区域，即\n自由存储区，动态区、静态区。 自由存储区：局部非静态变量的存储区域，即平常所说的栈 动态区： 用operator new ，malloc分配的内存，即平常所说的堆 静态区：全局变量 静态变量 字符串常量存在位置 而代码虽然占内存，但不属于c/c++内存模型的一部分\n各个段的关系 一个正在运行着的C编译程序占用的内存分为代码区、初始化数据区、未初始化数据区、堆区 和栈区5个部分。\n（1）代码区（text segment）。代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需 要借助栈来实现。\n代码区的指令中包括操作码和要操作的对象（或对象地址引用）。如果是立即数（即具体的数值，如5），将直接包含在代码中；如果是局部数据，将在栈区 分配空间，然后引用该数据地址；如果是BSS区和数据区，在代码中同样将引用该数据地址。\n（2）全局初始化数据区/静态数据区（Data Segment）。只初始化一次。\n（3）未初始化数据区（BSS）。在运行时改变其值。\n（4）栈区（stack）。由编译器自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。每当一个函数被调用，该函 数返回地址和一些关于调用的信息，比如某些寄存器的内容，被存储到栈区。然后这个被调用的函数再为它的自动变量和临时变量在栈区上分配空间，这就是C实现 函数递归调用的方法。每执行一次递归函数调用，一个新的栈框架就会被使用，这样这个新实例栈里的变量就不会和该函数的另一个实例栈里面的变量混淆。\n（5）堆区（heap）。用于动态内存分配。堆在内存中位于bss区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时有可能由OS 回收。\n之所以分成这么多个区域，主要基于以下考虑：\n一个进程在运行过程中，代码是根据流程依次执行的，只需要访问一次，当然跳转和递归有可能使代码执行多次，而数据一般都需要访问多次，因此单独开辟 空间以方便访问和节约空间。 临时数据及需要再次使用的代码在运行时放入栈区中，生命周期短。 全局数据和静态数据有可能在整个程序执行过程中都需要访问，因此单独存储管理。 堆区由用户自由分配，以便管理。\n下面通过一段简单的代码来查看C程序执行时的内存分配情况。相关数据在运行时的位置如注释所述。\n//main.cpp int a = 0; //a在全局已初始化数据区 char *p1; //p1在BSS区（未初始化全局变量） main() { int b; //b在栈区 char s[] = \u0026#34;abc\u0026#34;; //s为数组变量，存储在栈区， //\u0026#34;abc\u0026#34;为字符串常量，存储在已初始化数据区 char *p1，*p2; //p1、p2在栈区 char *p3 = \u0026#34;123456\u0026#34;; //123456\\0在已初始化数据区，p3在栈区 static int c =0； //C为全局（静态）数据，存在于已初始化数据区 //另外，静态数据会自动初始化 p1 = (char *)malloc(10);//分配得来的10个字节的区域在堆区 p2 = (char *)malloc(20);//分配得来的20个字节的区域在堆区 free(p1); free(p2); } C++内存配置器 标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。\nnew有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一起。类似的，delete将对象析构和内存释放组合在了一起。我们分配单个对象时，通常希望将内存分配和对象初始化组合在一起。因为在这种情况下，我们几乎肯定知道对象应有什么值。当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象的创建操作(同时付出一定开销)。一般情况下，将内存分配和对象构造组合在一起可能会导致不必要的浪费。\n标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。类似vector，allocator是一个模板。为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; using namespace std; //先熟悉一下提供的allocator用法 int main(int argc, char const *argv[]) { allocator\u0026lt;int\u0026gt; a; int *ptr=a.allocate(5); a.construct(ptr,3); a.construct(ptr+1,-3); a.construct(ptr+2,3); a.construct(ptr+3,-3); a.construct(ptr+4,3); for(int i=0;i\u0026lt;5;i++) { cout\u0026lt;\u0026lt;*(ptr+i)\u0026lt;\u0026lt;\u0026#34; \u0026#34;; a.destroy(ptr+i); } a.deallocate(ptr,5); return 0; } 内存屏障 内存屏障 CPU乱序执行在单线程环境下是一种很好的优化手段，但是在多线程环境下，就会出现数据不一致的问题，因此就可以通过内存屏障这个机制来处理这个问题。\n1.写内存屏障(Store Memory Barrier)：在指令后插入Store Barrier，能让写入缓存中最新数据更新写入主内存中，让其他线程可见。强制写入主内存，这种显示调用，不会让CPU去进行指令重排序 2.读内存屏障(Load Memory Barrier)：在指令后插入Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存中加载数据。也是不会让CPU去进行指令重排。\n","permalink":"https://oxygenbytes.github.io/posts/cplus/c++%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","summary":"内存模型所要表达的内容主要是这么描述： 一个内存操作的效果，在其他线程中的可见性问题。 C++ 内存模型 C分为四个区：堆，栈，静态全局变量区，常量区 C","title":"C++内存模型"},{"content":"const常引用（const + \u0026amp;）避免函数参数的双向传递 在c++可以使用引用传递作为函数的形参传入函数，相较于值传递的方式，引用传递能够节省函数使用时的内存分配，不需要像值传递一样拷贝实参。对于普通的数据类型可能看出引用的优势，但是如果函数的传入参数是一个十分复杂的结构体或者类，那么引用传递可以节省很大的内存开销。\n然而，由于引用传递是双向的，当在函数中对于形参的数据进行改变后，实参的值也会进行相应的改变，如下所示：\n#include \u0026lt;iostream\u0026gt; using namespace std; struct Point { int x; int y; Point(int a, int b) { x=a; y=b; } }; void fun(Point\u0026amp; point); int main() { Point point(1,1); fun(point); point.x++; point.y++; cout \u0026lt;\u0026lt; \u0026#34;======main======\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;点的坐标为(\u0026#34; \u0026lt;\u0026lt; point.x \u0026lt;\u0026lt; \u0026#34;.\u0026#34; \u0026lt;\u0026lt; point.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; return 0; } void fun(Point\u0026amp; point) { point.x++; point.y++; cout \u0026lt;\u0026lt; \u0026#34;======fun======\u0026#34; \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;点的坐标为(\u0026#34; \u0026lt;\u0026lt; point.x \u0026lt;\u0026lt; \u0026#34;,\u0026#34; \u0026lt;\u0026lt; point.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34; \u0026lt;\u0026lt; endl; } /* ------fun------- 点的坐标为（2,2） ------main------ 点的坐标为(2,3) 如果我们既不想改变传入参数的值，也不想因为值传递产生太大的开销，那么可以尝试一下使用常引用。可见，使用了常引用之后，传入参数的值就是一个常量了，无法对其内部变量进行修改，保证了传入参数的数据安全性。\n这里引用的作用主要是为了避免值传递，值传递通常会有很大的开销。\nC语言三个结束符有什么不同？ EOF ‘\\0’ \u0026lsquo;\\n\u0026rsquo; 网友A: EOF（End of file）是C/C++里面的宏定义，具体定义式是#define EOF -1，表示的是文件的结束标志，值等于-1，一般用在文件读取的函数里面，比如fscanf fgetc fgets等，一旦读取到文件最后就返回EOF标志并结束函数调用 \u0026lsquo;\\0\u0026rsquo;是转义字符，值等于0，主要用在C风格字符串的末尾，表示字符串结束标志。通常用在和字符串相关的函数里面，如strcmp strcpy等会用到它 \u0026lsquo;\\n\u0026rsquo;表示换行符，通常用作一些读取函数的读取结束标志，比如scanf,getchar(),gets()等，一旦遇到\u0026rsquo;\\n\u0026rsquo;就结束读取并返回\n网友B: EOF 是一个宏定义,一般是-1,用在读文件的时候.因为如果读到字符,这个字符的值一定是正的,所以用负值表示结束 \\0 是ascii码为0,一般表示用在字符串结尾表示空值.一个char a[100]数组,当你用这个数组进行字符串操作时,会把\\0当做结尾.如果没有设置\\0标志,这个字符串很可能出现问题 \\n 好像ascii码是10吧,就是回车的意思,a是1个字符,c也是1个字符,同样的,回车也是1个字符,只不过表现得不那么正常而已\nextern \u0026ldquo;C\u0026rdquo; #ifndef __INCvxWorksh /*防止该头文件被重复引用*/ #define __INCvxWorksh #ifdef __cplusplus //__cplusplus是cpp中自定义的一个宏 extern \u0026#34;C\u0026#34; { //告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的 #endif /**** some declaration or so *****/ #ifdef __cplusplus } #endif #endif /* __INCvxWorksh */ 2、被extern \u0026ldquo;C\u0026quot;修饰的变量和函数是按照C语言方式编译和链接的 首先看看C++中对类似C的函数是怎样编译的。 作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为： void foo( int x, int y ); 该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）。 ** _foo_int_int这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。** 例如，在C++中，函数void foo( int x, int y )与void foo( int x, float y )编译生成的符号是不相同的，后者为_foo_int_float。 同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以\u0026rdquo;.\u0026ldquo;来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。\nwhile(scanf(\u0026quot;%d\u0026rdquo;,\u0026amp;n)!=EOF) 用法 EOF(end of file)就是文件的结束，通常来判断文件的操作是否结束的标志。\nEOF不是特殊字符，而是定义在头文件\u0026lt;stdio.h\u0026gt;的常量，一般等于-1；\n#include\u0026lt;stdio.h\u0026gt; int main(){ char str[100][100]; int i=0,j; while(scanf(\u0026#34;%s\u0026#34;, str[i]) != EOF) //在黑框中手动输入时，系统并不知道什么时候到达了所谓的“文件末尾“ //因此需要用\u0026lt; Ctrl + Z \u0026gt;组合键，然后按\u0026lt; Enter \u0026gt;键的方式来告诉系统已经到了 EOF，这样系统才会结束 while i++; //while((str[i]=getchar())!=\u0026#39;\\n\u0026#39;) for(j=i-1;j\u0026gt;=0;j--){ printf(\u0026#34;%s\u0026#34;,str[j]); if(j!=0) printf(\u0026#34; \u0026#34;); } return 0; } 除了文件结束，做题遇见最多的是标准输入，但是标准输入与文件不一样，无法事先知道输入的长度，必须手动输入一个字符，表示到达EOF：\nLinux中，在新的一行的开头，按下Ctrl-D，就代表EOF（如果在一行的中间按下Ctrl-D，则表示输出“标准输入”的缓存区，所以这时必须按两次Ctrl-D）；\nWindows中，Ctrl-Z表示EOF。 结构体可以用作 map 的键吗？ 答： 可以，结构体是可以作为 map 的键的，但需要满足一定的条件。首先 map 的底层结构是 红黑树 ，属于 平衡二叉查找树 。对于map来说， key必须是有序的， 也就是说， key与key之间必须能比较， 所以需要重载 \u0026lt; 号 。所以当结构体作为 map 的键时，必须要重载 \u0026lt; 运算符。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;map\u0026gt; using namespace std; struct Info { string name; int score; // 重载 \u0026lt; 运算符 bool operator\u0026lt; (const Info \u0026amp;x) const { return score \u0026lt; x.score; } }; int main() { Info a, b; a.name = \u0026#34;eric\u0026#34;; a.score = 90; b.name = \u0026#34;cat\u0026#34;; b.score = 85; map\u0026lt;Info, int\u0026gt; m; m[a] = 1; m[b] = 2; map\u0026lt;Info, int\u0026gt;::iterator it; for(it = m.begin(); it != m.end(); it++) { cout \u0026lt;\u0026lt; it-\u0026gt;first.name \u0026lt;\u0026lt; endl; } return 0; C++中虚函数表存储在什么位置？ C++中虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。\nC++中能不能在 main 前执行代码？ 答：可以。\n全局类变量的构造都在main之前。可以通过全局变量来在 main 前面执行代码。 static 标识符标记的全局变量在程序初始化阶段，先于 main 执行。 //全局static变量的初始化在程序初始阶段，先于main函数的执行，所以可以利用这一点。在leetcode里经常见到利用一点，在main之前关闭cin与stdin的同步来“加快”速度的黑科技： static int _ = []{ cin.sync_with_stdio(false); return 0; }(); //_attribute((constructor))是gcc扩展，标记这个函数应当在main函数之前执行。同样有一个__attribute((destructor))，标记函数应当在程序结束之前（main结束之后，或者调用了exit后）执行; 其实想一想 main 无非就是个入口点，只不过是更改入口点而已。\ntypedef 关键字wiki 在C和C++编程语言中，typedef是一个关键字。它用来对一个数据类型取一个别名，目的是为了使源代码更易于阅读和理解。它通常用于简化声明复杂的类型组成的结构 ，但它也常常在各种长度的整数数据类型中看到，例如size_t和time_t。\ntypedef的语法是 :\ntypedef typedeclaration; 和结构体一起使用 typedef struct Node Node; struct Node { int data; Node *nextptr; }; 和指针一起使用 typedef int *intptr; intptr cliff, allen; // both cliff and allen are int* type intptr cliff2, *allen2; // cliff2 is int* type, but allen2 is int** type // same as: intptr cliff2; // intptr *allen2; 和结构体指针一起使用 typedef struct Node Node; struct Node { int data; Node *nextptr; }; 和函数指针一起使用 先来看这段没有使用typedef的代码：\nint do_math(float arg1, int arg2) { return arg2; } int call_a_func(int (*call_this)(float, int)) { int output = call_this(5.5, 7); return output; } int final_result = call_a_func(\u0026amp;do_math); 注意：这里的call_this是指向参数类型为(float, int) ,返回值是int类型的函数指针，另外注意函数指针的用法，\n使用typedef后这段代码可以改写为：\ntypedef int (*MathFunc)(float, int); int do_math(float arg1, int arg2) { return arg2; } int call_a_func(MathFunc call_this) { int output = call_this(5.5, 7); return output; } int final_result = call_a_func(\u0026amp;do_math); 前加一个typedef关键字，这样就定义一个名为MathFunc的函数指针类型，而不是一个MathFunc变量。\n指针 什么是指针？ 我们指知道：C语言中的数组是指 一类 类型，数组具体区分为 int 类型数组，double类型数组,char数组 等等。同样指针 这个概念也泛指 一类 数据类型，int指针类型，double指针类型，char指针类型等等。\n通常，我们用int类型保存一些整型的数据，如 int num = 97 ， 我们也会用char来存储字符： char ch = \u0026lsquo;a\u0026rsquo;。\n我们也必须知道：任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。\n因此：指针是程序数据在内存中的地址，而指针变量是用来保存这些地址的变量。\n指针本身也是一种数据类型\n为什么需要指针？ 指针解决了一些编程中基本的问题。\n第一，指针的使用使得不同区域的代码可以轻易的共享内存数据。当然你也可以通过数据的复制达到相同的效果，但是这样往往效率不太好，因为诸如结构体等大型数据，占用的字节数多，复制很消耗性能。但使用指针就可以很好的避免这个问题，因为任何类型的指针占用的字节数都是一样的（根据平台不同，有4字节或者8字节或者其他可能）。\n第二，指针使得一些复杂的链接性的数据结构的构建成为可能，比如链表，链式二叉树等等。\n第三，有些操作必须使用指针。如操作申请的堆内存。还有：C语言中的一切函数调用中，值传递都是“按值传递(pass by value)”的，如果我们要在函数中修改被传递过来的对象，就必须通过这个对象的指针来完成。\n什么是指针变量？ 指针变量是用来存放指针(地址)的变量。\nint c = 76; int *pointer; //此处int是指针变量的基类型，基类型就是指针变量指向的变量的类型 pointer = \u0026amp;c; //将变量c的地址赋值给指针变量pointer //赋值后，称指针变量pointer指向了变量c 指针运算符 *\n取址运算符\u0026amp;\n指针变量也是变量，是变量就有地址\n关于空指针 void*类型指针\n由于void是空类型，因此void类型的指针只保存了指针的值，而丢失了类型信息，我们不知道他指向的数据是什么类型的，只指定这个数据在内存中的起始地址，如果想要完整的提取指向的数据，程序员就必须对这个指针做出正确的类型转换，然后再解指针。因为，编译器不允许直接对void类型的指针做解指针操作。\n函数指针的几个疑惑 问题：c语言中， 函数名也称为函数的指针，那函数名是否也占内存空间？ 首先你上面的话是错误的，函数名是一段指令的入口地址，它是地址常量，不占用内存空间，只是在编译阶段存在于编译器的符号表中，例如函数的入口地址是0x123456，在翻译成机器指令以后，函数名是不存在的其在本质上对应汇编上的jump指令，在执行函数的时候，跳转到0x123456，这个函数名的本质就是这个地址。\nc语言中其他变量的原理也都是类似的\n#include \u0026lt;iostream\u0026gt; using namespace std; typedef int (*funcptr)(int, int); int add(int a,int b){ return a+b; } int test(funcptr ptr,int x, int y){ cout\u0026lt;\u0026lt;\u0026#34;this is a test\u0026#34;; return ptr(x, y); } int main(){ cout\u0026lt;\u0026lt;test(add,2,3)\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;test(\u0026amp;add,3,4)\u0026lt;\u0026lt;endl; cout\u0026lt;\u0026lt;\u0026amp;main; return 0; } 1）其实，MyFun的函数名与FunP函数指针都是一样的，即都是函数指针。MyFun函数名是一个函数指针常量，而FunP是一个函数数指针变量，这是它们的关系。\n2）但函数名调用如果都得如(*MyFun)(10)这样，那书写与读起来都是不方便和不习惯的。所以C语言的设计者们才会设计成又可允许MyFun(10)这种形式地调用（这样方便多了并与数学中的函数形式一样，不是吗？）。\n3）为统一起见，FunP函数指针变量也可以FunP(10)的形式来调用。\n4）赋值时，即可FunP = \u0026amp;MyFun形式，也可FunP = MyFun。\nC++的左值与右值 基本概念 左值与右值的概念在很多地方比较模糊，但其对我们对C++的理解很重要。比如我们看github上的源码的时候会看到std::move等用法，在查找其含义之后得知它功能是将左值转成右值引用，若是我们不理解左值与右值，还是无法知道它到底有什么用。\n我们还会经常在编译错误和警告信息中看到左值右值概念的出现。\n左值与右值的简单定义 lvalue(locator value), 即左值，代表一个在内存中占有确定位置的对象，换句话说就是有一个地址。\nrvalue：一个表达式要么是lvalue，要么是rvalue。所以，不是lvalue的表达式就是rvalue。\n左值是指表达式结束后依然存在的持久对象，右值是指表达式结束时就不再存在的临时对象。一个区分左值与右值的便捷方法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。\nC++ 11中用\u0026amp;表示左值引用，用\u0026amp;\u0026amp;表示右值引用 // Big Block // https://www.nowcoder.com/discuss/418915 #include \u0026lt;string\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { { std::string s = \u0026#34;1234\u0026#34;; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // \u0026#34;1234\u0026#34; } { std::string s = \u0026#34;1234\u0026#34;; std::move(s); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; // \u0026#34;1234\u0026#34; } { std::string s = \u0026#34;1234\u0026#34;; const auto\u0026amp; s1 = std::move(s); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; // \u0026#34;1234 1234\u0026#34; } { std::string s = \u0026#34;1234\u0026#34;; auto\u0026amp;\u0026amp; s1 = std::move(s); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; // \u0026#34;1234 1234\u0026#34; } { std::string s = \u0026#34;1234\u0026#34;; auto s1 = std::move(s); cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; endl; // \u0026#34; 1234\u0026#34; } return 0; } C++迭代器 #include \u0026lt;vector\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main(){ vector\u0026lt;int\u0026gt; v1; for(int i=0;i\u0026lt;100;i++){ if(i%3 ==0) v1.push_back(i); } vector\u0026lt;int\u0026gt;::iterator it; for(vector\u0026lt;int\u0026gt;::iterator it=v1.begin(); it != v1.end();it++){ *it += 2; cout\u0026lt;\u0026lt;*it\u0026lt;\u0026lt;endl; } return 0; } 注意迭代器的用法\n::不要丢掉，否则语法错误；迭代器的本质是指针，指针在使用之前一定要赋值\n小知识 c语言print()函数的参数 %d \u0026mdash;\u0026mdash;\u0026ndash;dicimal(base 10) %x \u0026mdash;\u0026mdash;\u0026ndash;hexadecimat(base 16) %o \u0026mdash;\u0026mdash;\u0026ndash;octal(base 8) ","permalink":"https://oxygenbytes.github.io/posts/cplus/c++%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","summary":"const常引用（const + \u0026amp;）避免函数参数的双向传递 在c++可以使用引用传递作为函数的形参传入函数，相较于值传递的方式，引用传递","title":"C++基础知识"},{"content":"使用cin来读取数据 ​cin 基本用法\n​cin遇到缓冲区中的[enter],[space],[tab]会结束当前输入，并舍弃[enter],[space],[tab]，继续下一项输入，当有连续[space],[enter,[tab]会全部舍弃。\n使用getchar()来输入字符 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ char c; cout\u0026lt;\u0026lt;\u0026#34;enter a sentence:\u0026#34;\u0026lt;\u0026lt;endl; while(c=getchar()) cout\u0026lt;\u0026lt;c; return 0; } getchar不跳过任何字符，包括终止字符Ctrl + D，严格按照函数个数读入字符\n使用cin.get()输入字符 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ char c; cout\u0026lt;\u0026lt;\u0026#34;enter a sentence:\u0026#34;\u0026lt;\u0026lt;endl; while((c=cin.get()) != EOF) cout\u0026lt;\u0026lt;c; return 0; } cin.get()会读取除了终止字符Ctrl + Z ，Ctrl + D外的任何字符\n使用cin.get()读取字符串 cin.get(ch,10,\u0026#39;\\n\u0026#39;); // 读取10-1个字符（包括空格），赋值给特定的字符数组 // 如果在读取10-1个字符之前，遇到制定的终止字符\u0026#39;\\n\u0026#39;,则提前停止读取 // 读取成功返回非0值（真），失败返回0值（假） 使用cin.getline()函数读入整行字符串 getline()和get()的区别\ngetline遇到终止字符标志时结束，缓冲区文件指针移到终止字符之后\nget遇到终止字符后停止读取，缓冲区文件指针不移动\ncin.get()\t\u0026mdash;\u0026gt; we are family;\ncin.getline() \u0026mdash;\u0026gt; we are faily;\n一个需要特别关注的程序 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; int main(){ char s[10][10]; int n = 0; cin\u0026gt;\u0026gt;n; //cin.get(); 程序正常！ for(int i = 0;i \u0026lt; n;i++){ cin.getline(a[i],10); } for(int i = 0;i \u0026lt; n;i++){ cout\u0026lt;\u0026lt;a[i]\u0026lt;\u0026lt;endl; } return 0; } 3 sunday monday tuesday sunday monday //少了一行，因为n读入后的换行被cin.getline()读取了 ","permalink":"https://oxygenbytes.github.io/posts/cplus/c++%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","summary":"使用cin来读取数据 ​cin 基本用法 ​cin遇到缓冲区中的[enter],[space],[tab]会结束当前输入，并舍弃[enter],[","title":"C++输入输出"},{"content":"课程链接\n基本语法知识 \u0026lt;iostream\u0026gt; 尖括号是使用标准头文件\n\u0026ldquo;matrix.h\u0026rdquo; 调用自给定头文件\n构造函数可以重载(overload)\n对于没有用到指针的类，一般不用写析构函数\n构造函数可以放在private里，这就是设计模式中的单例模式(singleton)\nclass Singleton { private: Singleton(); public: static Singleton\u0026amp; instance() { static Singleton INSTANCE; return INSTANCE; } }; 常量成员函数 将const关键字放在函数声明之后,意在强调该函数不可以改变其参数，只有成员函数才可以。\nclass Complex{ double re; double im; double real() const {return re}; double imag() return {return im}; }; { Complex c1(2,1); cout\u0026lt;\u0026lt;c1.real()\u0026lt;\u0026lt;endl; //right const Complex c2(2,1); cout\u0026lt;\u0026lt;c2.imag()\u0026lt;\u0026lt;endl; //wrong } C++引用其底层就是指针，但是这里做了封装 引用既可以作为函数参数，用以避免参数的复制，也可以用于对参数进行改变\n如果不想更改参数值，但是又想避免复制带来的开销，可以使用常引用， 即const ListNode\u0026amp;\nC++引用除了可以作为函数参数，还可以用作返回值，其目的与用作参数一致\nreturn by reference 不能使用的情况：返回值是函数局部变量，函数结束时候该变量被释放\nfriend关键字 friend函数可以自由的取得对应类的private数据\n相同class的各个objects互为friends\nc++防御式声明 #ifndef __COMPLEX__ #define __COMPLEX__ #endif inline关键字 在C/C++中，內联（inline）指的是在使用函数的地方不进行函数调用，而是将函数的实现代码插入到此处。 这样能够以增加代码大小为代价，省下函数调用过程产生的开销，加快程序执行速度。 內联属于编译器的一个优化措施，而inline关键字就是用来告诉编译器，希望对指定的函数做內联优化。\n所谓“希望”，意思就是这仅仅是程序员对编译器的优化建议，并不能强制编译器必须将指定的函数內联。 因此，如果一定要将一个函数內联，用inline关键字是不行的，需要使用编译器扩展或配合编译器优化选项。\n返回引用 当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。\n函数返回引用的时候，可以利用全局变量（作为函数返回），或者在函数的形参表中有引用或者指针（作为函数返回），这两者有一个共同点，就是返回执行完毕以后，变量依然存在，那么返回的引用才有意义。\n当不希望返回的对象被修改的时候，可以添加const。\na reference is a pointer which will auto dereference. 引用是自带解引用的指针(reference=*ptr)\n引用使用时无需解引用(*)，指针需要解引用；\n​ “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；\n​ 引用不能为空，指针可以为空；\n​ 指针和引用的自增(++)运算意义不一样；引用自增被引用对象的值，指针自增内存地址。\n友元函数 类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。\n友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。\n如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 friend\nstrlen的实现原理和计数方法 strlen所作的是一个计数器的工作，它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，直到碰到第一个字符串结束符\u0026rsquo;\\0\u0026rsquo;为止，然后返回计数器值(长度不包含\u0026rsquo;\\0\u0026rsquo;)。\nc++深拷贝和浅拷贝 C++中类的拷贝有两种：深拷贝，浅拷贝：当出现类的等号赋值时，即会调用拷贝函数 两个的区别 1 在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。 2 深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。\n重载\u0026laquo;符号 class String{ public: char* get_c_str() const {return m_data}; private: char* m_data; } ostream\u0026amp; operator\u0026lt;\u0026lt; (ostream\u0026amp; os, const String\u0026amp; str){ // 对于运算符重载的两个参数，第一个在运算符前，第二个在运算符后 // 对于此函数而言，os \u0026lt;\u0026lt; str; os \u0026lt;\u0026lt; str.get_c_str(); return os; // 这里返回os可以保证连续使用运算符 cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;b // 先执行cout\u0026lt;\u0026lt;a ==\u0026gt; cout,然后执行cout\u0026lt;\u0026lt;b } { String s1{\u0026#34;hello \u0026#34;}; cout \u0026lt;\u0026lt; s1; // cout是一个ostream对象 } 堆，栈，内存管理 stack：当你调用函数，函数本身就会形成一个stack用来放置参数，返回地址，局部变量等。\nheap: （system heap） 由操作系统分配的一块全局内存空间。程序可以动态分配后从中获得若干区块。\na. 局部变量，对象放置在stack中，当作用域结束其内存就会自动释放。\nb. 静态变量/全局变量，保存在静态区中，使用static 关键字或写在任何作用域之外，作用域结束之后仍存在，直到程序结束。\nc. 通过new 申请的的变量，对象会被保存在堆中，只有当使用 delete 函数之后其内存才会被释放。\nnew 关键字的实现原理：先分配内存（底层通过malloc实现），然后调用对象的构造函数。delete 关键字的实现原理：先调用对象的析构函数，然后释放内存（底层通过free实现）。\n动态分配所得的内存块（VC）\n动态分配的内存块\nstatic关键字\n作用\n修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。 修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。 修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。 修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。 static member functions 只能处理 static member data\n类模板 template\u0026lt;typename T\u0026gt; class complex{ // 类模板，作为一系列类的模板 public: complex(T r = 0,T i = 0) : re(r), im(i) { } private: T re,im; }; complex\u0026lt;int\u0026gt; //模板类 ，将类模板具体化得到的类叫做模板类 template\u0026lt;typename T\u0026gt; inline const T\u0026amp; min(const T\u0026amp; a, const T\u0026amp; b){ return b \u0026lt; a ? b : a; } class Stone{ public: bool operator\u0026lt; (const stone\u0026amp; rhs) const {return _weight \u0026lt; rhs._weight;} private: int _weight; }; stone r1(2,3),r2(3,3),r3; r3 = min(r1,r2); // 函数模板无需特殊写明，编译会自动进行类型推导 命名空间 namespace std // 命名空间声明 { } using namespace std; // 使用方式 int main{ cout\u0026lt;\u0026lt;a; std::cout\u0026lt;\u0026lt;a; } 面向对象设计\u0026ndash;三大特性\na. 封装 (has-a)\nb. 继承 (is-a)\nc. 多态(virtual function)\n面向对象设计原则 面向对象设计原则（1）\n依赖倒置原则（DIP）\n高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）。 抽象（稳定）不应该依赖于变化），实现细节应该依赖于抽象（稳定）。 面向对象设计原则（2）\n开放封闭原则（OCP）\n对扩展开放，对更改封闭。 类模块应该是可扩展的，但是不可修改。 面向对象设计原则（3）\n单一职责原则（SRP）\n一个类应该仅有一个引起它变化的原因。 变化的方向隐含着类的责任。 面向对象设计原则（4）\nLiskov 替换原则（LSP）\n子类必须能够替换它们的基类（IS-A）。 继承表达类型抽象。 面向对象设计原则（5）\n接口隔离原则（ISP）\n不应该强迫客户程序依赖它们不用的方法。 接口应该小而完备。 面向对象设计原则（6）\n优先使用对象组合，而不是类继承\n类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 继承在某种程度上破坏了封装性，子类父类耦合度高。 而对象组合则只要求被组合的对象具有良好定义的接口，度低。 面向对象设计原则（7）\n封装变化点\n使用封装来创建对象之间的分界层，让设计者可以在分界的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。\n面向对象设计原则（8）\n针对接口编程，而不是针对实现编程\n不将变量类型声明为某个特定的具体类，而是声明为某个接口。 客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。\n转换函数 #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; // Conversion function class Fraction // 分数类 { public: Fraction(int num,int den = 1) : son(num),mum(den) {} // 将Fraction类转化为double operator double() const{ // 转换函数，无需返回类型 return (double) (son / mum); } private: int son; int mum; }; int main(){ Fraction f(10,2); cout\u0026lt;\u0026lt;(double)f\u0026lt;\u0026lt;endl; return 0; } Non-explicit-one-argument ctor class Fraction // 分数类 { public: Fraction(int num,int den = 1) : son(num),mum(den) {} Fraction operator+ (const Fraction\u0026amp; f) { return Fracton(...); } private: int son; int mum; }; int main(){ Fraction f(3,4); Fraction d2=f+4; // 调用non-explicit ctor将4转换为Fraction，并调用operator+ } explict关键字 class Fraction { public: // 当使用explict的时候，说明只有在构造函数被显式调用的时候，才会进行自动转换 explict Fraction(int num,int den = 1) : son(num),mum(den) {} private: int son; int num; } int main(){ Fraction f(3,5); Fraction d2=f+4; } C++智能指针(pointer-like classes) template\u0026lt;typename T\u0026gt; // 智能指针是一个类模板 class shared_ptr{ public: T\u0026amp; operator*() const // 重载*操作符 { return *px;} T* operator-\u0026gt;() const // 重载-\u0026gt;操作符 { return px;} // -\u0026gt; 具有连续传递性，见下 shared_ptr(T* p) : px(p) {} private: T* px; long* pn; }; struct Foo{ void method(void) {} }; int main(){ shared_ptr\u0026lt;Foo\u0026gt; sp{new Foo}; Foo f(*sp); sp-\u0026gt;method; // [sp-\u0026gt;]method == [px]-\u0026gt;method } 迭代器也是一种特殊的智能指针，同时迭代器还要比一般的智能指针重载 ++ , -- 等运算符，同时对 * , -\u0026gt; 运算符要进行特殊的重载。\n// cpp list容器的迭代器 -- 双向链表 reference operator*() const { return (*node).data;} // 指针*直接返回数据 pointer operator-\u0026gt;() const { return \u0026amp;(operator*());} function like classes // 仿函数 template \u0026lt;typename T\u0026gt; struct identity ：public unary_function\u0026lt;T,T\u0026gt;{ const T\u0026amp; operator() (const T\u0026amp; x) const { return x;} }; // 仿函数的基类 template\u0026lt;class Arg, class Result\u0026gt; // 单操作数基类 struct unary_function { typedef Arg argument_type; typedef Result result_type; }; 函数对象要重载() 操作符。\nnamespace 经验谈 namespace testspace{ void test_member_template(){} } int main(){ testspace::test_member_template(); } 成员模板 template \u0026lt;class T1, class T2\u0026gt; struct pair { T1 first; T2 second; // 以下为成员模板 template\u0026lt;class U1,class U2\u0026gt; pair(const pair\u0026lt;U1,U2\u0026gt;\u0026amp; p){ // U1,U2要满足的条件 first(p.first),second(p.second); } }; pair\u0026lt;Base1,Base2\u0026gt; p2(pair\u0026lt;Derived1,Derived2\u0026gt;()); 模板特化 // 泛化 template \u0026lt;class Key\u0026gt; struct hash {}; // 特化1 template\u0026lt;\u0026gt; struct hash\u0026lt;char\u0026gt; { // ... size_t operator() (char x) const { return x;} } // 特化2 template\u0026lt;\u0026gt; struct hash\u0026lt;int\u0026gt; { // ... size_t operator() (int x) const (return x;) } int main(){ cout\u0026lt;\u0026lt; hash\u0026lt;int\u0026gt;()/*调用特化2 operator()*/(100)/* init parm*/ \u0026lt;\u0026lt; endl; } 模板偏特化 template\u0026lt;typename T,typename Alloc=...\u0026gt; class vector { //... }; //将T绑定到bool template\u0026lt;typename Alloc=...\u0026gt; class vector\u0026lt;bool, Alloc\u0026gt; { // ... } 模板模板参数 template\u0026lt;typename T, template\u0026lt;typename T\u0026gt; class Container \u0026gt; class XCls { private: Container\u0026lt;T\u0026gt; c; public: // ... }; template\u0026lt;typename T\u0026gt; using Lst = list\u0026lt;T, allocator\u0026lt;T\u0026gt;\u0026gt;; /* WRONG */ XCls\u0026lt;string,list\u0026gt; mylist1; // list未绑定 /* RIGHT */ XCls\u0026lt;string,Lst\u0026gt; mylist2; // Lst仍然是一个类模板 下面这个不是模板模板参数\ntemplate \u0026lt;class T,class Seqence = deque\u0026lt;T\u0026gt;\u0026gt; class stack { friend bool operator== \u0026lt;\u0026gt; (const stack\u0026amp;,const statck\u0026amp;); protected: Sequence c; }; stack\u0026lt;int,list\u0026lt;int\u0026gt;\u0026gt; s2; // list的类型已经绑定 vptr \u0026amp;\u0026amp; vtbl class A{ public: virtual void vfunc1(); virtual void vfunc2(); private: int m_data1,m_data2; }; class B : public A{ public: virtual void vfunc1(); // override }; 当某个类具有虚函数的时候，那么其生成的类就会有一个指针，会指向一个虚函数表，这个指针就是vptr。虚函数表就是vtbl。\nC++动态绑定 静态绑定的形式\ncall xxx ，其中xxx是地址。 动态绑定的条件\n通过指针调用。包括this指针。 有向上转型的动作。 调用虚函数。 // B继承A A* pa = new B; pa-\u0026gt;vfunc1(); //vfunc1是虚函数 new \u0026amp;\u0026amp; delete操作符重载 全局性重载，影响层面极广\nvoid* myAlloc(size_t size){ return malloc(size); } // 全局性重载1，影响层面极广 void* myfree(void* ptr){ return free(ptr); } inline void* operator new(size_t size){ cout\u0026lt;\u0026lt;\u0026#34;my global new()\u0026#34;\u0026lt;\u0026lt;endl; return myAlloc(size); } 重载成员函数中的new,delete,new[],delete[]\nclass Foo{ public: void* operator new[] (size_t); void* operator delete[](void*, size_t); }; try{ // 下面的1处 void* mem = operator new(sizeof(Foo)*N+4); p = static_cast\u0026lt;Foo*\u0026gt;(mem); p-\u0026gt;Foo::Foo(); // N次 } int main(){ // 1 Foo* p = new Foo[N]; } C++虚函数 基类的析构函数一定要写成虚函数，这样当进行多态调用的时候，才会执行基类的虚函数。\n容器适配器 C++ 提供了三种容器适配器(contain adapter): stack, queue, priority_queue。\nstack和queue基于deque实现 priority_queue基于vector实现 容器适配器的作用大概类似于电源适配器，将标准电压转化成各种需要的电压。\n你完全可以在deque上按照stack的方式工作，但是deque太强大了，它提供了远超stack的操作所需的各种接口 但凡你有一个失误，创建的栈就毁了。\n如何理解C++多态？ 多态的意义： 多态是面向对象的三大特性之一。\n面向对象的三大特性分别是：封装，继承，多态。\n多态的条件： 继承 重写父类方法 多态的本质： 多态：不同的子类调用相同的父类方法，产生不同的结果。函数有多个状态，即为多态。\n面向对象程序设计的一个重要特性是多态性，复习理解下C++ 是如何支持多态的。 接下来会涉及基类、派生类、虚函数、纯虚函数、抽象类的概念。\nC++ 的类继承中，被继承者被称为基类（base class），继承者被称为派生类（derived class）。指向派生类的指针类型与指向基类的指针类型是兼容的（反之不成立！）。这个简单的特性是C++ 多态性的基础。 (注意：可以用基类类型指针指向派生类类型的实例，反之不然）\n1，虚函数 我们面对一个问题：使用基类类型指针去引用派生类的成员时，这些成员必须也在基类中定义过。然而，一个基类的多个不同的派生类，对“同一个”成员函数的实现很可能是不一样的，因此，我们无法直接在基类中实现该成员函数。例如，对于基类“多边形”，派生类“正方形” 和 “三角形“对于成员函数”求面积“的实现是不同的。\n","permalink":"https://oxygenbytes.github.io/posts/cplus/%E4%BE%AF%E6%8D%B7c++%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/","summary":"课程链接 基本语法知识 \u0026lt;iostream\u0026gt; 尖括号是使用标准头文件 \u0026ldquo;matrix.h\u0026rdquo; 调用自给定头文件 构造函数可以重载(overload) 对于没有用到指针的类，一般不用写析构函数 构","title":"侯捷C++程序设计"},{"content":" 只要一个人明确地，诚挚地针对任何一个主题反思，那么这个人就必然可以和他周围的浮泛思想区隔开来。任何知性上的努力，都可以带我们脱离庸俗，它将引领我们穿越艰辛且隐蔽的道路，到达与世隔绝的境地。在那里，我们将发现自己浸淫在无数非凡的想法之中。这就是反思能够带给我们的结果。\n这些年，越来越觉得独立思考之可贵。开这个博客也是为了记录自己的思考和想法。这个博客是建在Github Page上的，我会在这里记录计算机方面的学习思考。但这个博客不会是一个纯粹的技术博客，它也会记录我在社会，艺术，科技，生活等方面的想法。\n正如苏格拉底所说：未经审视的生活不值得过。面对生活，希望我可以顽抗到底。\n学习方法论 重视问题 一个领域最重要，最活跃的东西是问题 独立思考 独立思考是解决问题的关键 主动检索 互联网是宝藏，Internet是最好的老师 重视媒介 书籍文字是最好的学习方式，缺点是慢，好书好文字需要筛选 文档是一种重要的媒介 图片是一种重要的描述关键内容的媒介 对于学习来说，视频是一种次等的媒介 知识的组织结构和知识内容本身同等重要 良好的知识组织，可以帮助人迅速的掌握知识内容，更可以加深对知识内容的理解 及时记录,对学习过程做充分的思考和记录 好记性不如烂笔头 笔记不一定要完美，但是要记录思考和想法 电子产品中的代码，文档，笔记要及时备份 不断学习 活到老，学到老 敢于折腾 生命在于折腾 学习不能一步到位，要逐环旋进 数学方法论 消元 变形 数形结合 普遍的代价是抽象 编程方法论 状态机 计算机本质上是一个状态机，内存存储的数据构成了当前的状态，CPU只能利用当前的状态计算出下一个状态。 使用计算机解决问题，就是在思考如何将这个问题表达成状态（用哪些变量存储哪些数据）以及如何在状态中转移（怎样根据一些变量计算出另一些变量）。 空间复杂度就是为了支持你的计算所必需存储的状态最多有多少，时间复杂度就是从初始状态到达最终状态中间需要多少步！ 数据结构组织决定算法设计 数组，链表是一切数据结构的最底层实现 数组，链表都是线性结构，可以看作是一维结构。 栈，队列，优先队列本质上是以不同顺序处理线性结构的一种抽象。 树和图本质上是一种二维的结构，处理二维数据结构，就像数学上的消元一样，核心方法是降维。从二维结构中抽象出一维结构，通过解决一维结构的问题，解决二维结构问题。 关心输入 输入提供了问题的规模和原始数据，也就是问题的状态表达，很多时候，要对输入做必要的限制和约束，处理极端情况。 编程是人利用计算机解决问题，不是计算机解决问题 计算机解决问题的办法就是暴力遍历解空间 优化解决办法的一个途径是对解空间进行分类，对不同的状态做不同的操作和处理 从集合的角度考虑问题 递归 递归本质上就像抛出悠悠球并回收，是一个双程。 递归代码最重要的两个特征：结束条件和自我调用。 递归函数要对不同的状态做不同的处理 缩小问题规模 信息应该充分利用 在解决问题的过程中，会有很多信息产生，要充分利用已经产生的信息来减少对未产生信息的计算。 典型的算法思想：回溯法\u0026amp;\u0026amp;分支限界法。二者本质上都是一致的，都是充分利用已经计算过的信息，来实现对树的剪枝。 回溯法利用回溯过的线路中的最优值对树的其他线路进行剪枝；分支限界法则是充分利用遍历过的树的上层信息来实现对树的下层信息的剪枝。 ","permalink":"https://oxygenbytes.github.io/about/","summary":"只要一个人明确地，诚挚地针对任何一个主题反思，那么这个人就必然可以和他周围的浮泛思想区隔开来。任何知性上的努力，都可以带我们脱离庸俗，它将引","title":"About Me"},{"content":"题目描述 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n\u0026gt;1并且m\u0026gt;1），每段绳子的长度记为k[0],k[1],\u0026hellip;,k[m]。请问k[0]xk[1]x\u0026hellip;xk[m]可能的最大乘积是多少？\n例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。\n题目分析 要让最大乘积最大，则当n \u0026gt; 5时，使用尽可能多的3。\n贪心算法 数学分析 $$ \\begin{matrix} if\\space x\\%3 \u0026amp;numOf2 \u0026amp;numOf3\\newline \\space\\space 0 \u0026amp; 0 \u0026amp; x/3\\newline \\space\\space 1 \u0026amp; 2 \u0026amp; x/3-1\\newline \\space\\space 2 \u0026amp; 1\u0026amp; x/3\\newline \\end{matrix} $$\n实现代码 public int cutRope2(int target) { if (target \u0026lt; 2) return 0; if (target == 2) return 1; if (target == 3) return 2; int numOf3 = target / 3; int numOf2 = 0; if (target % 3 == 1) { numOf3--; numOf2 = 2; } if(target % 3 == 2){ numOf2 = 1; } // int numOf2 = (target - numOf3*3) / 2; return (int) (Math.pow(2, numOf2) * Math.pow(3, numOf3)); } 递推算法 数学分析 $$ f(n)= \\begin{cases} f(n-3), \u0026amp; \\text{if $n$ \u0026gt; 6}\\newline [1,2,4,6],\u0026amp; \\text{if n = 2,3,4,5} \\end{cases} $$\n实现代码 public int cutRope(int target) { int n = 60; int[] dp = new int[n+1]; dp[2] = 1;dp[3] = 2; dp[4] = 4;dp[5] = 6; for(int i = 6;i \u0026lt;= 60;i++){ dp[i] = 3 * dp[i-3]; } return dp[target]; } 递归算法 数学分析 $$ f(n)= \\begin{cases} f(n-3), \u0026amp; \\text{if $n$ \u0026gt; 6}\\newline [1,2,4,6],\u0026amp; \\text{if n = 2,3,4,5} \\end{cases} $$\n实现代码 public class Solution { public int cutRope(int target) { if (target == 2) return 1; if (target == 3) return 2; if(target == 4) return 4; if(target == 5) return 6; return cutRope(target - 3) * 3; } } ","permalink":"https://oxygenbytes.github.io/posts/algorithms/cutrode/","summary":"题目描述 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n\u0026gt;1并且m\u0026gt;1），每段绳子的长度记为k[0],k[1","title":"剪绳子问题"}]