<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Zxq&#39;s Blog</title>
        <link>https://oxygenbytes.github.io/posts/</link>
        <description>Recent content in Posts on Zxq&#39;s Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <copyright>&lt;a href=&#34;https://oxygenbytes.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cd /home/zxq/&lt;/a&gt;</copyright>
        <lastBuildDate>Fri, 31 Dec 2021 00:52:39 +0800</lastBuildDate>
        <atom:link href="https://oxygenbytes.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>Mysql基础知识</title>
            <link>https://oxygenbytes.github.io/posts/2021/12/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
            <pubDate>Fri, 31 Dec 2021 00:52:39 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/12/mysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
            <description>Mysql查询流程 - 基础架构 Mysql更新流程 - 日志系统 与查询流程不一样，更新流程涉及两个重要的日志模块，分别是redo log（重做日志）和 binlog（归档日志）。</description>
            <content type="html"><![CDATA[<h2 id="mysql查询流程---基础架构">Mysql查询流程 - 基础架构</h2>
<h2 id="mysql更新流程---日志系统">Mysql更新流程 - 日志系统</h2>
<p>与查询流程不一样，更新流程涉及两个重要的日志模块，分别是redo log（重做日志）和 binlog（归档日志）。</p>
]]></content>
        </item>
        
        <item>
            <title>百度春招面试复盘</title>
            <link>https://oxygenbytes.github.io/posts/2021/10/%E7%99%BE%E5%BA%A6%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</link>
            <pubDate>Wed, 06 Oct 2021 15:42:45 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/10/%E7%99%BE%E5%BA%A6%E6%98%A5%E6%8B%9B%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</guid>
            <description>整个春招，百度总共8面，后端面试都通过了，其中测试开发岗位到二面，莫名奇妙给挂了，可能是说了一句已经有字节的offer， 对测试岗位还有所迟疑吧。。。
笔试 百度的笔试题目是两道原题，说来也是运气好，考试之前不久刚做过那两道题。印象比较深的一个题目是[130]被围绕的区域。
测试 测开一面 算法题是 字符串处理，去重规则类似 aaabbc =&amp;gt; abc 答的不错
测开二面 忘记了，没给过
MEG策略部门 后端一面 算法题是：二叉树左视图
后端二面 算法题是：二分查找问题，查找有序数组中数值等于某个数的值的个数
后端三面 面试官态度不怎么好，一直纠结我在字节实习测试开发的问题 应该是过了，但一直没有发正式offer，在拿到其他offer之后又想来说服我来这个部门
现在的部门 后端一面，mentor面的 算法题是：1. 接雨水 2. 接雨水的变式：二维接雨水 答的一般哈哈，存储和后端经验不足，需要提高
后端二面，xx老师面的 算法题是：
 链表题： 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;6 =&amp;gt; 1-&amp;gt;6-&amp;gt;2-&amp;gt;5-&amp;gt;3-&amp;gt;4, 融合了链表找中点，链表归并，链表反转三个问题 类似剑指offer上的机器活动范围问题 xx老师问了很多C++，操作系统的问题，这不撞我长处上了吗哈哈  后端三面，经理面的  主要是聊天，沟通一下意向，介绍一下部门业务  HR面 谈薪资，百度还是太抠了</description>
            <content type="html"><![CDATA[<p>整个春招，百度总共8面，后端面试都通过了，其中测试开发岗位到二面，莫名奇妙给挂了，可能是说了一句已经有字节的offer，
对测试岗位还有所迟疑吧。。。</p>
<h2 id="笔试">笔试</h2>
<p>百度的笔试题目是两道原题，说来也是运气好，考试之前不久刚做过那两道题。印象比较深的一个题目是[130]被围绕的区域。</p>
<h2 id="测试">测试</h2>
<h3 id="测开一面">测开一面</h3>
<p>算法题是 字符串处理，去重规则类似 aaabbc =&gt; abc
答的不错</p>
<h3 id="测开二面">测开二面</h3>
<p>忘记了，没给过</p>
<h2 id="meg策略部门">MEG策略部门</h2>
<h3 id="后端一面">后端一面</h3>
<p>算法题是：二叉树左视图</p>
<h3 id="后端二面">后端二面</h3>
<p>算法题是：二分查找问题，查找有序数组中数值等于某个数的值的个数</p>
<h3 id="后端三面">后端三面</h3>
<p>面试官态度不怎么好，一直纠结我在字节实习测试开发的问题
应该是过了，但一直没有发正式offer，在拿到其他offer之后又想来说服我来这个部门</p>
<h2 id="现在的部门">现在的部门</h2>
<h3 id="后端一面mentor面的">后端一面，mentor面的</h3>
<p>算法题是：1. 接雨水 2. 接雨水的变式：二维接雨水
答的一般哈哈，存储和后端经验不足，需要提高</p>
<h3 id="后端二面xx老师面的">后端二面，xx老师面的</h3>
<p>算法题是：</p>
<ol>
<li>链表题： 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6 =&gt; 1-&gt;6-&gt;2-&gt;5-&gt;3-&gt;4, 融合了链表找中点，链表归并，链表反转三个问题</li>
<li>类似剑指offer上的机器活动范围问题
xx老师问了很多C++，操作系统的问题，这不撞我长处上了吗哈哈</li>
</ol>
<h3 id="后端三面经理面的">后端三面，经理面的</h3>
<ol>
<li>主要是聊天，沟通一下意向，介绍一下部门业务</li>
</ol>
<h3 id="hr面">HR面</h3>
<p>谈薪资，百度还是太抠了</p>
]]></content>
        </item>
        
        <item>
            <title>字节客户端开发面试复盘</title>
            <link>https://oxygenbytes.github.io/posts/2021/08/%E5%AD%97%E8%8A%82%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</link>
            <pubDate>Fri, 06 Aug 2021 15:42:58 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/08/%E5%AD%97%E8%8A%82%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BC%80%E5%8F%91%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</guid>
            <description>虽然最后没有去字节，还是要感谢字节给了很多次面试机会，前两次参加字节面试的时候还什么都不懂 客户端没接触过，可以说靠刷题拿下sp，感谢曾经努力的自己
客户端一面 算法题： 旋转数组找最小元素 还问了一个代理的原理， http证书和对称加密和非对称加密的问题
客户端二面 算法题： 螺旋打印二维数组，使用深搜做的
客户端三面 算法题：
 遍历算法vector，删除vector中等于target的元素 给定一个数组 1 2 2 2 3 3 4 4 5 6 7 7 以最快的速度找到target第一次出现的位置  如今只零星记得算法题了，这三轮面试问题贼多，强度很大，一天面完，还都是技术面，临近毕业，工作还没着落，心理压力真的很大</description>
            <content type="html"><![CDATA[<p>虽然最后没有去字节，还是要感谢字节给了很多次面试机会，前两次参加字节面试的时候还什么都不懂
客户端没接触过，可以说靠刷题拿下sp，感谢曾经努力的自己</p>
<h2 id="客户端一面">客户端一面</h2>
<p>算法题：
旋转数组找最小元素
还问了一个代理的原理， http证书和对称加密和非对称加密的问题</p>
<h2 id="客户端二面">客户端二面</h2>
<p>算法题：
螺旋打印二维数组，使用深搜做的</p>
<h2 id="客户端三面">客户端三面</h2>
<p>算法题：</p>
<ol>
<li>遍历算法vector，删除vector中等于target的元素</li>
<li>给定一个数组 1 2 2 2 3 3 4 4 5 6 7 7 以最快的速度找到target第一次出现的位置</li>
</ol>
<p>如今只零星记得算法题了，这三轮面试问题贼多，强度很大，一天面完，还都是技术面，临近毕业，工作还没着落，心理压力真的很大</p>
]]></content>
        </item>
        
        <item>
            <title>Golang安装、配置、学习</title>
            <link>https://oxygenbytes.github.io/posts/2021/07/golang%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%AD%A6%E4%B9%A0/</link>
            <pubDate>Thu, 01 Jul 2021 20:13:03 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/07/golang%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%AD%A6%E4%B9%A0/</guid>
            <description>Linux安装 Go 1.16 rm -rf /usr/local/go &amp;amp;&amp;amp; tar -C /usr/local -xzf go1.16.5.linux-amd64.tar.gz export PATH=$PATH:/usr/local/go/bin reboot go version 配置国内代理 go env -w GO111MODULE=on go env -w GOPROXY=https://goproxy.cn, direct reboot vscode 使用Ctrl + Shift + P 打开命令行 选择Go: Install/Update Tools安装必要的包</description>
            <content type="html"><![CDATA[<h2 id="linux安装-go-116">Linux安装 Go 1.16</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">rm -rf /usr/local/go <span style="color:#f92672">&amp;&amp;</span> tar -C /usr/local -xzf go1.16.5.linux-amd64.tar.gz
export PATH<span style="color:#f92672">=</span>$PATH:/usr/local/go/bin
reboot
go version
</code></pre></div><h2 id="配置国内代理">配置国内代理</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">go env -w GO111MODULE<span style="color:#f92672">=</span>on
go env -w GOPROXY<span style="color:#f92672">=</span>https://goproxy.cn, direct
reboot
</code></pre></div><p>vscode 使用Ctrl + Shift + P 打开命令行 选择<code>Go: Install/Update Tools</code>安装必要的包</p>
]]></content>
        </item>
        
        <item>
            <title>进程和线程的区别</title>
            <link>https://oxygenbytes.github.io/posts/2021/06/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
            <pubDate>Sat, 26 Jun 2021 03:12:13 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/06/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
            <description>进程（Process）和线程（Thread）都是操作系统中的基本概念，它们之间有一些优劣和差异。
进程基本介绍 进程是程序执行时的一个实例，是系统进行资源分配的基本单位。所有与该进程有关的资源，都被记录在进程控制块(PCB)中。以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。
线程基本介绍 线程，有时也被称为轻量级进程，是程序执行流的最小单元，是进程中的一个实体，是被系统独立调度和分派的基本单位。与进程不同，线程与资源分配无关，线程自己不拥有系统资源，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。
进程和线程的关系 通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。但是，一个线程只属于一个进程。进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。而且需要注意的是，线程不是一个可执行的实体。
进程和线程的比较 进行和线程之间的差异可以从下面几个方面来阐述：
 调度 ：在引入线程的操作系统中，线程是调度和分配的基本单位 ，进程是资源拥有的基本单位 。把传统进程的两个属性分开，线程便能轻装运行，从而可 显著地提高系统的并发程度 。在同一进程中，线程的切换不会引起进程的切换；在由一个进程中的线程切换到另一个进程中的线程时，才会引起进程的切换。 并发性 ：在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，因而使操作系统具有更好的并发性，从而能 更有效地使用系统资源和提高系统吞吐量。 拥有资源 ：不论是传统的操作系统，还是设有线程的操作系统，进程都是拥有资源的一个独立 单位，它可以拥有自己的资源。一般地说，线程自己不拥有系统资源（只有一些必不可少的资源，但它可以访问其隶属进程的资源。 系统开销：由于在创建或撤消进程时，系统都要为之分配或回收资源，因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。进程切换的开销也远大于线程切换的开销。 通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性，因此共享简单。但是线程的数据同步要比进程略复杂。  最后 从上面的分析可以看到，似乎线程有很多优势，比如，数据共享效率高，可应对并发操作，有效利用等待时间等等，但是多线程的编程比多进程要复杂，同时，多进程的可靠性较好，因为进程间不会相互影响。实际情况还是需要自己分析拿捏的。但是一般来说，实际应用中常常采用“进程+线程”结合的方式，而不是非此即彼，因为它们两者没有绝对的好与不好，而是适合于不同场景。</description>
            <content type="html"><![CDATA[<p>进程（Process）和线程（Thread）都是操作系统中的基本概念，它们之间有一些优劣和差异。</p>
<h2 id="进程基本介绍">进程基本介绍</h2>
<p>进程是程序执行时的一个实例，是系统进行<strong>资源分配的基本单位</strong>。所有与该进程有关的资源，都被记录在进程控制块(PCB)中。以表示该进程拥有这些资源或正在使用它们。另外，进程也是抢占处理机的调度单位，它拥有一个完整的虚拟地址空间。当进程发生调度时，不同的进程拥有不同的虚拟地址空间，而同一进程内的不同线程共享同一地址空间。</p>
<h2 id="线程基本介绍">线程基本介绍</h2>
<p>线程，有时也被称为轻量级进程，是程序执行流的最小单元，是进程中的一个实体，是被<strong>系统独立调度和分派的基本单位</strong>。与进程不同，线程与资源分配无关，线程自己不拥有系统资源，它属于某一个进程，并与进程内的其他线程一起共享进程的资源。线程只由相关堆栈（系统栈或用户栈）寄存器和线程控制表TCB组成。</p>
<h2 id="进程和线程的关系">进程和线程的关系</h2>
<p>通常在一个进程中可以包含若干个线程，它们可以利用进程所拥有的资源。但是，一个线程只属于一个进程。进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。而且需要注意的是，线程不是一个可执行的实体。</p>
<h2 id="进程和线程的比较">进程和线程的比较</h2>
<p>进行和线程之间的差异可以从下面几个方面来阐述：</p>
<ul>
<li>调度 ：在引入线程的操作系统中，线程是调度和分配的基本单位 ，进程是资源拥有的基本单位 。把传统进程的两个属性分开，线程便能轻装运行，从而可 <strong>显著地提高系统的并发程度</strong> 。在同一进程中，线程的切换不会引起进程的切换；在由一个进程中的线程切换到另一个进程中的线程时，才会引起进程的切换。</li>
<li>并发性 ：在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间亦可并发执行，因而使操作系统具有更好的并发性，从而能 <strong>更有效地使用系统资源和提高系统吞吐量</strong>。</li>
<li>拥有资源 ：不论是传统的操作系统，还是设有线程的操作系统，进程都是拥有资源的一个独立 单位，它可以拥有自己的资源。一般地说，<strong>线程自己不拥有系统资源（只有一些必不可少的资源</strong>，但它可以访问其隶属进程的资源。</li>
<li>系统开销：由于在创建或撤消进程时，系统都要为之分配或回收资源，因此，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销。<strong>进程切换的开销也远大于线程切换的开销。</strong></li>
<li>通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性，因此共享简单。但是线程的数据同步要比进程略复杂。</li>
</ul>
<h2 id="最后">最后</h2>
<p>从上面的分析可以看到，似乎线程有很多优势，比如，数据共享效率高，可应对并发操作，有效利用等待时间等等，但是多线程的编程比多进程要复杂，同时，多进程的可靠性较好，因为进程间不会相互影响。实际情况还是需要自己分析拿捏的。但是一般来说，实际应用中常常采用“进程+线程”结合的方式，而不是非此即彼，因为它们两者没有绝对的好与不好，而是适合于不同场景。</p>
]]></content>
        </item>
        
        <item>
            <title>Deepin配置</title>
            <link>https://oxygenbytes.github.io/posts/2021/06/deepin%E9%85%8D%E7%BD%AE/</link>
            <pubDate>Sat, 26 Jun 2021 02:49:11 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/06/deepin%E9%85%8D%E7%BD%AE/</guid>
            <description>Deepin自带软件卸载 sudo apt purge org.deepin.browser sudo apt purge deepin-album deepin-voice-note deepin-draw sudo apt purge dde-introduction sudo apt purge libreoffice sudo apt purge libreoffice-calc libreoffice-impress libreoffice-writer sudo apt purge libreoffice-common libreoffice-style-colibre libreoffice-style-tango libreoffice-core sudo apt purge deepin-mail sudo apt purge simple-scan sudo apt-get remove dde-printer sudo apt autoremove Deepin更新并安装应用 sudo apt-get install firefox-esr sudo apt-get install g++ gdb make golang nodejs openjdk-11-jdk inetutils-tools zsh Deepin安装docker #!/bin/sh  # Shell script to add docker-ce to Deepin Linux repositories # Remove old docker sudo apt-get remove -y docker docker-engine docker.</description>
            <content type="html"><![CDATA[<h2 id="deepin自带软件卸载">Deepin自带软件卸载</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo apt purge org.deepin.browser 
sudo apt purge deepin-album  deepin-voice-note deepin-draw 
sudo apt purge dde-introduction 
sudo apt purge libreoffice
sudo apt purge libreoffice-calc libreoffice-impress libreoffice-writer 
sudo apt purge libreoffice-common libreoffice-style-colibre libreoffice-style-tango libreoffice-core
sudo apt purge deepin-mail 
sudo apt purge simple-scan 
sudo apt-get remove dde-printer 
sudo apt autoremove 
</code></pre></div><h2 id="deepin更新并安装应用">Deepin更新并安装应用</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo apt-get install firefox-esr
sudo apt-get install g++ gdb make golang nodejs openjdk-11-jdk inetutils-tools zsh
</code></pre></div><h2 id="deepin安装docker">Deepin安装docker</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/sh
</span><span style="color:#75715e"></span>
<span style="color:#75715e"># Shell script to add docker-ce to Deepin Linux repositories</span>

<span style="color:#75715e"># Remove old docker</span>
sudo apt-get remove -y docker docker-engine docker.io containerd runc

<span style="color:#75715e"># Install dependencies</span>
sudo apt-get install -y apt-transport-https ca-certificates curl gnupg2 software-properties-common
    
<span style="color:#75715e"># Add GPG and fingerprint</span>
curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -
sudo apt-key fingerprint 0EBFCD88

<span style="color:#75715e"># Add debian repository in deepin sources list</span>
printf <span style="color:#e6db74">&#39;deb [arch=amd64] https://download.docker.com/linux/debian buster stable\n&#39;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>| sudo tee /etc/apt/sources.list.d/docker-ce.list

<span style="color:#75715e"># Update packages and install</span>
sudo apt-get update -y
sudo apt-get install -y docker-ce

<span style="color:#75715e"># Add current user to the docker users group (OPTIONAL)</span>
sudo usermod -aG docker <span style="color:#66d9ef">$(</span>whoami<span style="color:#66d9ef">)</span>

sudo groupadd docker
sudo gpasswd -a $USER docker 
newgrp docker
docker ps 
</code></pre></div><p>然后配置国内景象</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo vim /etc/docker/daemon.json
<span style="color:#f92672">{</span>
  <span style="color:#e6db74">&#34;registry-mirrors&#34;</span>: <span style="color:#f92672">[</span>
    <span style="color:#e6db74">&#34;https://hub-mirror.c.163.com&#34;</span>,
    <span style="color:#e6db74">&#34;https://mirror.baidubce.com&#34;</span>
  <span style="color:#f92672">]</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="配置终端">配置终端</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sh -c <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>wget https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O -<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>
</code></pre></div><h2 id="配置ssh">配置SSH</h2>
<p>将.ssh/文件拷贝到~</p>
<p>测试是否连接到github</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ssh -T git@github.com
</code></pre></div><p>问题一</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ssh -vT git@github.com
&gt; ...
&gt; Agent admitted failure to sign using the key.
&gt; debug1: No more authentication methods to try.
&gt; Permission denied <span style="color:#f92672">(</span>publickey<span style="color:#f92672">)</span>.
</code></pre></div><p>采取措施</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># star图片t the ssh-agent in the background</span>
$ eval <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>ssh-agent -s<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>
&gt; Agent pid <span style="color:#ae81ff">59566</span>
$ ssh-add
&gt; Enter passphrase <span style="color:#66d9ef">for</span> /home/you/.ssh/id_rsa: <span style="color:#f92672">[</span>tippy tap<span style="color:#f92672">]</span>
&gt; Identity added: /home/you/.ssh/id_rsa <span style="color:#f92672">(</span>/home/you/.ssh/id_rsa<span style="color:#f92672">)</span>
</code></pre></div><p>问题二</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ermissions <span style="color:#ae81ff">0777</span> <span style="color:#66d9ef">for</span> <span style="color:#e6db74">&#39;~/.ssh/id_rsa&#39;</span> are too open
</code></pre></div><p>采取措施</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">chmod -R <span style="color:#ae81ff">700</span> id_rsa id_rsa.pub known_hosts passwd
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>C&#43;&#43;标准模板库STL</title>
            <link>https://oxygenbytes.github.io/posts/2021/06/c-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93stl/</link>
            <pubDate>Sun, 13 Jun 2021 20:43:09 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/06/c-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93stl/</guid>
            <description>注： size()、empty()是所有容器都有的，时间复杂度为 O(1)，并不是结果并非遍历得到，而是原本就有个变 量来存size，直接访问该变量即可
注：系统为某一程序分配空间时，所需时间与空间大小无关，而是与申请次数有关&amp;mdash;倍增思想的原理
vector 变长数组，倍增的思想 size() 返回元素个数 empty() 返回是否为空 clear() 清空 front()/back() push_back()/pop_back() begin()/end() [] 即和数组一样，支持随机寻址 支持比较运算，按字典排序: vector &amp;lt;int&amp;gt; a(3, 5), b(5,3); if(a &amp;gt; b) cout &amp;lt;&amp;lt; &amp;#34; a &amp;gt; b &amp;#34;; 遍历方式： //遍历方法一 for(auto x:a) cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;#39; &amp;#39;; //遍历方法二 迭代器可以看成是指针 for(int i = 0; i &amp;lt; a.size(); i ++) cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &amp;#39; &amp;#39;; //遍历方法三 迭代器可以看成是指针 for(vector &amp;lt;int&amp;gt; :: iterator i = a.begin(); i !</description>
            <content type="html"><![CDATA[<p>注： size()、empty()是所有容器都有的，时间复杂度为 O(1)，并不是结果并非遍历得到，而是原本就有个变 量来存size，直接访问该变量即可</p>
<p>注：系统为某一程序分配空间时，所需时间与空间大小无关，而是与申请次数有关&mdash;倍增思想的原理</p>
<h2 id="vector-变长数组倍增的思想">vector 变长数组，倍增的思想</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">size() <span style="color:#960050;background-color:#1e0010">返回元素个数</span>
empty() <span style="color:#960050;background-color:#1e0010">返回是否为空</span>
clear() <span style="color:#960050;background-color:#1e0010">清空</span>
front()<span style="color:#f92672">/</span>back() 
push_back()<span style="color:#f92672">/</span>pop_back()
begin()<span style="color:#f92672">/</span>end()
[] <span style="color:#960050;background-color:#1e0010">即和数组一样，支持随机寻址</span>
<span style="color:#960050;background-color:#1e0010">支持比较运算，按字典排序</span><span style="color:#f92672">:</span>
vector <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>), b(<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">3</span>);
<span style="color:#66d9ef">if</span>(a <span style="color:#f92672">&gt;</span> b) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; a &gt; b &#34;</span>;

<span style="color:#960050;background-color:#1e0010">遍历方式：</span>
<span style="color:#75715e">//遍历方法一
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> x:a)   cout <span style="color:#f92672">&lt;&lt;</span> x <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
<span style="color:#75715e">//遍历方法二 迭代器可以看成是指针
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> a.size(); i <span style="color:#f92672">++</span>)  cout <span style="color:#f92672">&lt;&lt;</span> a[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
<span style="color:#75715e">//遍历方法三 迭代器可以看成是指针
</span><span style="color:#75715e"></span><span style="color:#66d9ef">for</span>(vector <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">::</span> iterator i <span style="color:#f92672">=</span> a.begin(); i <span style="color:#f92672">!=</span> a.end(); i <span style="color:#f92672">++</span>) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#f92672">*</span>i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span>;
</code></pre></div><h2 id="pair">pair</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">    pair <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>
    first <span style="color:#960050;background-color:#1e0010">第一个元素</span>
    second <span style="color:#960050;background-color:#1e0010">第二个元素</span>
    <span style="color:#960050;background-color:#1e0010">支持比较运算，</span> <span style="color:#960050;background-color:#1e0010">以第一个为第一关键字，</span> <span style="color:#960050;background-color:#1e0010">第二个为第二关键字（字典序</span>)<span style="color:#f92672">---</span><span style="color:#960050;background-color:#1e0010">可用于按某一属性排序，将待排属性放</span>
    <span style="color:#960050;background-color:#1e0010">在第一个元素位置</span>
pair <span style="color:#960050;background-color:#1e0010">初始化方式：</span>
    pair <span style="color:#f92672">&lt;</span>string , <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> p;
    p <span style="color:#f92672">=</span> {<span style="color:#e6db74">&#34;hello&#34;</span>,  <span style="color:#ae81ff">20</span>}
    p <span style="color:#f92672">=</span> make_pair(<span style="color:#e6db74">&#34;hello&#34;</span>, <span style="color:#ae81ff">20</span>);
    cout <span style="color:#f92672">&lt;&lt;</span> p.first <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">&lt;&lt;</span> p.second ;

<span style="color:#960050;background-color:#1e0010">也可以用</span>pair存储两个以上的属性<span style="color:#960050;background-color:#1e0010">，如：</span>pair(<span style="color:#66d9ef">int</span> ,pair<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>);
</code></pre></div><h2 id="string-字符串">string 字符串</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#960050;background-color:#1e0010">基本操作</span>
    <span style="color:#a6e22e">substr</span>(), c_str()  <span style="color:#75715e">//c_str()  返回 const 类型的指针
</span><span style="color:#75715e"></span>    size()<span style="color:#f92672">/</span>length() <span style="color:#960050;background-color:#1e0010">返回字符串长度</span>
    empty()
    clear()<span style="color:#75715e">//清空整个字符串
</span><span style="color:#75715e"></span>    erase() <span style="color:#75715e">//erase(1,2) 删除以1为索引，长度为2的字符串
</span><span style="color:#75715e"></span>    []

<span style="color:#960050;background-color:#1e0010">支持比较运算，按字典序进行比较</span>  
    a <span style="color:#f92672">&lt;</span> <span style="color:#e6db74">&#34;hello&#34;</span> <span style="color:#960050;background-color:#1e0010">或</span> a.compare(<span style="color:#e6db74">&#34;hello&#34;</span>);<span style="color:#75715e">//a.compare() 返回具体的比较值
</span><span style="color:#75715e"></span>
<span style="color:#960050;background-color:#1e0010">字符串变量和字符数组之间的转化：</span>
    <span style="color:#66d9ef">char</span> ch[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>; string str <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;world&#34;</span>;
    ch[] <span style="color:#f92672">-&gt;</span> str :   str <span style="color:#f92672">=</span> ch;
    str <span style="color:#f92672">-&gt;</span> ch[] <span style="color:#f92672">:</span>   strcpy(ch,str.c_str());

string <span style="color:#960050;background-color:#1e0010">初始化</span><span style="color:#f92672">:</span>
    string a(<span style="color:#e6db74">&#34;hello&#34;</span>);
    string a <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello&#34;</span>;

<span style="color:#960050;background-color:#1e0010">取子串：</span><span style="color:#75715e">//很常用
</span><span style="color:#75715e"></span>    a.substr(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">3</span>);<span style="color:#75715e">//返回下标从1开始且长度为3的子串，包括左端点  
</span><span style="color:#75715e"></span>
<span style="color:#960050;background-color:#1e0010">拼接字符串：</span>
    a <span style="color:#f92672">+=</span> <span style="color:#e6db74">&#34;world&#34;</span>;<span style="color:#75715e">//新增字符串
</span><span style="color:#75715e"></span>    a.append(<span style="color:#e6db74">&#34; world&#34;</span>);<span style="color:#75715e">//新增字符串
</span><span style="color:#75715e"></span>    a.push_back(<span style="color:#e6db74">&#39;.&#39;</span>);<span style="color:#75715e">//在字符串末新增单个字符
</span><span style="color:#75715e"></span>
<span style="color:#960050;background-color:#1e0010">在字符串指定位置添加字符串</span>
    a.insert(<span style="color:#ae81ff">3</span>,<span style="color:#e6db74">&#34;world&#34;</span>);

<span style="color:#960050;background-color:#1e0010">访问字符串：</span>string str;
    cout <span style="color:#f92672">&lt;&lt;</span> str[<span style="color:#ae81ff">2</span>];<span style="color:#75715e">//以下标方式访问
</span><span style="color:#75715e"></span>    cout <span style="color:#f92672">&lt;&lt;</span> str.at(<span style="color:#ae81ff">2</span>);<span style="color:#75715e">//通过at()方法访问
</span><span style="color:#75715e"></span>    getline(cin,str );;<span style="color:#75715e">//读取一行字符赋值给str
</span><span style="color:#75715e"></span>    getline(cin, str,<span style="color:#e6db74">&#39;!&#39;</span>);<span style="color:#75715e">//读取一行字符赋值给str,以！结束
</span><span style="color:#75715e"></span>
<span style="color:#960050;background-color:#1e0010">字符串排序：</span>
    sort(str.begin(),str.end());<span style="color:#75715e">//需要包含头文件algorithm
</span><span style="color:#75715e"></span>
<span style="color:#960050;background-color:#1e0010">可以使用</span>STL接口<span style="color:#960050;background-color:#1e0010">，可以理解为一个特殊的容器，容器里装的是的字符</span>
    a.push_back(<span style="color:#e6db74">&#39;.&#39;</span>);<span style="color:#75715e">//在字符串末新增单个字符
</span><span style="color:#75715e"></span>    a.pop_back();

<span style="color:#960050;background-color:#1e0010">字符串变量的交换和取代：</span>
    a.swap(str);<span style="color:#75715e">//str 为字符串变量
</span><span style="color:#75715e"></span>    a.replace(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,str2) <span style="color:#75715e">//用字符串str2取代字符串a下标为1长度为2的子串
</span></code></pre></div><h2 id="deque-双端队列">deque 双端队列</h2>
<p>缺点：慢，但用的不是很多，因为它要比一般的数组慢好几倍</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">    size()
    empty()
    clear()
    front() <span style="color:#f92672">/</span> back()
    push_back() <span style="color:#f92672">/</span> pop_back()
    push_front() <span style="color:#f92672">/</span> pop_front()
    begin() <span style="color:#f92672">/</span> end()
    []
</code></pre></div><h2 id="容器适配器">容器适配器</h2>
<p>C++ 提供了三种容器适配器(contain adapter):
stack, queue, priority_queue。</p>
<ol>
<li>stack和queue基于deque实现</li>
<li>priority_queue基于vector实现</li>
</ol>
<p>容器适配器的作用大概类似于电源适配器，将标准电压转化成各种需要的电压。</p>
<p>你完全可以在deque上按照stack的方式工作，但是deque太强大了，它提供了远超stack的操作所需的各种接口
但凡你有一个失误，创建的栈就毁了。</p>
<h3 id="queue-队列">queue 队列</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">    size()
    empty() 
    push()  <span style="color:#75715e">//向队尾插入一个元素
</span><span style="color:#75715e"></span>    front() <span style="color:#75715e">//返回对头元素
</span><span style="color:#75715e"></span>    pop()   <span style="color:#75715e">//弹出对头元素
</span><span style="color:#75715e"></span>    back()  <span style="color:#75715e">//返回队尾元素
</span></code></pre></div><h3 id="priority_queue-优先队列">priority_queue 优先队列</h3>
<p>priority_queue&lt;Type, Container, Functional&gt;
如果不写后两个参数，那么容器默认用的是vector，比较方式默认用operator&lt;，也就是优先队列是大顶堆，队头元素最大。</p>
<p>Type为数据类型， Container为保存数据的容器，Functional为元素比较方式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;queue&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
	priority_queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> p;
	p.push(<span style="color:#ae81ff">1</span>);
	p.push(<span style="color:#ae81ff">2</span>);
	p.push(<span style="color:#ae81ff">8</span>);
	p.push(<span style="color:#ae81ff">5</span>);
	p.push(<span style="color:#ae81ff">43</span>);
	<span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">5</span>;i<span style="color:#f92672">++</span>){
		cout<span style="color:#f92672">&lt;&lt;</span>p.top()<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
		p.pop();
	}
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#75715e">// 43 8 5 2 1
</span><span style="color:#75715e">//升序队列
</span><span style="color:#75715e"></span>priority_queue <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>,greater<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> q;
<span style="color:#75715e">//降序队列
</span><span style="color:#75715e"></span>priority_queue <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>,less<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span>q;
<span style="color:#75715e">//greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）
</span><span style="color:#75715e"></span>
<span style="color:#960050;background-color:#1e0010">其实就是堆，默认是大根堆</span>

    push() <span style="color:#75715e">//插入一个元素
</span><span style="color:#75715e"></span>    top()  <span style="color:#75715e">// 返回堆顶元素
</span><span style="color:#75715e"></span>    pop()  <span style="color:#75715e">//弹出堆顶元素
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">将小根堆转化为大根堆：</span>
<span style="color:#960050;background-color:#1e0010">方法</span><span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">：</span> priority_queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>,greater<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> heap; <span style="color:#75715e">//定义一个小根堆heap;
</span><span style="color:#75715e"></span><span style="color:#960050;background-color:#1e0010">方法</span><span style="color:#ae81ff">2</span><span style="color:#960050;background-color:#1e0010">：</span> <span style="color:#960050;background-color:#1e0010">以负数来存</span>
</code></pre></div><h3 id="stack-栈">stack 栈</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">    size()
    empty()
    push()  <span style="color:#75715e">//向栈顶插入一个元素
</span><span style="color:#75715e"></span>    top()   <span style="color:#75715e">//返回栈顶元素
</span><span style="color:#75715e"></span>    pop()   <span style="color:#75715e">//弹出栈顶元素
</span></code></pre></div><h2 id="set-map-multiset-multimap">set, map, multiset, multimap</h2>
<p>基于平衡二叉树（红黑树）， 动态维护有序序列</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">    set <span style="color:#960050;background-color:#1e0010">与</span> multiset <span style="color:#960050;background-color:#1e0010">的区别：</span>set <span style="color:#960050;background-color:#1e0010">里面不可以有重复元素，而</span>multiset <span style="color:#960050;background-color:#1e0010">可以有</span>
    size()
    empty()
    clear()
    begin() <span style="color:#f92672">/</span> end() <span style="color:#f92672">++</span>, <span style="color:#f92672">--</span> <span style="color:#960050;background-color:#1e0010">返回前驱和后继，</span> <span style="color:#960050;background-color:#1e0010">时间复杂度：</span> O(logn)
</code></pre></div><h3 id="setmultiset-集合">set/multiset 集合</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">    insert() <span style="color:#960050;background-color:#1e0010">插入一个数</span>
    find()   <span style="color:#960050;background-color:#1e0010">查找一个数</span>
    count()  <span style="color:#960050;background-color:#1e0010">返回某个数的个数</span>

    erase()
        <span style="color:#960050;background-color:#1e0010">注意：</span>(<span style="color:#ae81ff">1</span>)(<span style="color:#ae81ff">2</span>)<span style="color:#960050;background-color:#1e0010">在</span>set中无区别<span style="color:#960050;background-color:#1e0010">，但在</span>multiset里有区别
        (<span style="color:#ae81ff">1</span>) <span style="color:#960050;background-color:#1e0010">输入是一个整数</span>x, <span style="color:#960050;background-color:#1e0010">删除所有</span>x          <span style="color:#960050;background-color:#1e0010">时间复发度：</span> O(k  <span style="color:#f92672">+</span> logn)  <span style="color:#75715e">//k是所有元素的个数
</span><span style="color:#75715e"></span>        (<span style="color:#ae81ff">2</span>) <span style="color:#960050;background-color:#1e0010">输入一个迭代器，</span> <span style="color:#960050;background-color:#1e0010">删除这个迭代器</span>

    <span style="color:#960050;background-color:#1e0010">注意：</span> lower_bound()<span style="color:#f92672">/</span>upper_bound() <span style="color:#f92672">-----</span> <span style="color:#960050;background-color:#1e0010">核心操作</span>
    lower_bound(x) <span style="color:#960050;background-color:#1e0010">返回大于等于</span>x的最小的数的迭代器
    upper_bound(x) <span style="color:#960050;background-color:#1e0010">返回大于</span>x的最小的数的迭代器
</code></pre></div><h3 id="mapmultimap-哈希表">map/multimap 哈希表</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">    insert()  <span style="color:#960050;background-color:#1e0010">插入的一个数是一个</span>pair         <span style="color:#960050;background-color:#1e0010">用的不多</span>
    erase()   <span style="color:#960050;background-color:#1e0010">输入的参数是</span>pair <span style="color:#960050;background-color:#1e0010">或</span> <span style="color:#960050;background-color:#1e0010">是迭代器</span>   <span style="color:#960050;background-color:#1e0010">用的较多</span>
    find()
    []        <span style="color:#960050;background-color:#1e0010">时间复杂度：</span> O(logn)           <span style="color:#960050;background-color:#1e0010">最主要的操作</span>
    lower_bound()<span style="color:#f92672">/</span>upper_bound()
</code></pre></div><h3 id="unordered_setmapmultisetmultimap-哈希表">unordered_set/map/multiset/multimap 哈希表</h3>
<p>和上面类似，增、删、改、查的时间复杂度是 O(1) &mdash; 优势
和上面的区别：凡是和排序有关的操作都是不支持的,如：不支持 lower_bound()/upper_bound() 迭代器的++，&ndash; 等</p>
<h2 id="bitset">bitset</h2>
<p>压位, 存储相同的数据量，存储空间仅占bool变量的 1/8</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">    <span style="color:#960050;background-color:#1e0010">定义变量：</span> bitset<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">10000</span><span style="color:#f92672">&gt;</span> s   <span style="color:#75715e">//注意&lt;&gt;中存的不是类型，而是个数
</span><span style="color:#75715e"></span>    <span style="color:#f92672">~</span>,<span style="color:#f92672">&amp;</span>, <span style="color:#f92672">|</span>, <span style="color:#f92672">^</span>
    <span style="color:#f92672">&gt;&gt;</span> , <span style="color:#f92672">&lt;&lt;</span>
    <span style="color:#f92672">==</span> , <span style="color:#f92672">!=</span> 
    []
    count()     <span style="color:#960050;background-color:#1e0010">返回有多少个</span><span style="color:#ae81ff">1</span>
    any()       <span style="color:#960050;background-color:#1e0010">判断是否至少有一个</span><span style="color:#ae81ff">1</span>
    none()      <span style="color:#960050;background-color:#1e0010">判断是否全为</span><span style="color:#ae81ff">0</span>
    set()       <span style="color:#960050;background-color:#1e0010">把所有位置为</span><span style="color:#ae81ff">1</span>
    set(k, v)   <span style="color:#960050;background-color:#1e0010">把第</span>k位置为1
    reset()     <span style="color:#960050;background-color:#1e0010">把所有位置为</span><span style="color:#ae81ff">0</span>
    flip()      <span style="color:#960050;background-color:#1e0010">等价于</span><span style="color:#f92672">~</span>
    flip(k)     <span style="color:#960050;background-color:#1e0010">把第</span>k位取反
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>整数二分算法模板</title>
            <link>https://oxygenbytes.github.io/posts/2021/06/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</link>
            <pubDate>Sun, 13 Jun 2021 20:20:31 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/06/%E6%95%B4%E6%95%B0%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95%E6%A8%A1%E6%9D%BF/</guid>
            <description>bool check(int x) {/* ... */} // 检查x是否满足某种性质  // 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用： int bsearch_1(int l, int r) { while (l &amp;lt; r) { int mid = l + r &amp;gt;&amp;gt; 1; if (check(mid)) r = mid; // check()判断mid是否满足性质  else l = mid + 1; } return l; } // 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用： int bsearch_2(int l, int r) { while (l &amp;lt; r) { int mid = l + r + 1 &amp;gt;&amp;gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } </description>
            <content type="html"><![CDATA[<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">check</span>(<span style="color:#66d9ef">int</span> x) {<span style="color:#75715e">/* ... */</span>} <span style="color:#75715e">// 检查x是否满足某种性质
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bsearch_1</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r)
{
    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r)
    {
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (check(mid)) r <span style="color:#f92672">=</span> mid;    <span style="color:#75715e">// check()判断mid是否满足性质
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> l <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> l;
}
<span style="color:#75715e">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bsearch_2</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r)
{
    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r)
    {
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (check(mid)) l <span style="color:#f92672">=</span> mid;
        <span style="color:#66d9ef">else</span> r <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> l;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>归并排序模板</title>
            <link>https://oxygenbytes.github.io/posts/2021/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/</link>
            <pubDate>Sun, 13 Jun 2021 20:17:34 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/06/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/</guid>
            <description>void merge_sort(int q[], int l, int r) { if (l &amp;gt;= r) return; int mid = l + r &amp;gt;&amp;gt; 1; merge_sort(q, l, mid); merge_sort(q, mid + 1, r); int k = 0, i = l, j = mid + 1; while (i &amp;lt;= mid &amp;amp;&amp;amp; j &amp;lt;= r) if (q[i] &amp;lt;= q[j]) tmp[k ++ ] = q[i ++ ]; else tmp[k ++ ] = q[j ++ ]; while (i &amp;lt;= mid) tmp[k ++ ] = q[i ++ ]; while (j &amp;lt;= r) tmp[k ++ ] = q[j ++ ]; for (i = l, j = 0; i &amp;lt;= r; i ++, j ++ ) q[i] = tmp[j]; } </description>
            <content type="html"><![CDATA[<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge_sort</span>(<span style="color:#66d9ef">int</span> q[], <span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r)
{
    <span style="color:#66d9ef">if</span> (l <span style="color:#f92672">&gt;=</span> r) <span style="color:#66d9ef">return</span>;

    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
    merge_sort(q, l, mid);
    merge_sort(q, mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r);

    <span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, i <span style="color:#f92672">=</span> l, j <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;=</span> mid <span style="color:#f92672">&amp;&amp;</span> j <span style="color:#f92672">&lt;=</span> r)
        <span style="color:#66d9ef">if</span> (q[i] <span style="color:#f92672">&lt;=</span> q[j]) tmp[k <span style="color:#f92672">++</span> ] <span style="color:#f92672">=</span> q[i <span style="color:#f92672">++</span> ];
        <span style="color:#66d9ef">else</span> tmp[k <span style="color:#f92672">++</span> ] <span style="color:#f92672">=</span> q[j <span style="color:#f92672">++</span> ];

    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;=</span> mid) tmp[k <span style="color:#f92672">++</span> ] <span style="color:#f92672">=</span> q[i <span style="color:#f92672">++</span> ];
    <span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&lt;=</span> r) tmp[k <span style="color:#f92672">++</span> ] <span style="color:#f92672">=</span> q[j <span style="color:#f92672">++</span> ];

    <span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> l, j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;=</span> r; i <span style="color:#f92672">++</span>, j <span style="color:#f92672">++</span> ) q[i] <span style="color:#f92672">=</span> tmp[j];
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>快速排序模板</title>
            <link>https://oxygenbytes.github.io/posts/2021/06/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/</link>
            <pubDate>Sun, 13 Jun 2021 20:16:14 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/06/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/</guid>
            <description>void quick_sort(int q[], int l, int r) { if (l &amp;gt;= r) return; int i = l - 1, j = r + 1, x = q[l + r &amp;gt;&amp;gt; 1]; while (i &amp;lt; j) { do i ++ ; while (q[i] &amp;lt; x); do j -- ; while (q[j] &amp;gt; x); if (i &amp;lt; j) swap(q[i], q[j]); } quick_sort(q, l, j), quick_sort(q, j + 1, r); } </description>
            <content type="html"><![CDATA[<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quick_sort</span>(<span style="color:#66d9ef">int</span> q[], <span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r)
{
    <span style="color:#66d9ef">if</span> (l <span style="color:#f92672">&gt;=</span> r) <span style="color:#66d9ef">return</span>;

    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> l <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, j <span style="color:#f92672">=</span> r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, x <span style="color:#f92672">=</span> q[l <span style="color:#f92672">+</span> r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">while</span> (i <span style="color:#f92672">&lt;</span> j)
    {
        <span style="color:#66d9ef">do</span> i <span style="color:#f92672">++</span> ; <span style="color:#66d9ef">while</span> (q[i] <span style="color:#f92672">&lt;</span> x);
        <span style="color:#66d9ef">do</span> j <span style="color:#f92672">--</span> ; <span style="color:#66d9ef">while</span> (q[j] <span style="color:#f92672">&gt;</span> x);
        <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&lt;</span> j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, r);
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>快速幂模板</title>
            <link>https://oxygenbytes.github.io/posts/2021/06/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%A8%A1%E6%9D%BF/</link>
            <pubDate>Sun, 13 Jun 2021 20:07:37 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/06/%E5%BF%AB%E9%80%9F%E5%B9%82%E6%A8%A1%E6%9D%BF/</guid>
            <description>求 $ m^k \bmod p $
int qmi(int m, int k, int p) { int res = 1 % p, t = m; while (k) { if (k&amp;amp;1) res = res * t % p; t = t * t % p; k &amp;gt;&amp;gt;= 1; } return res; } </description>
            <content type="html"><![CDATA[<p>求 $ m^k \bmod p $</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">qmi</span>(<span style="color:#66d9ef">int</span> m, <span style="color:#66d9ef">int</span> k, <span style="color:#66d9ef">int</span> p)
{
    <span style="color:#66d9ef">int</span> res <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">%</span> p, t <span style="color:#f92672">=</span> m;
    <span style="color:#66d9ef">while</span> (k)
    {
        <span style="color:#66d9ef">if</span> (k<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>) res <span style="color:#f92672">=</span> res <span style="color:#f92672">*</span> t <span style="color:#f92672">%</span> p;
        t <span style="color:#f92672">=</span> t <span style="color:#f92672">*</span> t <span style="color:#f92672">%</span> p;
        k <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> res;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>高途跟谁学面试复盘</title>
            <link>https://oxygenbytes.github.io/posts/2021/05/%E9%AB%98%E9%80%94%E8%B7%9F%E8%B0%81%E5%AD%A6%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</link>
            <pubDate>Mon, 10 May 2021 22:49:50 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/05/%E9%AB%98%E9%80%94%E8%B7%9F%E8%B0%81%E5%AD%A6%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</guid>
            <description>笔试 忘了，似乎是五道题，有一道最长递增子序列没做出来（因为还让打印出序列），后来还被面试官拿出来鞭尸。。。其他简单题都做出来了
时间比较久了，重点记一下算法题和答的不好的问题
一面  select, poll, epoll，答的不好，因为没实际用过 算法题：求字符串的最长回文序列，秒了  二面  算法题：在增序链表中插入一个节点，参数为二级指针 算法题: 写一个二分搜索  三面  算法题：二位数组，从左到右，从上到下升序，查找某个值是不是在数组中，秒了  </description>
            <content type="html"><![CDATA[<h2 id="笔试">笔试</h2>
<p>忘了，似乎是五道题，有一道最长递增子序列没做出来（因为还让打印出序列），后来还被面试官拿出来鞭尸。。。其他简单题都做出来了</p>
<p>时间比较久了，重点记一下算法题和答的不好的问题</p>
<h2 id="一面">一面</h2>
<ol>
<li>select, poll, epoll，答的不好，因为没实际用过</li>
<li>算法题：求字符串的最长回文序列，秒了</li>
</ol>
<h2 id="二面">二面</h2>
<ol>
<li>算法题：在增序链表中插入一个节点，参数为二级指针</li>
<li>算法题: 写一个二分搜索</li>
</ol>
<h2 id="三面">三面</h2>
<ol>
<li>算法题：二位数组，从左到右，从上到下升序，查找某个值是不是在数组中，秒了</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>美团优选面试复盘</title>
            <link>https://oxygenbytes.github.io/posts/2021/04/%E7%BE%8E%E5%9B%A2%E4%BC%98%E9%80%89%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</link>
            <pubDate>Tue, 20 Apr 2021 19:22:23 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/04/%E7%BE%8E%E5%9B%A2%E4%BC%98%E9%80%89%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</guid>
            <description>时间比较久了，重点记一下算法题和答的不好的问题
笔试 忘记了，大概是4道编程题，全是ACM类型的题目，最后做出来1.4道，进面试了
一面  介绍自己 讲一下虚拟内存的工作原理，印象里只有这个面试官问过 算法题：连续子数组的最大和，秒了 反问了一下，常用C++，对java不太熟，而美团以java为主，会不会有影响  二面（2021-03-02 15:00，1小时30分钟）  介绍自己 说一下sql优化方法，我。。。 算法题：找出字符串中最长的回文串，秒了，用了O（n^2）的方法 反问一下工作内容和工作时间  </description>
            <content type="html"><![CDATA[<p>时间比较久了，重点记一下算法题和答的不好的问题</p>
<h2 id="笔试">笔试</h2>
<p>忘记了，大概是4道编程题，全是ACM类型的题目，最后做出来1.4道，进面试了</p>
<h2 id="一面">一面</h2>
<ol>
<li>介绍自己</li>
<li>讲一下虚拟内存的工作原理，印象里只有这个面试官问过</li>
<li>算法题：连续子数组的最大和，秒了</li>
<li>反问了一下，常用C++，对java不太熟，而美团以java为主，会不会有影响</li>
</ol>
<h2 id="二面2021-03-02-15001小时30分钟">二面（2021-03-02 15:00，1小时30分钟）</h2>
<ol>
<li>介绍自己</li>
<li>说一下sql优化方法，我。。。</li>
<li>算法题：找出字符串中最长的回文串，秒了，用了O（n^2）的方法</li>
<li>反问一下工作内容和工作时间</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>华为面试复盘</title>
            <link>https://oxygenbytes.github.io/posts/2021/04/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</link>
            <pubDate>Fri, 02 Apr 2021 21:54:01 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/04/%E5%8D%8E%E4%B8%BA%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</guid>
            <description>投递之后一直无消息，后来被华为财经部门捞了，面试的职位是 财经数字化工程师，凭印象简单写写
笔试（2021.03.24） 3道算法题, 第一题AC， 第二题70%， 第三题太长看晕了，直接提交了
一面(2021.03.29)  自我介绍 简单讲讲项目，项目的难点是什么，怎么解决的 一些基础知识 算法题：最接近目标的三数之和，用了双指针，写的死循环了，本来还想调一下的，但是面试官说思路可以，就走了，真的很忙  二面（2021.03.29,接着一面继续）  介绍项目 学过什么课程 进程和线程，进程通讯方式 C++ STL里面的数据结构 大学里面专业课成绩怎么样？最好的是什么课？算法设计与分析 谈谈递归，深搜，广搜，动态规划 算法题：全排列，说说思路就可以，还谈到子集，组合问题，最后说到这几个问题和树的关系，如何从树的角度去理解这几个问题  主管面（2021.04.02） 我是哈工程的，面试官说自己对哈工程还算了解，因为他是哈工大的。。。
 大学经历 在学校的成绩 为什么没有实习 疫情对你的影响，因为疫情的感悟 为什么写博客，最大的收获是什么 做算法题最大的收获是什么？ 答：依然很菜，但是逐步消除了对代码的陌生感 对华为的看法和印象 对华为财经的看法，从华为最近拿到支付牌照聊了一下 为什么有些面试者对面向企业内部的软件开发业务不太感兴趣 如果同时拿到华为和互联网的offer，会怎么选择？ 谈一下自己的优缺点 期望薪资 反问了一下本科生在华为的发展和晋升问题  </description>
            <content type="html"><![CDATA[<p>投递之后一直无消息，后来被华为财经部门捞了，面试的职位是 <code>财经数字化工程师</code>，凭印象简单写写</p>
<h2 id="笔试20210324">笔试（2021.03.24）</h2>
<p>3道算法题, 第一题AC， 第二题70%， 第三题太长看晕了，直接提交了</p>
<h2 id="一面20210329">一面(2021.03.29)</h2>
<ol>
<li>自我介绍</li>
<li>简单讲讲项目，项目的难点是什么，怎么解决的</li>
<li>一些基础知识</li>
<li>算法题：最接近目标的三数之和，用了双指针，写的死循环了，本来还想调一下的，但是面试官说思路可以，就走了，真的很忙</li>
</ol>
<h2 id="二面20210329接着一面继续">二面（2021.03.29,接着一面继续）</h2>
<ol>
<li>介绍项目</li>
<li>学过什么课程</li>
<li>进程和线程，进程通讯方式</li>
<li>C++ STL里面的数据结构</li>
<li>大学里面专业课成绩怎么样？最好的是什么课？算法设计与分析</li>
<li>谈谈递归，深搜，广搜，动态规划</li>
<li>算法题：全排列，说说思路就可以，还谈到子集，组合问题，最后说到这几个问题和树的关系，如何从树的角度去理解这几个问题</li>
</ol>
<h2 id="主管面20210402">主管面（2021.04.02）</h2>
<p>我是哈工程的，面试官说自己对哈工程还算了解，因为他是哈工大的。。。</p>
<ol>
<li>大学经历</li>
<li>在学校的成绩</li>
<li>为什么没有实习</li>
<li>疫情对你的影响，因为疫情的感悟</li>
<li>为什么写博客，最大的收获是什么</li>
<li>做算法题最大的收获是什么？ 答：依然很菜，但是逐步消除了对代码的陌生感</li>
<li>对华为的看法和印象</li>
<li>对华为财经的看法，从华为最近拿到支付牌照聊了一下</li>
<li>为什么有些面试者对面向企业内部的软件开发业务不太感兴趣</li>
<li>如果同时拿到华为和互联网的offer，会怎么选择？</li>
<li>谈一下自己的优缺点</li>
<li>期望薪资</li>
<li>反问了一下本科生在华为的发展和晋升问题</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>Shoppe面试复盘</title>
            <link>https://oxygenbytes.github.io/posts/2021/04/shoppe%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</link>
            <pubDate>Fri, 02 Apr 2021 09:35:00 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/04/shoppe%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</guid>
            <description>笔试（2021.03.10） 笔试应该是春招最早的几批，当天Shoppe的笔试平台还崩掉了，在牛客网上还有不少吐嘈，不过不久就恢复正常了，有一说一Shoppe的这个笔试系统还是不错的 笔试是一部分选择 + 3道编程题，选择题目已经记不住了，时间很久了 三道编程题目分别是(之所以能记住是因为有个小伙伴问过)：
 字符串abc abcabcabc判断第一个串重复n次能不能得到第二个，使用暴力递归处理 通过70% 归并数组 AC 正则表达式匹配， leetcode原题， AC  两轮面试的题目我凭印象大概写写吧
一面(2021.03.14) 时间也很久了，问的比较基础，是一个小姐姐
 重点是计算机网络，操作系统，数据库 白盒测试，黑盒测试 算法题：给定数组，将数组元素按出现次数排序并打印 算法题有点简单 SQL题：根据给定的条件写建表语句 差点栽了，因为我自己确实很少写SQL，勉强写了一个 反问  二面（2021.03.20）  介绍项目，项目中的难点 测试预约餐厅小程序的功能，角度尽可能全面，答的一般 算法题目，给定一个字符串，计算字符串中回文串的个数，给出测试用例，还要生成随机字符串来进行验证  分析时间复杂度，有没有更好的办法，答暴力法时间复杂度O(N^3), 还可以使用DP打表计算 如果一个字符串长为100万呢？ 答C++一秒大概执行10^7到10^8, 10^18次方要跑很久很久   wget用过没？ 答可以用来看google有没有连好。。。聊DNS污染，VPN的工作原理，聊网络知识 聊几个Linux命令，问为什么用Linux做桌面系统。。。 反问  HR面（2021.03.26）  经历 考研情况 城市意向 Offer情况 期望薪资 反问  收到意向书（2021年4月2日） 整体来说，整个流程比较常规，二面面试官问的点比较新鲜，面试官态度都很好</description>
            <content type="html"><![CDATA[<h2 id="笔试20210310">笔试（2021.03.10）</h2>
<p>笔试应该是春招最早的几批，当天Shoppe的笔试平台还崩掉了，在牛客网上还有不少吐嘈，不过不久就恢复正常了，有一说一Shoppe的这个笔试系统还是不错的
笔试是一部分选择 + 3道编程题，选择题目已经记不住了，时间很久了
三道编程题目分别是(之所以能记住是因为有个小伙伴问过)：</p>
<ol>
<li>字符串abc abcabcabc判断第一个串重复n次能不能得到第二个，使用暴力递归处理 通过70%</li>
<li>归并数组 AC</li>
<li>正则表达式匹配， leetcode原题， AC</li>
</ol>
<p>两轮面试的题目我凭印象大概写写吧</p>
<h2 id="一面20210314">一面(2021.03.14)</h2>
<p>时间也很久了，问的比较基础，是一个小姐姐</p>
<ol>
<li>重点是计算机网络，操作系统，数据库</li>
<li>白盒测试，黑盒测试</li>
<li>算法题：给定数组，将数组元素按出现次数排序并打印
算法题有点简单</li>
<li>SQL题：根据给定的条件写建表语句
差点栽了，因为我自己确实很少写SQL，勉强写了一个</li>
<li>反问</li>
</ol>
<h2 id="二面20210320">二面（2021.03.20）</h2>
<ol>
<li>介绍项目，项目中的难点</li>
<li>测试预约餐厅小程序的功能，角度尽可能全面，答的一般</li>
<li>算法题目，给定一个字符串，计算字符串中回文串的个数，给出测试用例，还要生成随机字符串来进行验证
<ol>
<li>分析时间复杂度，有没有更好的办法，答暴力法时间复杂度O(N^3), 还可以使用DP打表计算</li>
<li>如果一个字符串长为100万呢？ 答C++一秒大概执行10^7到10^8, 10^18次方要跑很久很久</li>
</ol>
</li>
<li>wget用过没？ 答可以用来看google有没有连好。。。聊DNS污染，VPN的工作原理，聊网络知识</li>
<li>聊几个Linux命令，问为什么用Linux做桌面系统。。。</li>
<li>反问</li>
</ol>
<h2 id="hr面20210326">HR面（2021.03.26）</h2>
<ol>
<li>经历</li>
<li>考研情况</li>
<li>城市意向</li>
<li>Offer情况</li>
<li>期望薪资</li>
<li>反问</li>
</ol>
<h2 id="收到意向书2021年4月2日">收到意向书（2021年4月2日）</h2>
<p>整体来说，整个流程比较常规，二面面试官问的点比较新鲜，面试官态度都很好</p>
]]></content>
        </item>
        
        <item>
            <title>字节跳动面试复盘</title>
            <link>https://oxygenbytes.github.io/posts/2021/03/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</link>
            <pubDate>Tue, 09 Mar 2021 12:46:52 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/03/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</guid>
            <description>一面（2021-02-24 18:00，1小时10分钟）  介绍自己 介绍项目，针对项目细节进行提问 浏览器输入一个地址，后面发生了什么？ 进程间通讯方式有哪些？ 死锁，原因与解除 const关键字和static关键字 define和const的区别 STL容器，vector, list, map, unordered_map, set效率及对应的底层结构 Redis与MySQL的区别 TCP的拥塞控制，流量控制，滑动窗口 如果当前面试界面崩溃了，如何排查问题 面向对象的三大特性 考研情况与意向城市 算法题：二叉树的镜像 反问  二面（2021-03-02 15:00，1小时30分钟）  介绍自己 介绍项目，介绍了很久   登录界面如何实现，如何测试 SQL注入 数据库中的表是如何组织的 为什么选用python 消息通知机制是如何实现的，如何改进  毕业设计题目，进度 C++语法，虚函数，虚函数表 深拷贝和浅拷贝，代码如何实现 引用和指针 分析结构体的内存对齐问题 malloc和free, new和delete，C++内存模型 迭代器失效的问题 C++程序的编译过程 计算机网络，DNS，HTTP，ARP，NAT，TCP, ICMP 上线的项目用户报告有问题，如何排查，如何定位问题 代码题：手写一个单例模式 是否了解其他设计模式 算法题：一个二位矩阵，矩阵中每个位置有不一样高的柱子，小球只能往高度相同的柱子或者更低的柱子滚动，判断一个小球能否滚落出矩阵 反问  三面（2021-03-08 11:00, 50分钟）  考研情况 去年面试字节的情况 介绍项目,前端，后端，数据库 用过抖音吗？在抖音买过东西吗？（没&amp;hellip;） 最常用的软件是什么？ （chrome） 如何对搜索引擎的搜索框进行测试 对搜索引擎技术还有那些了解 OSI模型和TCP/IP模型 算法题 给定一个字符串s，和字符串字典strDict，使用strDict中的字符串来组成s，并用|分割 代码写的很快，平时写代码多吗？是不是刷过很多题？为什么刷题？有哪些收获？ 谈到个人博客，为什么写博客？为什么博客打不开？（在github page上, 需要魔法。。） 考研不打算调剂吗？ 反问  HR面（2021-03-09 17:00，10分钟）  面试体验，对前面几位面试官的评价 为什么选择字节？ 为什么选测试开发 offer情况,态度最差的HR，问完之后说我没什么大厂offer，我当时刚开始春招，肯定没offer 城市意向 反问  </description>
            <content type="html"><![CDATA[<h2 id="一面2021-02-24-18001小时10分钟">一面（2021-02-24 18:00，1小时10分钟）</h2>
<ol>
<li>介绍自己</li>
<li>介绍项目，针对项目细节进行提问</li>
<li>浏览器输入一个地址，后面发生了什么？</li>
<li>进程间通讯方式有哪些？</li>
<li>死锁，原因与解除</li>
<li>const关键字和static关键字</li>
<li>define和const的区别</li>
<li>STL容器，vector, list, map, unordered_map, set效率及对应的底层结构</li>
<li>Redis与MySQL的区别</li>
<li>TCP的拥塞控制，流量控制，滑动窗口</li>
<li>如果当前面试界面崩溃了，如何排查问题</li>
<li>面向对象的三大特性</li>
<li>考研情况与意向城市</li>
<li>算法题：二叉树的镜像</li>
<li>反问</li>
</ol>
<h2 id="二面2021-03-02-15001小时30分钟">二面（2021-03-02 15:00，1小时30分钟）</h2>
<ol>
<li>介绍自己</li>
<li>介绍项目，介绍了很久</li>
</ol>
<ul>
<li>登录界面如何实现，如何测试</li>
<li>SQL注入</li>
<li>数据库中的表是如何组织的</li>
<li>为什么选用python</li>
<li>消息通知机制是如何实现的，如何改进</li>
</ul>
<ol start="3">
<li>毕业设计题目，进度</li>
<li>C++语法，虚函数，虚函数表</li>
<li>深拷贝和浅拷贝，代码如何实现</li>
<li>引用和指针</li>
<li>分析结构体的内存对齐问题</li>
<li>malloc和free, new和delete，C++内存模型</li>
<li>迭代器失效的问题</li>
<li>C++程序的编译过程</li>
<li>计算机网络，DNS，HTTP，ARP，NAT，TCP, ICMP</li>
<li>上线的项目用户报告有问题，如何排查，如何定位问题</li>
<li>代码题：手写一个单例模式</li>
<li>是否了解其他设计模式</li>
<li>算法题：一个二位矩阵，矩阵中每个位置有不一样高的柱子，小球只能往高度相同的柱子或者更低的柱子滚动，判断一个小球能否滚落出矩阵</li>
<li>反问</li>
</ol>
<h2 id="三面2021-03-08-1100-50分钟">三面（2021-03-08 11:00, 50分钟）</h2>
<ol>
<li>考研情况</li>
<li>去年面试字节的情况</li>
<li>介绍项目,前端，后端，数据库</li>
<li>用过抖音吗？在抖音买过东西吗？（没&hellip;）</li>
<li>最常用的软件是什么？ （chrome）</li>
<li>如何对搜索引擎的搜索框进行测试</li>
<li>对搜索引擎技术还有那些了解</li>
<li>OSI模型和TCP/IP模型</li>
<li>算法题 给定一个字符串s，和字符串字典strDict，使用strDict中的字符串来组成s，并用|分割</li>
<li>代码写的很快，平时写代码多吗？是不是刷过很多题？为什么刷题？有哪些收获？</li>
<li>谈到个人博客，为什么写博客？为什么博客打不开？（在github page上, 需要魔法。。）</li>
<li>考研不打算调剂吗？</li>
<li>反问</li>
</ol>
<h2 id="hr面2021-03-09-170010分钟">HR面（2021-03-09 17:00，10分钟）</h2>
<ol>
<li>面试体验，对前面几位面试官的评价</li>
<li>为什么选择字节？</li>
<li>为什么选测试开发</li>
<li>offer情况,态度最差的HR，问完之后说我没什么大厂offer，我当时刚开始春招，肯定没offer</li>
<li>城市意向</li>
<li>反问</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>排序算法</title>
            <link>https://oxygenbytes.github.io/posts/2021/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
            <pubDate>Wed, 03 Mar 2021 22:35:34 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/03/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
            <description>冒泡排序 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; void bubblesort(vector&amp;lt;int&amp;gt;&amp;amp; nums){ int n = nums.size(); for(int i = n - 1;i &amp;gt; 0;i--){ for(int j = 0;j &amp;lt; i;j++){ if(nums[j] &amp;gt; nums[j+1]) swap(nums[j], nums[j+1]); } } } int main(){ vector&amp;lt;int&amp;gt; nums(10); srand(unsigned(time(0))); // srand((unsigned)time(NULL)) 也可以  for(int i = 0;i &amp;lt; 10;i++){ nums[i] = rand() % 20; cout&amp;lt;&amp;lt;nums[i]&amp;lt;&amp;lt;&amp;#34; &amp;#34;; } cout&amp;lt;&amp;lt;endl; bubblesort(nums); for(auto x : nums) cout&amp;lt;&amp;lt;x&amp;lt;&amp;lt;&amp;#34; &amp;#34;; cout&amp;lt;&amp;lt;endl; return 0; } 选择排序 #include &amp;lt;bits/stdc++.</description>
            <content type="html"><![CDATA[<h2 id="冒泡排序">冒泡排序</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">bubblesort</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums){
    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> nums.size();

    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>;i<span style="color:#f92672">--</span>){
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;j <span style="color:#f92672">&lt;</span> i;j<span style="color:#f92672">++</span>){
            <span style="color:#66d9ef">if</span>(nums[j] <span style="color:#f92672">&gt;</span> nums[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>])
                swap(nums[j], nums[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>]);
        }
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums(<span style="color:#ae81ff">10</span>);
    srand(<span style="color:#66d9ef">unsigned</span>(time(<span style="color:#ae81ff">0</span>)));
    <span style="color:#75715e">// srand((unsigned)time(NULL)) 也可以
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>;i<span style="color:#f92672">++</span>){
        nums[i] <span style="color:#f92672">=</span> rand() <span style="color:#f92672">%</span> <span style="color:#ae81ff">20</span>;
        cout<span style="color:#f92672">&lt;&lt;</span>nums[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
    }
    cout<span style="color:#f92672">&lt;&lt;</span>endl;
    bubblesort(nums);
    
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> x : nums) cout<span style="color:#f92672">&lt;&lt;</span>x<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
    cout<span style="color:#f92672">&lt;&lt;</span>endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="选择排序">选择排序</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">selectsort</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums){
    
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;i<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">int</span> min <span style="color:#f92672">=</span> i;
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;j <span style="color:#f92672">&lt;</span> nums.size();j<span style="color:#f92672">++</span>){
            <span style="color:#66d9ef">if</span>(nums[j] <span style="color:#f92672">&lt;</span> nums[min])
                min <span style="color:#f92672">=</span> j;
        }
        swap(nums[min], nums[i]);
    }
}


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums(<span style="color:#ae81ff">10</span>);
    srand(<span style="color:#66d9ef">unsigned</span>(time(<span style="color:#ae81ff">0</span>)));
    
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>;i<span style="color:#f92672">++</span>){
        nums[i] <span style="color:#f92672">=</span> rand() <span style="color:#f92672">%</span> <span style="color:#ae81ff">20</span>;
        cout<span style="color:#f92672">&lt;&lt;</span>nums[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
    }
    cout<span style="color:#f92672">&lt;&lt;</span>endl;
    selectsort(nums);
    
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> x : nums) cout<span style="color:#f92672">&lt;&lt;</span>x<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
    cout<span style="color:#f92672">&lt;&lt;</span>endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="插入排序">插入排序</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">insertsort</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums){
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;i <span style="color:#f92672">&lt;</span> nums.size();i<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">int</span> t <span style="color:#f92672">=</span> nums[i], j;
        <span style="color:#66d9ef">for</span>(j <span style="color:#f92672">=</span> i <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> ;j <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;j<span style="color:#f92672">--</span>){
            <span style="color:#66d9ef">if</span>(nums[j] <span style="color:#f92672">&gt;</span> t){
                nums[j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> nums[j];
                
            }<span style="color:#66d9ef">else</span>{
                <span style="color:#66d9ef">break</span>;
            }
        }
        nums[j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> t;
    }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums(<span style="color:#ae81ff">10</span>);
    srand(<span style="color:#66d9ef">unsigned</span>(time(<span style="color:#ae81ff">0</span>)));
    
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>;i<span style="color:#f92672">++</span>){
        nums[i] <span style="color:#f92672">=</span> rand() <span style="color:#f92672">%</span> <span style="color:#ae81ff">20</span>;
        cout<span style="color:#f92672">&lt;&lt;</span>nums[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
    }
    cout<span style="color:#f92672">&lt;&lt;</span>endl;
    insertsort(nums);
    
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> x : nums) cout<span style="color:#f92672">&lt;&lt;</span>x<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
    cout<span style="color:#f92672">&lt;&lt;</span>endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="希尔排序">希尔排序</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">shellsort</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums) {
    <span style="color:#66d9ef">int</span> length <span style="color:#f92672">=</span> nums.size();
    <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">while</span> (h <span style="color:#f92672">&lt;</span> length <span style="color:#f92672">/</span> <span style="color:#ae81ff">3</span>) {
        h <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> <span style="color:#f92672">*</span> h <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    <span style="color:#66d9ef">while</span> (h <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">1</span>) {
        <span style="color:#75715e">// 希尔排序大的关键就是每次一个节点都向前移动h步长，这样可以更快的接近自己的目标位置，从而获得较好的时间复杂度
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 这里的i是[h...end], h是[j, i]
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> h; i <span style="color:#f92672">&lt;</span> length; i<span style="color:#f92672">++</span>) {
            cout<span style="color:#f92672">&lt;&lt;</span>h<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">&lt;&lt;</span>i<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;
            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> i; j <span style="color:#f92672">&gt;=</span> h <span style="color:#f92672">&amp;&amp;</span> nums[j] <span style="color:#f92672">&lt;</span> nums[j <span style="color:#f92672">-</span> h]; j <span style="color:#f92672">-=</span> h) {
                <span style="color:#75715e">//cout&lt;&lt;j&lt;&lt;&#34; &#34;&lt;&lt;j-h&lt;&lt;endl;
</span><span style="color:#75715e"></span>                cnt<span style="color:#f92672">++</span>;
                swap(nums[j], nums[j<span style="color:#f92672">-</span>h]);
            }
        }
        h <span style="color:#f92672">=</span> h <span style="color:#f92672">/</span> <span style="color:#ae81ff">3</span>;
    }
    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;Time O(&#34;</span>;
    cout<span style="color:#f92672">&lt;&lt;</span>((<span style="color:#66d9ef">double</span>)cnt <span style="color:#f92672">/</span> length )<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;)&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>;
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums(n);
    srand(<span style="color:#66d9ef">unsigned</span>(time(<span style="color:#ae81ff">0</span>)));
    
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> n;i<span style="color:#f92672">++</span>){
        nums[i] <span style="color:#f92672">=</span> rand() <span style="color:#f92672">%</span> <span style="color:#ae81ff">20</span>;
        cout<span style="color:#f92672">&lt;&lt;</span>nums[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
    }
    cout<span style="color:#f92672">&lt;&lt;</span>endl;
    shellsort(nums);
    
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> x : nums) cout<span style="color:#f92672">&lt;&lt;</span>x<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
    cout<span style="color:#f92672">&lt;&lt;</span>endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="归并排序">归并排序</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> n  <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
<span style="color:#66d9ef">int</span> aux[n];

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">merge</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> mid, <span style="color:#66d9ef">int</span> right){
    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> left, j <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> left;k <span style="color:#f92672">&lt;=</span> right;k<span style="color:#f92672">++</span>) aux[k] <span style="color:#f92672">=</span> nums[k];

    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> left;k <span style="color:#f92672">&lt;=</span> right;k<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&gt;</span> mid) nums[k] <span style="color:#f92672">=</span> aux[j<span style="color:#f92672">++</span>];
        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(j <span style="color:#f92672">&gt;</span> right) nums[k] <span style="color:#f92672">=</span> aux[i<span style="color:#f92672">++</span>]; <span style="color:#75715e">// 互斥关系，必须使用else if
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span>(aux[i] <span style="color:#f92672">&gt;</span> aux[j]) nums[k] <span style="color:#f92672">=</span> aux[j<span style="color:#f92672">++</span>];
        <span style="color:#66d9ef">else</span> nums[k] <span style="color:#f92672">=</span> aux[i<span style="color:#f92672">++</span>];
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">mergesort</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right){
    <span style="color:#66d9ef">if</span>(left <span style="color:#f92672">&gt;=</span> right) <span style="color:#66d9ef">return</span> ;
    <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> (right <span style="color:#f92672">-</span> left) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> left;
    mergesort(nums, left, mid);
    mergesort(nums, mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, right);
    merge(nums, left, mid, right);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){

    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums(n);
    srand(<span style="color:#66d9ef">unsigned</span>(time(<span style="color:#ae81ff">0</span>)));
    
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> n;i<span style="color:#f92672">++</span>){
        nums[i] <span style="color:#f92672">=</span> rand() <span style="color:#f92672">%</span> <span style="color:#ae81ff">20</span>;
        cout<span style="color:#f92672">&lt;&lt;</span>nums[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
    }
    cout<span style="color:#f92672">&lt;&lt;</span>endl;
    mergesort(nums, <span style="color:#ae81ff">0</span>, nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> x : nums) cout<span style="color:#f92672">&lt;&lt;</span>x<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
    cout<span style="color:#f92672">&lt;&lt;</span>endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="快速排序">快速排序</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">partition</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right){
    <span style="color:#66d9ef">int</span> pivot <span style="color:#f92672">=</span> left;

    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> left;
    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> right <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">while</span>(true){
        <span style="color:#66d9ef">while</span>(nums[<span style="color:#f92672">++</span>i] <span style="color:#f92672">&lt;</span> nums[pivot]) <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">==</span> right) <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">while</span>(nums[<span style="color:#f92672">--</span>j] <span style="color:#f92672">&gt;</span> nums[pivot]) <span style="color:#66d9ef">if</span>(j <span style="color:#f92672">==</span> left) <span style="color:#66d9ef">break</span>;
        <span style="color:#66d9ef">if</span>(i <span style="color:#f92672">&gt;=</span> j) <span style="color:#66d9ef">break</span>;
        swap(nums[i], nums[j]);
    }
    swap(nums[pivot], nums[j]);
    <span style="color:#66d9ef">return</span> j;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">quicksort</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right){
    <span style="color:#66d9ef">if</span>(left <span style="color:#f92672">&gt;=</span> right) <span style="color:#66d9ef">return</span> ;
    
    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> partition(nums, left, right);
    quicksort(nums, left, j<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
    quicksort(nums, j<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>, right);
}   

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){

    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums(n);
    srand(<span style="color:#66d9ef">unsigned</span>(time(<span style="color:#ae81ff">0</span>)));
    
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> n;i<span style="color:#f92672">++</span>){
        nums[i] <span style="color:#f92672">=</span> rand() <span style="color:#f92672">%</span> <span style="color:#ae81ff">20</span>;
        cout<span style="color:#f92672">&lt;&lt;</span>nums[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
    }
    cout<span style="color:#f92672">&lt;&lt;</span>endl;
    quicksort(nums, <span style="color:#ae81ff">0</span>, nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> x : nums) cout<span style="color:#f92672">&lt;&lt;</span>x<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
    cout<span style="color:#f92672">&lt;&lt;</span>endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="堆排序">堆排序</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">heapify</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right){
    <span style="color:#66d9ef">int</span> dad <span style="color:#f92672">=</span> left;
    <span style="color:#66d9ef">int</span> son <span style="color:#f92672">=</span> dad <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;

    <span style="color:#66d9ef">while</span>(son <span style="color:#f92672">&lt;=</span> right){
        <span style="color:#66d9ef">if</span>(son <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;=</span> right <span style="color:#f92672">&amp;&amp;</span> nums[son <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">&gt;</span> nums[son]){
            son <span style="color:#f92672">=</span> son <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        }
        <span style="color:#66d9ef">if</span>(nums[dad] <span style="color:#f92672">&gt;</span> nums[son]){
            <span style="color:#66d9ef">return</span> ;
        }<span style="color:#66d9ef">else</span>{
            swap(nums[dad], nums[son]);
            dad <span style="color:#f92672">=</span> son;
            son <span style="color:#f92672">=</span> dad <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
        }
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">heapsort</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> nums, <span style="color:#66d9ef">int</span> left, <span style="color:#66d9ef">int</span> right){
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> right <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;i<span style="color:#f92672">--</span>){
        heapify(nums, i, right);
    }

    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> right;i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>;i<span style="color:#f92672">--</span>){
        swap(nums[i], nums[<span style="color:#ae81ff">0</span>]);
        heapify(nums, <span style="color:#ae81ff">0</span>, i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    }
}


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> nums(n);
    srand(<span style="color:#66d9ef">unsigned</span>(time(<span style="color:#ae81ff">0</span>)));
    
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> n;i<span style="color:#f92672">++</span>){
        nums[i] <span style="color:#f92672">=</span> rand() <span style="color:#f92672">%</span> <span style="color:#ae81ff">20</span>;
        cout<span style="color:#f92672">&lt;&lt;</span>nums[i]<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
    }
    cout<span style="color:#f92672">&lt;&lt;</span>endl;
    heapsort(nums, <span style="color:#ae81ff">0</span>, nums.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
    
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> x : nums) cout<span style="color:#f92672">&lt;&lt;</span>x<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
    cout<span style="color:#f92672">&lt;&lt;</span>endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>蓝湖面试复盘</title>
            <link>https://oxygenbytes.github.io/posts/2021/03/%E8%93%9D%E6%B9%96%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</link>
            <pubDate>Wed, 03 Mar 2021 19:46:52 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/03/%E8%93%9D%E6%B9%96%E9%9D%A2%E8%AF%95%E5%A4%8D%E7%9B%98/</guid>
            <description>时间比较久了，重点记一下算法题和答的不好的问题
一面  算法题：实现整数的sqrt函数， 使用二分法做  二面  算法题：算法题找出一个数组中，出现次数最多的两个数   我最开始用unordered_map, 后来面试官说空间复杂度可以优化，时间复杂度也可以优化，最后尝试写了一个0（n）的算法
 2：问了一下http头部有什么字段，我只说了最常见的三五个，因为没仔细记忆过</description>
            <content type="html"><![CDATA[<p>时间比较久了，重点记一下算法题和答的不好的问题</p>
<h2 id="一面">一面</h2>
<ol>
<li>算法题：实现整数的sqrt函数， 使用二分法做</li>
</ol>
<h2 id="二面">二面</h2>
<ol>
<li>算法题：算法题找出一个数组中，出现次数最多的两个数</li>
</ol>
<blockquote>
<p>我最开始用unordered_map, 后来面试官说空间复杂度可以优化，时间复杂度也可以优化，最后尝试写了一个0（n）的算法</p>
</blockquote>
<p>2：问了一下http头部有什么字段，我只说了最常见的三五个，因为没仔细记忆过</p>
]]></content>
        </item>
        
        <item>
            <title>C&#43;&#43;对象模型</title>
            <link>https://oxygenbytes.github.io/posts/2021/02/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</link>
            <pubDate>Tue, 23 Feb 2021 17:38:43 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/02/c-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B/</guid>
            <description>什么是C++对象模型?  语言中直接支持面向对象程序设计的部分。 对于各种支持的底层实现机制。  对象模型研究的是对象在存储上的空间与时间上的更优，并对C++面向对象技术加以支持，如以虚指针、虚表机制支持多态特性。
理解虚函数表 C++中虚函数的作用主要是为了实现多态机制。多态，简单来说，是指在继承层次中，父类的指针可以具有多种形态——当它指向某个子类对象时，通过它能够调用到子类的函数，而非父类的函数。
#include &amp;lt;iostream&amp;gt;using namespace std; class Base { public: virtual void print(){ cout&amp;lt;&amp;lt;&amp;#34;Base&amp;#34;&amp;lt;&amp;lt;endl;}; }; class Derive : public Base{ public: virtual void print(){cout&amp;lt;&amp;lt;&amp;#34;Derive&amp;#34;&amp;lt;&amp;lt;endl;}; }; int main(){ Base* ptr1 = new Base; Base* ptr2 = new Derive; ptr1-&amp;gt;print(); // Base::print();  ptr2-&amp;gt;print(); // Derive::print();  return 0; } 这是一种运行期多态，即父类指针唯有在程序运行时才能知道所指的真正类型是什么。这种运行期决议，是通过虚函数表来实现的。
使用指针访问虚表 #include &amp;lt;iostream&amp;gt;using namespace std; class Base { private: int a; public: virtual void test(){ cout&amp;lt;&amp;lt;&amp;#34;test&amp;#34;&amp;lt;&amp;lt;endl; } virtual void print(){ cout&amp;lt;&amp;lt;&amp;#34;Base&amp;#34;&amp;lt;&amp;lt;endl;} }; typedef void(*Func)(void); int main(){ Base b; int * vptrAdree = (int *)(&amp;amp;b); cout&amp;lt;&amp;lt;vptrAdree&amp;lt;&amp;lt;endl; Func fun = (Func)*(int * )(*(int*)(&amp;amp;b)+8); fun(); // Base  return 0; } 我们强行把类对象的地址转换为 int* 类型，取得了虚函数指针的地址。虚函数指针指向虚函数表,虚函数表中存储的是一系列虚函数的地址，虚函数地址出现的顺序与类中虚函数声明的顺序一致。对虚函数指针地址值，可以得到虚函数表的地址，也即是虚函数表第二个虚函数的地址。</description>
            <content type="html"><![CDATA[<h2 id="什么是c对象模型">什么是C++对象模型?</h2>
<ol>
<li>语言中直接支持面向对象程序设计的部分。</li>
<li>对于各种支持的底层实现机制。</li>
</ol>
<p>对象模型研究的是对象在存储上的空间与时间上的更优，并对C++面向对象技术加以支持，如以虚指针、虚表机制支持多态特性。</p>
<h2 id="理解虚函数表">理解虚函数表</h2>
<p>C++中虚函数的作用主要是为了实现多态机制。多态，简单来说，是指在继承层次中，父类的指针可以具有多种形态——当它指向某个子类对象时，通过它能够调用到子类的函数，而非父类的函数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	 <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> print(){ cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;Base&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;};
};
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Derive</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> Base{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> print(){cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;Derive&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;};
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){

    Base<span style="color:#f92672">*</span> ptr1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Base;
    Base<span style="color:#f92672">*</span> ptr2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Derive;

    ptr1<span style="color:#f92672">-&gt;</span>print(); <span style="color:#75715e">// Base::print();
</span><span style="color:#75715e"></span>    ptr2<span style="color:#f92672">-&gt;</span>print(); <span style="color:#75715e">// Derive::print();
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>这是一种运行期多态，即父类指针唯有在程序运行时才能知道所指的真正类型是什么。这种运行期决议，是通过虚函数表来实现的。</p>
<h2 id="使用指针访问虚表">使用指针访问虚表</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Base</span> {
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">int</span> a;
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> test(){
		cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;test&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;
	}
	<span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>(){ cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;Base&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;}
};


<span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">void</span>(<span style="color:#f92672">*</span>Func)(<span style="color:#66d9ef">void</span>);


<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){

	Base b;
	<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> vptrAdree <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)(<span style="color:#f92672">&amp;</span>b);  
	cout<span style="color:#f92672">&lt;&lt;</span>vptrAdree<span style="color:#f92672">&lt;&lt;</span>endl;

	Func fun <span style="color:#f92672">=</span> (Func)<span style="color:#f92672">*</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span> )(<span style="color:#f92672">*</span>(<span style="color:#66d9ef">int</span><span style="color:#f92672">*</span>)(<span style="color:#f92672">&amp;</span>b)<span style="color:#f92672">+</span><span style="color:#ae81ff">8</span>);

	fun(); <span style="color:#75715e">// Base
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

</code></pre></div><p>我们强行把类对象的地址转换为 int* 类型，取得了虚函数指针的地址。虚函数指针指向虚函数表,虚函数表中存储的是一系列虚函数的地址，虚函数地址出现的顺序与类中虚函数声明的顺序一致。对虚函数指针地址值，可以得到虚函数表的地址，也即是虚函数表第二个虚函数的地址。</p>
<h1 id="对象模型概述">对象模型概述</h1>
<p>在C++中，有两种数据成员（class data members）：static 和nonstatic,以及三种类成员函数（class member functions）:static、nonstatic和virtual:</p>
<p>那么，这个类在内存中将被如何表示？5种数据都是连续存放的吗？如何布局才能支持C++多态？ 我们的C++标准与编译器将如何塑造出各种数据成员与成员函数呢？</p>
<h2 id="41简单对象模型">4.1.简单对象模型</h2>
<p><strong>说明：在下面出现的图中，用蓝色边框框起来的内容在内存上是连续的。</strong>
这个模型非常地简单粗暴。在该模型下，对象由一系列的指针组成，每一个指针都指向一个数据成员或成员函数，也即是说，每个数据成员和成员函数在类中所占的大小是相同的，都为一个指针的大小。这样有个好处——很容易算出对象的大小，不过赔上的是空间和执行期效率。想象一下，如果我们的Point3d类是这种模型，将会比C语言的struct多了许多空间来存放指向函数的指针，而且每次读取类的数据成员，都需要通过再一次寻址——又是时间上的消耗。
所以这种对象模型并没有被用于实际产品上。</p>
<h2 id="42表格驱动模型">4.2.表格驱动模型</h2>
<p>这个模型在简单对象模型的基础上又添加一个间接层，它把类中的数据分成了两个部分：数据部分与函数部分，并使用两张表格，一张存放数据本身，一张存放函数的地址（也即函数比成员多一次寻址），而类对象仅仅含有两个指针，分别指向上面这两个表。这样看来，对象的大小是固定为两个指针大小。这个模型也没有用于实际应用于真正的C++编译器上。</p>
<h2 id="43非继承下的c对象模型">4.3.非继承下的C++对象模型</h2>
<p>概述：在此模型下，nonstatic 数据成员被置于每一个类对象中，而static数据成员被置于类对象之外。static与nonstatic函数也都放在类对象之外，而对于virtual 函数，则通过虚函数表+虚指针来支持，具体如下：</p>
<ul>
<li>每个类生成一个表格，称为虚表（virtual table，简称vtbl）。虚表中存放着一堆指针，这些指针指向该类每一个虚函数。虚表中的函数地址将按声明时的顺序排列，不过当子类有多个重载函数时例外，后面会讨论。</li>
<li>每个类对象都拥有一个虚表指针(vptr)，由编译器为其生成。虚表指针的设定与重置皆由类的复制控制（也即是构造函数、析构函数、赋值操作符）来完成。vptr的位置为编译器决定，传统上它被放在所有显示声明的成员之后，不过现在许多编译器把vptr放在一个类对象的最前端。
另外，虚函数表的前面设置了一个指向type_info的指针，用以支持RTTI（Run Time Type Identification，运行时类型识别）。RTTI是为多态而生成的信息，包括对象继承关系，对象本身的描述等，只有具有虚函数的对象在会生成。</li>
</ul>
<h3 id="参考">参考</h3>
<ol>
<li><a href="https://www.cnblogs.com/QG-whz/p/4909359.html">图说C++对象模型：对象内存布局详解</a></li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>Docker 学习</title>
            <link>https://oxygenbytes.github.io/posts/2021/01/docker-%E5%AD%A6%E4%B9%A0/</link>
            <pubDate>Sat, 30 Jan 2021 21:49:10 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/01/docker-%E5%AD%A6%E4%B9%A0/</guid>
            <description>一、解决的问题 由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。
Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其他机器中。
二、与虚拟机的比较 虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。
启动速度 启动虚拟机需要启动虚拟机的操作系统，再启动应用，这个过程非常慢；
而启动 Docker 相当于启动宿主操作系统上的一个进程。
占用资源 虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU，一台机器只能开启几十个的虚拟机。
而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。
三、优势 除了启动速度快以及占用资源少之外，Docker 具有以下优势：
更容易迁移 提供一致性的运行环境，可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。
更容易维护 使用分层技术和镜像，使得应用可以更容易复用重复部分。复用程度越高，维护工作也越容易。
更容易扩展 可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。
四、使用场景 持续集成 持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。
Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。
提供可伸缩的云服务 根据应用的负载情况，可以很容易地增加或者减少 Docker。
搭建微服务架构 Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。
五、镜像与容器 镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。
镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。
构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。
Ubuntu上docker的安装和配置 脚本如下：
#!/bin/sh  # Shell script to add docker-ce to Deepin Linux repositories # Remove old docker sudo apt-get remove -y docker docker-engine docker.</description>
            <content type="html"><![CDATA[<h1 id="一解决的问题">一、解决的问题</h1>
<p>由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。</p>
<p>Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其他机器中。</p>
<h1 id="二与虚拟机的比较">二、与虚拟机的比较</h1>
<p>虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。</p>
<h2 id="启动速度">启动速度</h2>
<p>启动虚拟机需要启动虚拟机的操作系统，再启动应用，这个过程非常慢；</p>
<p>而启动 Docker 相当于启动宿主操作系统上的一个进程。</p>
<h2 id="占用资源">占用资源</h2>
<p>虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU，一台机器只能开启几十个的虚拟机。</p>
<p>而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。</p>
<h1 id="三优势">三、优势</h1>
<p>除了启动速度快以及占用资源少之外，Docker 具有以下优势：</p>
<h2 id="更容易迁移">更容易迁移</h2>
<p>提供一致性的运行环境，可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。</p>
<h2 id="更容易维护">更容易维护</h2>
<p>使用分层技术和镜像，使得应用可以更容易复用重复部分。复用程度越高，维护工作也越容易。</p>
<h2 id="更容易扩展">更容易扩展</h2>
<p>可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。</p>
<h1 id="四使用场景">四、使用场景</h1>
<h2 id="持续集成">持续集成</h2>
<p>持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。</p>
<p>Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。</p>
<h2 id="提供可伸缩的云服务">提供可伸缩的云服务</h2>
<p>根据应用的负载情况，可以很容易地增加或者减少 Docker。</p>
<h2 id="搭建微服务架构">搭建微服务架构</h2>
<p>Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。</p>
<h1 id="五镜像与容器">五、镜像与容器</h1>
<p>镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。</p>
<p>镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。</p>
<p>构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。</p>
<h1 id="ubuntu上docker的安装和配置">Ubuntu上docker的安装和配置</h1>
<p>脚本如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/bin/sh
</span><span style="color:#75715e"></span>
<span style="color:#75715e"># Shell script to add docker-ce to Deepin Linux repositories</span>

<span style="color:#75715e"># Remove old docker</span>
sudo apt-get remove -y docker docker-engine docker.io containerd runc

<span style="color:#75715e"># Install dependencies</span>
sudo apt-get install -y apt-transport-https ca-certificates curl gnupg2 software-properties-common
    
<span style="color:#75715e"># Add GPG and fingerprint</span>
curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -
sudo apt-key fingerprint 0EBFCD88

<span style="color:#75715e"># Add debian repository in deepin sources list</span>
printf <span style="color:#e6db74">&#39;deb [arch=amd64] https://download.docker.com/linux/debian buster stable\n&#39;</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span>| sudo tee /etc/apt/sources.list.d/docker-ce.list

<span style="color:#75715e"># Update packages and install</span>
sudo apt-get update -y
sudo apt-get install -y docker-ce

<span style="color:#75715e"># Add current user to the docker users group (OPTIONAL)</span>
sudo usermod -aG docker <span style="color:#66d9ef">$(</span>whoami<span style="color:#66d9ef">)</span>

sudo groupadd docker
sudo gpasswd -a $USER docker 
newgrp docker
docker ps 

sudo vim /etc/docker/daemon.json
</code></pre></div><p>编辑daemon.json文件并配置容器镜像</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">{</span>
  <span style="color:#e6db74">&#34;registry-mirrors&#34;</span>: <span style="color:#f92672">[</span>
    <span style="color:#e6db74">&#34;https://hub-mirror.c.163.com&#34;</span>,
    <span style="color:#e6db74">&#34;https://mirror.baidubce.com&#34;</span>
  <span style="color:#f92672">]</span>
<span style="color:#f92672">}</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Git 学习</title>
            <link>https://oxygenbytes.github.io/posts/2021/01/git-%E5%AD%A6%E4%B9%A0/</link>
            <pubDate>Sat, 30 Jan 2021 21:49:10 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/01/git-%E5%AD%A6%E4%B9%A0/</guid>
            <description>本节主要记录一些git学习的笔记内容
git学习链接
git分支管理  新建分支 git checkout -b branchname 切换分支 git checkout branchname 查看分支 git branch 查看所有分支 git branch -av  比如你现在在dev，克隆下来的是主分支(main)
如果你要进行什么修改，可以建一个新的分之，比如按照今天的日期
git checkout -b 190721 # 创建并切换分支 git checkout 190721 # 直接切换分支 当系统重装后，如何连接git和github github官方参考链接
先下载git
sudo apt-get git # deepin sudo pacman -S git #manjaro 然后为本地 git 配置全局的 user 与 email 参数。
git config ‐‐global user.name &amp;#34;your github account name&amp;#34; git config ‐‐global user.email &amp;#34;your github account email&amp;#34; 为了在后续操作中我们能将本地仓库的代码推送至 github 的仓库上,我们需要在本地生成 SSH 秘钥,并将公钥保存到 github 账户信息中,这样我们在本地提交的时候 github 就能通 过本地的私钥与公钥进行校验。</description>
            <content type="html"><![CDATA[<p>本节主要记录一些git学习的笔记内容</p>
<p><a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html">git学习链接</a></p>
<h2 id="git分支管理">git分支管理</h2>
<ol>
<li>新建分支      git checkout -b branchname</li>
<li>切换分支      git checkout  branchname</li>
<li>查看分支      git branch</li>
<li>查看所有分支   git branch -av</li>
</ol>
<p>比如你现在在dev，克隆下来的是主分支(main)</p>
<p>如果你要进行什么修改，可以建一个新的分之，比如按照今天的日期</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git checkout -b <span style="color:#ae81ff">190721</span>
<span style="color:#75715e"># 创建并切换分支</span>
git checkout <span style="color:#ae81ff">190721</span>
<span style="color:#75715e"># 直接切换分支</span>
</code></pre></div><h2 id="当系统重装后如何连接git和github">当系统重装后，如何连接git和github</h2>
<p><a href="https://docs.github.com/en/github/authenticating-to-github/troubleshooting-ssh">github官方参考链接</a></p>
<p>先下载git</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">sudo apt-get git <span style="color:#75715e"># deepin</span>
sudo pacman -S git <span style="color:#75715e">#manjaro</span>
</code></pre></div><p>然后为本地 git 配置全局的 user 与 email 参数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">git config ‐‐global user.name <span style="color:#e6db74">&#34;your github account name&#34;</span>
git config ‐‐global user.email <span style="color:#e6db74">&#34;your github account email&#34;</span>
</code></pre></div><p>为了在后续操作中我们能将本地仓库的代码推送至 github 的仓库上,我们需要在本地生成
SSH 秘钥,并将公钥保存到 github 账户信息中,这样我们在本地提交的时候 github 就能通
过本地的私钥与公钥进行校验。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ssh‐keygen ‐t rsa ‐C <span style="color:#e6db74">&#34;your github account email&#34;</span>
</code></pre></div><p>复制当前主目录下~/.ssh/id_rsa.pub，只需要把公钥的内容提交给 github 。</p>
<p>进入Github的个人setting 界面,选择 SSH and GPG keys ,点击 New SSH key ,在展开的窗口中填写密钥信息,title 可以随意，方便自己管理即可,key 那一栏则把刚刚生成的 id_rsa.pub 的内容复制进去。最后点击按钮添加。</p>
<p>测试是否连接到github</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">ssh -T git@github.com
</code></pre></div><h3 id="问题一">问题一</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ssh -vT git@github.com
&gt; ...
&gt; Agent admitted failure to sign using the key.
&gt; debug1: No more authentication methods to try.
&gt; Permission denied <span style="color:#f92672">(</span>publickey<span style="color:#f92672">)</span>.
</code></pre></div><p>采取措施</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># star图片t the ssh-agent in the background</span>
eval <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>ssh-agent -s<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>
&gt; Agent pid <span style="color:#ae81ff">59566</span>
ssh-add
&gt; Enter passphrase <span style="color:#66d9ef">for</span> /home/you/.ssh/id_rsa: <span style="color:#f92672">[</span>tippy tap<span style="color:#f92672">]</span>
&gt; Identity added: /home/you/.ssh/id_rsa <span style="color:#f92672">(</span>/home/you/.ssh/id_rsa<span style="color:#f92672">)</span>
</code></pre></div><h3 id="问题二">问题二</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">permissions <span style="color:#ae81ff">0777</span> <span style="color:#66d9ef">for</span> <span style="color:#e6db74">&#39;~/.ssh/id_rsa&#39;</span> are too open
</code></pre></div><p>采取措施</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">chmod -R <span style="color:#ae81ff">700</span> id_rsa id_rsa.pub known_hosts passwd
</code></pre></div><h2 id="版本回退">版本回退</h2>
<ul>
<li><code>git reset --hard HEAD^</code> 回退到上一版本</li>
<li><code>git reset --hard HEAD^^</code> 回退到上上版本</li>
<li><code>git reset --hard HEAD~100</code> 回退到上100个版本</li>
<li><code>git reset --hard 具体版本号</code> 回退到具体版本号</li>
<li><code>git reflog</code> 记录每一次命令</li>
<li><code>git checkout -- readme.txt</code> 命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：
<ul>
<li>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</li>
<li>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</li>
<li>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</li>
</ul>
</li>
</ul>
<h2 id="git添加远程分支">Git添加远程分支</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># create a new repository on the command line</span>
echo <span style="color:#e6db74">&#34;# hugo-blog-theme&#34;</span> &gt;&gt; README.md
git init
git add README.md
git commit -m <span style="color:#e6db74">&#34;first commit&#34;</span>
git branch -M main
git remote add origin https://github.com/oxygenbytes/hugo-blog-theme.git
git push -u origin main

<span style="color:#75715e"># push an existing repository from the command line</span>
git remote add origin https://github.com/oxygenbytes/hugo-blog-theme.git
git branch -M main
git push -u origin main
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Linux 学习</title>
            <link>https://oxygenbytes.github.io/posts/2021/01/linux-%E5%AD%A6%E4%B9%A0/</link>
            <pubDate>Sat, 30 Jan 2021 21:49:10 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/01/linux-%E5%AD%A6%E4%B9%A0/</guid>
            <description>一、常用操作以及概念 快捷键  Tab：命令和文件名补全； Ctrl+C：中断正在运行的程序； Ctrl+D：结束键盘输入（End Of File，EOF）  求助 1. &amp;ndash;help 指令的基本用法与选项介绍。
2. man man 是 manual 的缩写，将指令的具体信息显示出来。
当执行man date时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下：
   代号 类型     1 用户在 shell 环境中可以操作的指令或者可执行文件   5 配置文件   8 系统管理员可以使用的管理指令    3. info info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以进行跳转。
4. doc /usr/share/doc 存放着软件的一整套说明文件。
关机 1. who 在关机前需要先使用 who 命令查看有没有其它用户在线。
2. sync 为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘上，因此关机之前需要先进行 sync 同步操作。</description>
            <content type="html"><![CDATA[<h1 id="一常用操作以及概念">一、常用操作以及概念</h1>
<h2 id="快捷键">快捷键</h2>
<ul>
<li>Tab：命令和文件名补全；</li>
<li>Ctrl+C：中断正在运行的程序；</li>
<li>Ctrl+D：结束键盘输入（End Of File，EOF）</li>
</ul>
<h2 id="求助">求助</h2>
<h3 id="1---help">1. &ndash;help</h3>
<p>指令的基本用法与选项介绍。</p>
<h3 id="2-man">2. man</h3>
<p>man 是 manual 的缩写，将指令的具体信息显示出来。</p>
<p>当执行<code>man date</code>时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">代号</th>
<th>类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td>用户在 shell 环境中可以操作的指令或者可执行文件</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td>配置文件</td>
</tr>
<tr>
<td style="text-align:center">8</td>
<td>系统管理员可以使用的管理指令</td>
</tr>
</tbody>
</table>
<h3 id="3-info">3. info</h3>
<p>info 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以进行跳转。</p>
<h3 id="4-doc">4. doc</h3>
<p>/usr/share/doc 存放着软件的一整套说明文件。</p>
<h2 id="关机">关机</h2>
<h3 id="1-who">1. who</h3>
<p>在关机前需要先使用 who 命令查看有没有其它用户在线。</p>
<h3 id="2-sync">2. sync</h3>
<p>为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘上，因此关机之前需要先进行 sync 同步操作。</p>
<h3 id="3-shutdown">3. shutdown</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># shutdown [-krhc] 时间 [信息]
-k ： 不会关机，只是发送警告信息，通知所有在线的用户
-r ： 将系统的服务停掉后就重新启动
-h ： 将系统的服务停掉后就立即关机
-c ： 取消已经在进行的 shutdown 指令内容
</code></pre></div><h2 id="path">PATH</h2>
<p>可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
</code></pre></div><h2 id="sudo">sudo</h2>
<p>sudo 允许一般用户使用 root 可执行的命令，不过只有在 /etc/sudoers 配置文件中添加的用户才能使用该指令。</p>
<h2 id="vim-三个模式">VIM 三个模式</h2>
<ul>
<li>一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容；</li>
<li>编辑模式（Insert mode）：按下 &ldquo;i&rdquo; 等按键之后进入，可以对文本进行编辑；</li>
<li>指令列模式（Bottom-line mode）：按下 &ldquo;:&rdquo; 按键之后进入，用于保存退出等操作。</li>
</ul>
<p>在指令列模式下，有以下命令用于离开或者保存文件。</p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">:w</td>
<td style="text-align:center">写入磁盘</td>
</tr>
<tr>
<td style="text-align:center">:w!</td>
<td style="text-align:center">当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关</td>
</tr>
<tr>
<td style="text-align:center">:q</td>
<td style="text-align:center">离开</td>
</tr>
<tr>
<td style="text-align:center">:q!</td>
<td style="text-align:center">强制离开不保存</td>
</tr>
<tr>
<td style="text-align:center">:wq</td>
<td style="text-align:center">写入磁盘后离开</td>
</tr>
<tr>
<td style="text-align:center">:wq!</td>
<td style="text-align:center">强制写入磁盘后离开</td>
</tr>
</tbody>
</table>
<h1 id="二磁盘">二、磁盘</h1>
<h2 id="磁盘接口">磁盘接口</h2>
<h3 id="1-ide">1. IDE</h3>
<p>IDE（ATA）全称 Advanced Technology Attachment，接口速度最大为 133MB/s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代。</p>
<h3 id="2-sata">2. SATA</h3>
<p>SATA 全称 Serial ATA，也就是使用串口的 ATA 接口，抗干扰性强，且对数据线的长度要求比 ATA 低很多，支持热插拔等功能。SATA-II 的接口速度为 300MiB/s，而新的 SATA-III 标准可达到 600MiB/s 的传输速度。SATA 的数据线也比 ATA 的细得多，有利于机箱内的空气流通，整理线材也比较方便。</p>
<h3 id="3-scsi">3. SCSI</h3>
<p>SCSI 全称是 Small Computer System Interface（小型机系统接口），经历多代的发展，从早期的 SCSI-II 到目前的 Ultra320 SCSI 以及 Fiber-Channel（光纤通道），接口型式也多种多样。SCSI 硬盘广为工作站级个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速 15000rpm 的高转速，且传输时 CPU 占用率较低，但是单价也比相同容量的 ATA 及 SATA 硬盘更加昂贵。</p>
<h3 id="4-sas">4. SAS</h3>
<p>SAS（Serial Attached SCSI）是新一代的 SCSI 技术，和 SATA 硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb/s。此外也透过缩小连接线改善系统内部空间等。</p>
<h2 id="磁盘的文件名">磁盘的文件名</h2>
<p>Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下：</p>
<ul>
<li>IDE 磁盘：/dev/hd[a-d]</li>
<li>SATA/SCSI/SAS 磁盘：/dev/sd[a-p]</li>
</ul>
<p>其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关。</p>
<h1 id="三分区">三、分区</h1>
<h2 id="分区表">分区表</h2>
<p>磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。</p>
<h3 id="1-mbr">1. MBR</h3>
<p>MBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。</p>
<p>分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其它扇区用记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。</p>
<p>Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 /dev/sda1。注意，逻辑分区的编号从 5 开始。</p>
<h3 id="2-gpt">2. GPT</h3>
<p>不同的磁盘有不同的扇区大小，例如 512 bytes 和最新磁盘的 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小为 512 bytes。</p>
<p>GPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。</p>
<p>GPT 没有扩展分区概念，都是主分区，每个 LAB 可以分 4 个分区，因此总共可以分 4 * 32 = 128 个分区。</p>
<p>MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 2<!-- raw HTML omitted -->33<!-- raw HTML omitted --> TB = 8 ZB。</p>
<h2 id="开机检测程序">开机检测程序</h2>
<h3 id="1-bios">1. BIOS</h3>
<p>BIOS（Basic Input/Output System，基本输入输出系统），它是一个固件（嵌入在硬件中的软件），BIOS 程序存放在断电后内容不会丢失的只读内存中。</p>
<p>BIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的主要开机记录（MBR），由主要开机记录（MBR）执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。</p>
<p>主要开机记录（MBR）中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现了多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动开机管理程序时，就可以通过选单选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。</p>
<p>安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉主要开机记录（MBR），而 Linux 可以选择将开机管理程序安装在主要开机记录（MBR）或者其它分区的启动扇区，并且可以设置开机管理程序的选单。</p>
<h3 id="2-uefi">2. UEFI</h3>
<p>BIOS 不可以读取 GPT 分区表，而 UEFI 可以。</p>
<h1 id="四文件系统">四、文件系统</h1>
<h2 id="分区与文件系统">分区与文件系统</h2>
<p>对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。</p>
<h2 id="组成">组成</h2>
<p>最主要的几个组成部分如下：</p>
<ul>
<li>inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；</li>
<li>block：记录文件的内容，文件太大时，会占用多个 block。</li>
</ul>
<p>除此之外还包括：</p>
<ul>
<li>superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</li>
<li>block bitmap：记录 block 是否被使用的位域。</li>
</ul>
<h2 id="文件读取">文件读取</h2>
<p>对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中去查找文件内容所在的所有 block，然后把所有 block 的内容读出来。</p>
<p>而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。</p>
<h2 id="磁盘碎片">磁盘碎片</h2>
<p>指一个文件内容所在的 block 过于分散。</p>
<h2 id="block">block</h2>
<p>在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。</p>
<table>
<thead>
<tr>
<th style="text-align:center">大小</th>
<th style="text-align:center">1KB</th>
<th style="text-align:center">2KB</th>
<th style="text-align:center">4KB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">最大单一文件</td>
<td style="text-align:center">16GB</td>
<td style="text-align:center">256GB</td>
<td style="text-align:center">2TB</td>
</tr>
<tr>
<td style="text-align:center">最大文件系统</td>
<td style="text-align:center">2TB</td>
<td style="text-align:center">8TB</td>
<td style="text-align:center">16TB</td>
</tr>
</tbody>
</table>
<p>一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。</p>
<h2 id="inode">inode</h2>
<p>inode 具体包含以下信息：</p>
<ul>
<li>权限 (read/write/excute)；</li>
<li>拥有者与群组 (owner/group)；</li>
<li>容量；</li>
<li>建立或状态改变的时间 (ctime)；</li>
<li>最近一次的读取时间 (atime)；</li>
<li>最近修改的时间 (mtime)；</li>
<li>定义文件特性的旗标 (flag)，如 SetUID&hellip;；</li>
<li>该文件真正内容的指向 (pointer)。</li>
</ul>
<p>inode 具有以下特点：</p>
<ul>
<li>每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；</li>
<li>每个文件都仅会占用一个 inode。</li>
</ul>
<p>inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用是指，让 inode 记录的引用 block 块记录引用信息。</p>
<h2 id="目录">目录</h2>
<p>建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。</p>
<p>可以看出文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的 w 权限有关。</p>
<h2 id="日志">日志</h2>
<p>如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。</p>
<p>ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。</p>
<h2 id="挂载">挂载</h2>
<p>挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。</p>
<h2 id="目录配置">目录配置</h2>
<p>为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：</p>
<ul>
<li>/ (root, 根目录)</li>
<li>/usr (unix software resource)：所有系统默认软件都会安装到这个目录；</li>
<li>/var (variable)：存放系统或程</li>
</ul>
<h1 id="五文件">五、文件</h1>
<h2 id="文件属性">文件属性</h2>
<p>用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。</p>
<p>使用 ls 查看一个文件时，会显示一个文件的信息，例如 <code>drwxr-xr-x. 3 root root 17 May 6 00:14 .config</code>，对这个信息的解释如下：</p>
<ul>
<li>drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段</li>
<li>3：链接数</li>
<li>root：文件拥有者</li>
<li>root：所属群组</li>
<li>17：文件大小</li>
<li>May 6 00:14：文件最后被修改的时间</li>
<li>.config：文件名</li>
</ul>
<p>常见的文件类型及其含义有：</p>
<ul>
<li>d：目录</li>
<li>-：文件</li>
<li>l：链接文件</li>
</ul>
<p>9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。</p>
<p>文件时间有以下三种：</p>
<ul>
<li>modification time (mtime)：文件的内容更新就会更新；</li>
<li>status time (ctime)：文件的状态（权限、属性）更新就会更新；</li>
<li>access time (atime)：读取文件时就会更新。</li>
</ul>
<h2 id="文件与目录的基本操作">文件与目录的基本操作</h2>
<h3 id="1-ls">1. ls</h3>
<p>列出文件或者目录的信息，目录的信息就是其中包含的文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># ls [-aAdfFhilnrRSt] file|dir
-a ：列出全部的文件
-d ：仅列出目录本身
-l ：以长数据串行列出，包含文件的属性与权限等等数据
</code></pre></div><h3 id="2-cd">2. cd</h3>
<p>更换当前目录。</p>
<pre tabindex="0"><code>cd [相对路径或绝对路径]
</code></pre><h3 id="3-mkdir">3. mkdir</h3>
<p>创建目录。</p>
<pre tabindex="0"><code># mkdir [-mp] 目录名称
-m ：配置目录权限
-p ：递归创建目录
</code></pre><h3 id="4-rmdir">4. rmdir</h3>
<p>删除目录，目录必须为空。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">rmdir [-p] 目录名称
-p ：递归删除目录
</code></pre></div><h3 id="5-touch">5. touch</h3>
<p>更新文件时间或者建立新文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># touch [-acdmt] filename
-a ： 更新 atime
-c ： 更新 ctime，若该文件不存在则不建立新文件
-m ： 更新 mtime
-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=&#34;日期或时间&#34;
-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm]
</code></pre></div><h3 id="6-cp">6. cp</h3>
<p>复制文件。</p>
<p>如果源文件有两个以上，则目的文件一定要是目录才行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">cp [-adfilprsu] source destination
-a ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明
-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身
-i ：若目标文件已经存在时，在覆盖前会先询问
-p ：连同文件的属性一起复制过去
-r ：递归持续复制
-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制
--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了
</code></pre></div><h3 id="7-rm">7. rm</h3>
<p>删除文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># rm [-fir] 文件或目录
-r ：递归删除
</code></pre></div><h3 id="8-mv">8. mv</h3>
<p>移动文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># mv [-fiu] source destination
# mv [options] source1 source2 source3 .... directory
-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖
</code></pre></div><h2 id="修改权限">修改权限</h2>
<p>可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># chmod [-R] xyz dirname/filename
</code></pre></div><p>示例：将 .bashrc 文件的权限修改为 -rwxr-xr&ndash;。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># chmod 754 .bashrc
</code></pre></div><p>也可以使用符号来设定权限。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># chmod [ugoa]  [+-=] [rwx] dirname/filename
- u：拥有者
- g：所属群组
- o：其他人
- a：所有人
- +：添加权限
- -：移除权限
- =：设定权限
</code></pre></div><p>示例：为 .bashrc 文件的所有用户添加写权限。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># chmod a+w .bashrc
</code></pre></div><h2 id="文件默认权限">文件默认权限</h2>
<ul>
<li>文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。</li>
<li>目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。</li>
</ul>
<p>可以通过 umask 设置或者查看文件的默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r&ndash;。</p>
<h2 id="目录的权限">目录的权限</h2>
<p>文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。</p>
<p>目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。</p>
<h2 id="链接">链接</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># ln [-sf] source_filename dist_filename
-s ：默认是 hard link，加 -s 为 symbolic link
-f ：如果目标文件存在时，先删除目标文件
</code></pre></div><h3 id="1-实体链接">1. 实体链接</h3>
<p>在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。</p>
<p>删除任意一个条目，文件还是存在，只要引用数量不为 0。</p>
<p>有以下限制：不能跨越文件系统、不能对目录进行链接。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># ln /etc/crontab .
# ll -i /etc/crontab crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
</code></pre></div><h3 id="2-符号链接">2. 符号链接</h3>
<p>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。</p>
<p>当源文件被删除了，链接文件就打不开了。</p>
<p>可以为目录建立链接。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># ll -i /etc/crontab /root/crontab2
34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab
53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab
</code></pre></div><h2 id="获取文件内容">获取文件内容</h2>
<h3 id="1-cat">1. cat</h3>
<p>取得文件内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># cat [-AbEnTv] filename
-n ：打印出行号，连同空白行也会有行号，-b 不会
</code></pre></div><h3 id="2-tac">2. tac</h3>
<p>是 cat 的反向操作，从最后一行开始打印。</p>
<h3 id="3-more">3. more</h3>
<p>和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。</p>
<h3 id="4-less">4. less</h3>
<p>和 more 类似，但是多了一个向前翻页的功能。</p>
<h3 id="5-head">5. head</h3>
<p>取得文件前几行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># head [-n number] filename
-n ：后面接数字，代表显示几行的意思
</code></pre></div><h3 id="6-tail">6. tail</h3>
<p>是 head 的反向操作，只是取得是后几行。</p>
<h3 id="7-od">7. od</h3>
<p>以字符或者十六进制的形式显示二进制文件。</p>
<h2 id="指令与文件搜索">指令与文件搜索</h2>
<h3 id="1-which">1. which</h3>
<p>指令搜索。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># which [-a] command
-a ：将所有指令列出，而不是只列第一个
</code></pre></div><h3 id="2-whereis">2. whereis</h3>
<p>文件搜索。速度比较快，因为它只搜索几个特定的目录。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># whereis [-bmsu] dirname/filename
</code></pre></div><h3 id="3-locate">3. locate</h3>
<p>文件搜索。可以用关键字或者正则表达式进行搜索。</p>
<p>locate 使用 /var/lib/mlocate/ 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># locate [-ir] keyword
-r：正则表达式
</code></pre></div><h3 id="4-find">4. find</h3>
<p>文件搜索。可以使用文件的属性和权限进行搜索。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html"># find [basedir] [option]
example: find . -name &#34;shadow*&#34;
</code></pre></div><p><strong>① 与时间有关的选项</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">-mtime  n ：列出在 n 天前的那一天修改过内容的文件
-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件
-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件
-newer file ： 列出比 file 更新的文件
</code></pre></div><p>+4、4 和 -4 的指示的时间范围如下：</p>
<!-- raw HTML omitted -->
<p><strong>② 与文件拥有者和所属群组有关的选项</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">-uid n
-gid n
-user name
-group name
-nouser ：搜索拥有者不存在 /etc/passwd 的文件
-nogroup：搜索所属群组不存在于 /etc/group 的文件
</code></pre></div><p><strong>③ 与文件权限和名称有关的选项</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">-name filename
-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k
-type TYPE
-perm mode  ：搜索权限等于 mode 的文件
-perm -mode ：搜索权限包含 mode 的文件
-perm /mode ：搜索权限包含任一 mode 的文件
</code></pre></div><h1 id="六压缩与打包">六、压缩与打包</h1>
<h2 id="压缩文件名">压缩文件名</h2>
<p>Linux 底下有很多压缩文件名，常见的如下：</p>
<table>
<thead>
<tr>
<th>扩展名</th>
<th>压缩程序</th>
</tr>
</thead>
<tbody>
<tr>
<td>*.Z</td>
<td>compress</td>
</tr>
<tr>
<td>*.zip</td>
<td>zip</td>
</tr>
<tr>
<td>*.gz</td>
<td>gzip</td>
</tr>
<tr>
<td>*.bz2</td>
<td>bzip2</td>
</tr>
<tr>
<td>*.xz</td>
<td>xz</td>
</tr>
<tr>
<td>*.tar</td>
<td>tar 程序打包的数据，没有经过压缩</td>
</tr>
<tr>
<td>*.tar.gz</td>
<td>tar 程序打包的文件，经过 gzip 的压缩</td>
</tr>
<tr>
<td>*.tar.bz2</td>
<td>tar 程序打包的文件，经过 bzip2 的压缩</td>
</tr>
<tr>
<td>*.tar.xz</td>
<td>tar 程序打包的文件，经过 xz 的压缩</td>
</tr>
</tbody>
</table>
<h2 id="压缩指令">压缩指令</h2>
<h3 id="1-gzip">1. gzip</h3>
<p>gzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。</p>
<p>经过 gzip 压缩过，源文件就不存在了。</p>
<p>有 9 个不同的压缩等级可以使用。</p>
<p>可以使用 zcat、zmore、zless 来读取压缩文件的内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ gzip [-cdtv#] filename
-c ：将压缩的数据输出到屏幕上
-d ：解压缩
-t ：检验压缩文件是否出错
-v ：显示压缩比等信息
-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6
</code></pre></div><h3 id="2-bzip2">2. bzip2</h3>
<p>提供比 gzip 更高的压缩比。</p>
<p>查看命令：bzcat、bzmore、bzless、bzgrep。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ bzip2 [-cdkzv#] filename
-k ：保留源文件
</code></pre></div><h3 id="3-xz">3. xz</h3>
<p>提供比 bzip2 更佳的压缩比。</p>
<p>可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。</p>
<p>查看命令：xzcat、xzmore、xzless、xzgrep。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ xz [-dtlkc#] filename
</code></pre></div><h2 id="打包">打包</h2>
<p>压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gip、bzip2、xz 将打包文件进行压缩。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename...  ==打包压缩
$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件]              ==查看
$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录]    ==解压缩
-z ：使用 zip；
-j ：使用 bzip2；
-J ：使用 xz；
-c ：新建打包文件；
-t ：查看打包文件里面有哪些文件；
-x ：解打包或解压缩的功能；
-v ：在压缩/解压缩的过程中，显示正在处理的文件名；
-f : filename：要处理的文件；
-C 目录 ： 在特定目录解压缩。
</code></pre></div><table>
<thead>
<tr>
<th style="text-align:center">使用方式</th>
<th>命令</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">打包压缩</td>
<td>tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称</td>
</tr>
<tr>
<td style="text-align:center">查 看</td>
<td>tar -jtv -f filename.tar.bz2</td>
</tr>
<tr>
<td style="text-align:center">解压缩</td>
<td>tar -jxv -f filename.tar.bz2 -C 要解压缩的目录</td>
</tr>
</tbody>
</table>
<h1 id="七bash">七、Bash</h1>
<p>可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。</p>
<h2 id="特性">特性</h2>
<ul>
<li>命令历史：记录使用过的命令</li>
<li>命令与文件补全：快捷键：tab</li>
<li>命名别名：例如 lm 是 ls -al 的别名</li>
<li>shell scripts</li>
<li>通配符：例如 ls -l /usr/bin/X* 列出 /usr/bin 下面所有以 X 开头的文件</li>
</ul>
<h2 id="变量操作">变量操作</h2>
<p>对一个变量赋值直接使用 =。</p>
<p>对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式；</p>
<p>输出变量使用 echo 命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ x<span style="color:#f92672">=</span>abc
$ echo $x
$ echo <span style="color:#e6db74">${</span>x<span style="color:#e6db74">}</span>
</code></pre></div><p>变量内容如果有空格，必须使用双引号或者单引号。</p>
<ul>
<li>双引号内的特殊字符可以保留原本特性，例如 x=&ldquo;lang is $LANG&rdquo;，则 x 的值为 lang is zh_TW.UTF-8；</li>
<li>单引号内的特殊字符就是特殊字符本身，例如 x=&lsquo;lang is $LANG&rsquo;，则 x 的值为 lang is $LANG。</li>
</ul>
<p>可以使用 `指令` 或者 $(指令) 的方式将指令的执行结果赋值给变量。例如 version=$(uname -r)，则 version 的值为 4.15.0-22-generic。</p>
<p>可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。</p>
<p>Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ declare [-aixr] variable
-a ： 定义为数组类型
-i ： 定义为整数类型
-x ： 定义为环境变量
-r ： 定义为 readonly 类型
</code></pre></div><p>使用 [ ] 来对数组进行索引操作：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ array<span style="color:#f92672">[</span>1<span style="color:#f92672">]=</span>a
$ array<span style="color:#f92672">[</span>2<span style="color:#f92672">]=</span>b
$ echo <span style="color:#e6db74">${</span>array[1]<span style="color:#e6db74">}</span>
</code></pre></div><h2 id="指令搜索顺序">指令搜索顺序</h2>
<ul>
<li>以绝对或相对路径来执行指令，例如 /bin/ls 或者 ./ls ；</li>
<li>由别名找到该指令来执行；</li>
<li>由 Bash 内置的指令来执行；</li>
<li>按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。</li>
</ul>
<h2 id="数据流重定向">数据流重定向</h2>
<p>重定向指的是使用文件代替标准输入、标准输出和标准错误输出。</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">代码</th>
<th style="text-align:center">运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">标准输入 (stdin)</td>
<td style="text-align:center">0</td>
<td style="text-align:center">&lt; 或 &laquo;</td>
</tr>
<tr>
<td style="text-align:center">标准输出 (stdout)</td>
<td style="text-align:center">1</td>
<td style="text-align:center">&gt; 或 &raquo;</td>
</tr>
<tr>
<td style="text-align:center">标准错误输出 (stderr)</td>
<td style="text-align:center">2</td>
<td style="text-align:center">2&gt; 或 2&raquo;</td>
</tr>
</tbody>
</table>
<p>其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。</p>
<p>可以将不需要的标准输出以及标准错误输出重定向到 /dev/null，相当于扔进垃圾箱。</p>
<p>如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ find /home -name .bashrc &gt; list 2&gt;&amp;<span style="color:#ae81ff">1</span>
</code></pre></div><h1 id="八管道指令">八、管道指令</h1>
<p>管道是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管道。</p>
<p>在命令之间使用 | 分隔各个管道命令。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ ls -al /etc | less
</code></pre></div><h2 id="提取指令">提取指令</h2>
<p>cut 对数据进行切分，取出想要的部分。</p>
<p>切分过程一行一行地进行。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ cut
-d ：分隔符
-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间
-c ：以字符为单位取出区间
</code></pre></div><p>示例 1：last 显示登入者的信息，取出用户名。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ last
root pts/1 192.168.201.101 Sat Feb 7 12:35 still logged in
root pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)
root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)

$ last | cut -d &#39; &#39; -f 1
</code></pre></div><p>示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ export
declare -x HISTCONTROL=&#34;ignoredups&#34;
declare -x HISTSIZE=&#34;1000&#34;
declare -x HOME=&#34;/home/dmtsai&#34;
declare -x HOSTNAME=&#34;study.centos.vbird&#34;
.....(其他省略).....

$ export | cut -c 12-
</code></pre></div><h2 id="排序指令">排序指令</h2>
<p><strong>sort</strong>  用于排序。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ sort [-fbMnrtuk] [file or stdin]
-f ：忽略大小写
-b ：忽略最前面的空格
-M ：以月份的名字来排序，例如 JAN，DEC
-n ：使用数字
-r ：反向排序
-u ：相当于 unique，重复的内容只出现一次
-t ：分隔符，默认为 tab
-k ：指定排序的区间
</code></pre></div><p>示例：/etc/passwd 文件内容以 : 来分隔，要求以第三列进行排序。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ cat /etc/passwd | sort -t &#39;:&#39; -k 3
root❌0:0:root:/root:/bin/bash
dmtsai❌1000:1000:dmtsai:/home/dmtsai:/bin/bash
alex❌1001:1002::/home/alex:/bin/bash
arod❌1002:1003::/home/arod:/bin/bash
</code></pre></div><p><strong>uniq</strong>  可以将重复的数据只取一个。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ uniq [-ic]
-i ：忽略大小写
-c ：进行计数
</code></pre></div><p>示例：取得每个人的登录总次数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ last | cut -d &#39; &#39; -f 1 | sort | uniq -c
1
6 (unknown
47 dmtsai
4 reboot
7 root
1 wtmp
</code></pre></div><h2 id="双向输出重定向">双向输出重定向</h2>
<p>输出重定向会将输出内容重定向到文件中，而  <strong>tee</strong>  不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ tee [-a] file
</code></pre></div><h2 id="字符转换指令">字符转换指令</h2>
<p><strong>tr</strong>  用来删除一行中的字符，或者对字符进行替换。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ tr [-ds] SET1 ...
-d ： 删除行中 SET1 这个字符串
</code></pre></div><p>示例，将 last 输出的信息所有小写转换为大写。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ last | tr &#39;[a-z]&#39; &#39;[A-Z]&#39;
</code></pre></div><p><strong>col</strong>  将 tab 字符转为空格字符。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ col [-xb]
-x ： 将 tab 键转换成对等的空格键
</code></pre></div><p><strong>expand</strong>  将 tab 转换一定数量的空格，默认是 8 个。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ expand [-t] file
-t ：tab 转为空格的数量
</code></pre></div><p><strong>join</strong>  将有相同数据的那一行合并在一起。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ join [-ti12] file1 file2
-t ：分隔符，默认为空格
-i ：忽略大小写的差异
-1 ：第一个文件所用的比较字段
-2 ：第二个文件所用的比较字段
</code></pre></div><p><strong>paste</strong>  直接将两行粘贴在一起。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ paste [-d] file1 file2
-d ：分隔符，默认为 tab
</code></pre></div><h2 id="分区指令">分区指令</h2>
<p><strong>split</strong>  将一个文件划分成多个文件。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ split [-bl] file PREFIX
-b ：以大小来进行分区，可加单位，例如 b, k, m 等
-l ：以行数来进行分区。
- PREFIX ：分区文件的前导名称
</code></pre></div><h1 id="九正则表达式">九、正则表达式</h1>
<h2 id="grep">grep</h2>
<p>g/re/p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ grep [-acinv] [--color=auto] 搜寻字符串 filename
-c ： 统计个数
-i ： 忽略大小写
-n ： 输出行号
-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行
--color=auto ：找到的关键字加颜色显示
</code></pre></div><p>示例：把含有 the 字符串的行提取出来（注意默认会有 &ndash;color=auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串）</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ grep -n &#39;the&#39; regular_express.txt
8:I can&#39;t finish the test.
12:the symbol &#39;*&#39; is represented as start.
15:You are the best is mean you are the no. 1.
16:The world Happy is the same with &#34;glad&#34;.
18:google is the best tools for search keyword
</code></pre></div><p>因为 { 和 } 在 shell 是有特殊意义的，因此必须要使用转义字符进行转义。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ grep -n &#39;go\{2,5\}g&#39; regular_express.txt
</code></pre></div><h2 id="printf">printf</h2>
<p>用于格式化输出。它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ printf &#39;%10s %5i %5i %5i %8.2f \n&#39; $(cat printf.txt)
    DmTsai    80    60    92    77.33
     VBird    75    55    80    70.00
       Ken    60    90    70    73.33
</code></pre></div><h2 id="awk">awk</h2>
<p>是由 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。</p>
<p>awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。</p>
<p>示例：取出最近五个登录用户的用户名和 IP</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ last -n 5
dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged in
dmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)
dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)
dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)
dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15)
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ last -n 5 | awk &#39;{print $1 &#34;\t&#34; $3}&#39;
</code></pre></div><p>可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ awk &#39;条件类型 1 {动作 1} 条件类型 2 {动作 2} ...&#39; filename
</code></pre></div><p>示例：/etc/passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-text" data-lang="text">$ cat /etc/passwd | awk &#39;BEGIN {FS=&#34;:&#34;} $3 &lt; 10 {print $1 &#34;\t &#34; $3}&#39;
root 0
bin 1
daemon 2
</code></pre></div><p>awk 变量：</p>
<table>
<thead>
<tr>
<th style="text-align:center">变量名称</th>
<th>代表意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">NF</td>
<td>每一行拥有的字段总数</td>
</tr>
<tr>
<td style="text-align:center">NR</td>
<td>目前所处理的是第几行数据</td>
</tr>
<tr>
<td style="text-align:center">FS</td>
<td>目前的分隔字符，默认是空格键</td>
</tr>
</tbody>
</table>
<p>示例：显示正在处理的行号以及每一行有多少字段</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">$ last -n 5 | awk &#39;{print $1 &#34;\t lines: &#34; NR &#34;\t columns: &#34; NF}&#39;
dmtsai lines: 1 columns: 10
dmtsai lines: 2 columns: 10
dmtsai lines: 3 columns: 10
dmtsai lines: 4 columns: 10
dmtsai lines: 5 columns: 9
</code></pre></div><h1 id="十进程管理">十、进程管理</h1>
<h2 id="查看进程">查看进程</h2>
<h3 id="1-ps">1. ps</h3>
<p>查看某个时间点的进程信息</p>
<p>示例一：查看自己的进程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># ps -l</span>
</code></pre></div><p>示例二：查看系统所有进程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># ps aux</span>
</code></pre></div><p>示例三：查看特定的进程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># ps aux | grep threadx</span>
</code></pre></div><h3 id="2-pstree">2. pstree</h3>
<p>查看进程树</p>
<p>示例：查看所有进程树</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># pstree -A</span>
</code></pre></div><h3 id="3-top">3. top</h3>
<p>实时显示进程信息</p>
<p>示例：两秒钟刷新一次</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># top -d 2</span>
</code></pre></div><h3 id="4-netstat">4. netstat</h3>
<p>查看占用端口的进程</p>
<p>示例：查看特定端口的进程</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sh" data-lang="sh"><span style="color:#75715e"># netstat -anp | grep port</span>
</code></pre></div><h2 id="进程状态">进程状态</h2>
<table>
<thead>
<tr>
<th style="text-align:center">状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">R</td>
<td>running or runnable (on run queue)</td>
</tr>
<tr>
<td style="text-align:center">D</td>
<td>uninterruptible sleep (usually I/O)</td>
</tr>
<tr>
<td style="text-align:center">S</td>
<td>interruptible sleep (waiting for an event to complete)</td>
</tr>
<tr>
<td style="text-align:center">Z</td>
<td>zombie (terminated but not reaped by its parent)</td>
</tr>
<tr>
<td style="text-align:center">T</td>
<td>stopped (either by a job control signal or because it is being traced)</td>
</tr>
<tr>
<td style="text-align:center"><!-- raw HTML omitted --></td>
<td></td>
</tr>
</tbody>
</table>
<!-- raw HTML omitted -->
<h2 id="sigchld">SIGCHLD</h2>
<p>当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中：</p>
<ul>
<li>得到 SIGCHLD 信号；</li>
<li>waitpid() 或者 wait() 调用会返回。</li>
</ul>
<p>其中子进程发送的 SIGCHLD 信号包含了子进程的信息，比如进程 ID、进程状态、进程使用 CPU 的时间等。</p>
<p>在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。</p>
<!-- raw HTML omitted -->
<h2 id="wait">wait()</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">pid_t wait(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>status)
</code></pre></div><p>父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。</p>
<p>如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。</p>
<p>参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。</p>
<h2 id="waitpid">waitpid()</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c">pid_t waitpid(pid_t pid, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>status, <span style="color:#66d9ef">int</span> options)
</code></pre></div><p>作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。</p>
<p>pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。</p>
<p>options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。</p>
<h2 id="孤儿进程">孤儿进程</h2>
<p>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。</p>
<p>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</p>
<p>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。</p>
<h2 id="僵尸进程">僵尸进程</h2>
<p>一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。</p>
<p>僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。</p>
<p>系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<p>要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。</p>
<h1 id="参考资料">参考资料</h1>
<ul>
<li>鸟哥. 鸟 哥 的 Linux 私 房 菜 基 础 篇 第 三 版[J]. 2009.</li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-rpmdpkg/index.html">Linux 平台上的软件包管理</a></li>
<li><a href="http://liubigbin.github.io/2016/03/11/Linux-%E4%B9%8B%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E3%80%81%E5%83%B5%E6%AD%BB%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/">Linux 之守护进程、僵死进程与孤儿进程</a></li>
<li><a href="https://stackoverflow.com/questions/185899/what-is-the-difference-between-a-symbolic-link-and-a-hard-link">What is the difference between a symbolic link and a hard link?</a></li>
<li><a href="https://idea.popcount.org/2012-12-11-linux-process-states/">Linux process states</a></li>
<li><a href="https://en.wikipedia.org/wiki/GUID_Partition_Table">GUID Partition Table</a></li>
<li><a href="https://blog.csdn.net/kevinhg/article/details/7001719">详解 wait 和 waitpid 函数</a></li>
<li><a href="https://blog.csdn.net/tianlesoftware/article/details/6009110">IDE、SATA、SCSI、SAS、FC、SSD 硬盘类型介绍</a></li>
<li><a href="http://www.mpchunter.com/s3000/akai-ib-301s-scsi-interface-for-s2800s3000/">Akai IB-301S SCSI Interface for S2800,S3000</a></li>
<li><a href="https://en.wikipedia.org/wiki/Parallel_ATA">Parallel ATA</a></li>
<li><a href="http://www.thessdreview.com/our-reviews/adata-xpg-sx900-256gb-sata-3-ssd-review-expanded-capacity-and-sandforce-driven-speed/4/">ADATA XPG SX900 256GB SATA 3 SSD Review – Expanded Capacity and SandForce Driven Speed</a></li>
<li><a href="https://blogs.cisco.com/datacenter/decoding-ucs-invicta-part-1">Decoding UCS Invicta – Part 1</a></li>
<li><a href="https://zh.wikipedia.org/wiki/%E7%A1%AC%E7%9B%98">硬盘</a></li>
<li><a href="http://www.differencebetween.info/difference-between-sas-and-sata">Difference between SAS and SATA</a></li>
<li><a href="https://zh.wikipedia.org/wiki/BIOS">BIOS</a></li>
<li><a href="https://www.cs.rutgers.edu/~pxk/416/notes/13-fs-studies.html">File system design case studies</a></li>
<li><a href="https://classes.soe.ucsc.edu/cmps111/Fall08/proj4.shtml">Programming Project #4</a></li>
<li><a href="http://web.cs.ucla.edu/classes/fall14/cs111/scribe/11a/index.html">FILE SYSTEM DESIGN</a></li>
</ul>
<hr>
<p>github: <a href="https://github.com/sjsdfg/CS-Notes-PDF">https://github.com/sjsdfg/CS-Notes-PDF</a></p>
]]></content>
        </item>
        
        <item>
            <title>二分算法</title>
            <link>https://oxygenbytes.github.io/posts/2021/01/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/</link>
            <pubDate>Sat, 30 Jan 2021 21:49:10 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2021/01/%E4%BA%8C%E5%88%86%E7%AE%97%E6%B3%95/</guid>
            <description>二分算法 二分模板 二分模板一共有两个，分别适用于不同情况。
版本1 当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。 C++ 代码模板：
int bsearch_1(int l, int r) { while (l &amp;lt; r) { int mid = l + r &amp;gt;&amp;gt; 1; if (check(mid)) r = mid; else l = mid + 1; } return l; } 版本2 当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。 C++ 代码模板：
int bsearch_2(int l, int r) { while (l &amp;lt; r) { int mid = l + r + 1 &amp;gt;&amp;gt; 1; if (check(mid)) l = mid; else r = mid - 1; } return l; } 使用心的  假设有一个总区间，经由我们的 check 函数判断后，可分成两部分， 若以o作 true，&amp;hellip;.</description>
            <content type="html"><![CDATA[<h1 id="二分算法">二分算法</h1>
<h2 id="二分模板">二分模板</h2>
<p>二分模板一共有两个，分别适用于不同情况。</p>
<h3 id="版本1">版本1</h3>
<p>当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。
C++ 代码模板：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bsearch_1</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r)
{
    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r)
    {
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (check(mid)) r <span style="color:#f92672">=</span> mid;
        <span style="color:#66d9ef">else</span> l <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> l;
}
</code></pre></div><h3 id="版本2">版本2</h3>
<p>当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。
C++ 代码模板：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">bsearch_2</span>(<span style="color:#66d9ef">int</span> l, <span style="color:#66d9ef">int</span> r)
{
    <span style="color:#66d9ef">while</span> (l <span style="color:#f92672">&lt;</span> r)
    {
        <span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> l <span style="color:#f92672">+</span> r <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&gt;&gt;</span> <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">if</span> (check(mid)) l <span style="color:#f92672">=</span> mid;
        <span style="color:#66d9ef">else</span> r <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
    }
    <span style="color:#66d9ef">return</span> l;
}
</code></pre></div><h2 id="使用心的">使用心的</h2>
<blockquote>
<p>假设有一个总区间，经由我们的 check 函数判断后，可分成两部分，
若以o作 true，&hellip;..作 false 示意较好识别</p>
<p>如果我们的目标是下面这个v，使用模板 1</p>
<p><code>................vooooooooo</code></p>
<p>假设经由 check 划分后，整个区间的属性与目标v如下，则使用模板 2</p>
<p><code>oooooooov................</code></p>
<p>模板1就是在满足chek()的区间内找到左边界，模板2在满足check()的区间内找到右边界。</p>
</blockquote>
<blockquote>
<p>二分可以将<code>求解类型的问题</code> 转换为 <code>判定型问题</code></p>
</blockquote>
<h2 id="实数域上的二分算法">实数域上的二分算法</h2>
<p>实数域上的二分较为简单，确定好需要的的精度 <code>eps</code>, 以 <code>left + eps &lt; right</code> 为循环条件，每次根据在 <code>mid</code> 上根据判定选择 <code>left = mid</code>, <code>right = mid</code> 分支之一即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">binary_search</span>(<span style="color:#66d9ef">double</span> left, <span style="color:#66d9ef">double</span> right){
    <span style="color:#66d9ef">while</span>(left <span style="color:#f92672">+</span> <span style="color:#ae81ff">1e-5</span> <span style="color:#f92672">&lt;</span> right){
        <span style="color:#66d9ef">double</span> mid <span style="color:#f92672">=</span> (left <span style="color:#f92672">+</span> right) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
        <span style="color:#66d9ef">if</span>(check(mid)) left <span style="color:#f92672">=</span> mid;
        <span style="color:#66d9ef">else</span> right <span style="color:#f92672">=</span> mid;
    }
    <span style="color:#66d9ef">return</span> mid;
}
</code></pre></div><h2 id="参考">参考</h2>
<p>链接：https://www.acwing.com/blog/content/31/</p>
]]></content>
        </item>
        
        <item>
            <title>Java IO</title>
            <link>https://oxygenbytes.github.io/posts/2020/10/java-io/</link>
            <pubDate>Tue, 27 Oct 2020 23:06:27 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2020/10/java-io/</guid>
            <description>一、概览 Java 的 I/O 大概可以分成以下几类：
 磁盘操作：File 字节操作：InputStream 和 OutputStream 字符操作：Reader 和 Writer 对象操作：Serializable 网络操作：Socket 新的输入/输出：NIO  二、磁盘操作 File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。
递归地列出一个目录下所有文件：
public static void listAllFiles(File dir) { if (dir == null || !dir.exists()) { return; } if (dir.isFile()) { System.out.println(dir.getName()); return; } for (File file : dir.listFiles()) { listAllFiles(file); } } 从 Java7 开始，可以使用 Paths 和 Files 代替 File。
三、字节操作 实现文件复制 public static void copyFile(String src, String dist) throws IOException { FileInputStream in = new FileInputStream(src); FileOutputStream out = new FileOutputStream(dist); byte[] buffer = new byte[20 * 1024]; int cnt; // read() 最多读取 buffer.</description>
            <content type="html"><![CDATA[<h1 id="一概览">一、概览</h1>
<p>Java 的 I/O 大概可以分成以下几类：</p>
<ul>
<li>磁盘操作：File</li>
<li>字节操作：InputStream 和 OutputStream</li>
<li>字符操作：Reader 和 Writer</li>
<li>对象操作：Serializable</li>
<li>网络操作：Socket</li>
<li>新的输入/输出：NIO</li>
</ul>
<h1 id="二磁盘操作">二、磁盘操作</h1>
<p>File 类可以用于表示文件和目录的信息，但是它不表示文件的内容。</p>
<p>递归地列出一个目录下所有文件：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">listAllFiles</span><span style="color:#f92672">(</span>File dir<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>dir <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>dir<span style="color:#f92672">.</span><span style="color:#a6e22e">exists</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>dir<span style="color:#f92672">.</span><span style="color:#a6e22e">isFile</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>dir<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">());</span>
        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>File file <span style="color:#f92672">:</span> dir<span style="color:#f92672">.</span><span style="color:#a6e22e">listFiles</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        listAllFiles<span style="color:#f92672">(</span>file<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>从 Java7 开始，可以使用 Paths 和 Files 代替 File。</p>
<h1 id="三字节操作">三、字节操作</h1>
<h2 id="实现文件复制">实现文件复制</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">copyFile</span><span style="color:#f92672">(</span>String src<span style="color:#f92672">,</span> String dist<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
    FileInputStream in <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span>src<span style="color:#f92672">);</span>
    FileOutputStream out <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span>dist<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> buffer <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>20 <span style="color:#f92672">*</span> 1024<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">int</span> cnt<span style="color:#f92672">;</span>

    <span style="color:#75715e">// read() 最多读取 buffer.length 个字节
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 返回的是实际读取的个数
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 返回 -1 的时候表示读到 eof，即文件尾
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>cnt <span style="color:#f92672">=</span> in<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>buffer<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> buffer<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        out<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>buffer<span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> cnt<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    in<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
    out<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="装饰者模式">装饰者模式</h2>
<p>Java I/O 使用了装饰者模式来实现。以 InputStream 为例，</p>
<ul>
<li>InputStream 是抽象组件；</li>
<li>FileInputStream 是 InputStream 的子类，属于具体组件，提供了字节流的输入操作；</li>
<li>FilterInputStream 属于抽象装饰者，装饰者用于装饰组件，为组件提供额外的功能。例如 BufferedInputStream 为 FileInputStream 提供缓存的功能。</li>
</ul>
<!-- raw HTML omitted -->
<p>实例化一个具有缓存功能的字节流对象时，只需要在 FileInputStream 对象上再套一层 BufferedInputStream 对象即可。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">FileInputStream fileInputStream <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span>filePath<span style="color:#f92672">);</span>
BufferedInputStream bufferedInputStream <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedInputStream<span style="color:#f92672">(</span>fileInputStream<span style="color:#f92672">);</span>
</code></pre></div><p>DataInputStream 装饰者提供了对更多数据类型进行输入的操作，比如 int、double 等基本类型。</p>
<h1 id="四字符操作">四、字符操作</h1>
<h2 id="编码与解码">编码与解码</h2>
<p>编码就是把字符转换为字节，而解码是把字节重新组合成字符。</p>
<p>如果编码和解码过程使用不同的编码方式那么就出现了乱码。</p>
<ul>
<li>GBK 编码中，中文字符占 2 个字节，英文字符占 1 个字节；</li>
<li>UTF-8 编码中，中文字符占 3 个字节，英文字符占 1 个字节；</li>
<li>UTF-16be 编码中，中文字符和英文字符都占 2 个字节。</li>
</ul>
<p>UTF-16be 中的 be 指的是 Big Endian，也就是大端。相应地也有 UTF-16le，le 指的是 Little Endian，也就是小端。</p>
<p>Java 的内存编码使用双字节编码 UTF-16be，这不是指 Java 只支持这一种编码方式，而是说 char 这种类型使用 UTF-16be 进行编码。char 类型占 16 位，也就是两个字节，Java 使用这种双字节编码是为了让一个中文或者一个英文都能使用一个 char 来存储。</p>
<h2 id="string-的编码方式">String 的编码方式</h2>
<p>String 可以看成一个字符序列，可以指定一个编码方式将它编码为字节序列，也可以指定一个编码方式将一个字节序列解码为 String。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String str1 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;中文&#34;</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> bytes <span style="color:#f92672">=</span> str1<span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;UTF-8&#34;</span><span style="color:#f92672">);</span>
String str2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span>bytes<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;UTF-8&#34;</span><span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>str2<span style="color:#f92672">);</span>
</code></pre></div><p>在调用无参数 getBytes() 方法时，默认的编码方式不是 UTF-16be。双字节编码的好处是可以使用一个 char 存储中文和英文，而将 String 转为 bytes[] 字节数组就不再需要这个好处，因此也就不再需要双字节编码。getBytes() 的默认编码方式与平台有关，一般为 UTF-8。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> bytes <span style="color:#f92672">=</span> str1<span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">();</span>
</code></pre></div><h2 id="reader-与-writer">Reader 与 Writer</h2>
<p>不管是磁盘还是网络传输，最小的存储单元都是字节，而不是字符。但是在程序中操作的通常是字符形式的数据，因此需要提供对字符进行操作的方法。</p>
<ul>
<li>InputStreamReader 实现从字节流解码成字符流；</li>
<li>OutputStreamWriter 实现字符流编码成为字节流。</li>
</ul>
<h2 id="实现逐行输出文本文件的内容">实现逐行输出文本文件的内容</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">readFileContent</span><span style="color:#f92672">(</span>String filePath<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>

    FileReader fileReader <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileReader<span style="color:#f92672">(</span>filePath<span style="color:#f92672">);</span>
    BufferedReader bufferedReader <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedReader<span style="color:#f92672">(</span>fileReader<span style="color:#f92672">);</span>

    String line<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>line <span style="color:#f92672">=</span> bufferedReader<span style="color:#f92672">.</span><span style="color:#a6e22e">readLine</span><span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>line<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#75715e">// 装饰者模式使得 BufferedReader 组合了一个 Reader 对象
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 在调用 BufferedReader 的 close() 方法时会去调用 Reader 的 close() 方法
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 因此只要一个 close() 调用即可
</span><span style="color:#75715e"></span>    bufferedReader<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="五对象操作">五、对象操作</h1>
<h2 id="序列化">序列化</h2>
<p>序列化就是将一个对象转换成字节序列，方便存储和传输。</p>
<ul>
<li>序列化：ObjectOutputStream.writeObject()</li>
<li>反序列化：ObjectInputStream.readObject()</li>
</ul>
<p>不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。</p>
<h2 id="serializable">Serializable</h2>
<p>序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException<span style="color:#f92672">,</span> ClassNotFoundException <span style="color:#f92672">{</span>

    A a1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> A<span style="color:#f92672">(</span>123<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;abc&#34;</span><span style="color:#f92672">);</span>
    String objectFile <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;file/a1&#34;</span><span style="color:#f92672">;</span>

    ObjectOutputStream objectOutputStream <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectOutputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span>objectFile<span style="color:#f92672">));</span>
    objectOutputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">writeObject</span><span style="color:#f92672">(</span>a1<span style="color:#f92672">);</span>
    objectOutputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>

    ObjectInputStream objectInputStream <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectInputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span>objectFile<span style="color:#f92672">));</span>
    A a2 <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>A<span style="color:#f92672">)</span> objectInputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">readObject</span><span style="color:#f92672">();</span>
    objectInputStream<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>a2<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> <span style="color:#66d9ef">implements</span> Serializable <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> x<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> String y<span style="color:#f92672">;</span>

    A<span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x<span style="color:#f92672">,</span> String y<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> y<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">toString</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;x = &#34;</span> <span style="color:#f92672">+</span> x <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;  &#34;</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;y = &#34;</span> <span style="color:#f92672">+</span> y<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="transient">transient</h2>
<p>transient 关键字可以使一些属性不会被序列化。</p>
<p>ArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">transient</span> Object<span style="color:#f92672">[]</span> elementData<span style="color:#f92672">;</span>
</code></pre></div><h1 id="六网络操作">六、网络操作</h1>
<p>Java 中的网络支持：</p>
<ul>
<li>InetAddress：用于表示网络上的硬件资源，即 IP 地址；</li>
<li>URL：统一资源定位符；</li>
<li>Sockets：使用 TCP 协议实现网络通信；</li>
<li>Datagram：使用 UDP 协议实现网络通信。</li>
</ul>
<p>同步和异步：同步和异步是针对应用程序和内核的交互而言的，同步指的是用户进程触发IO 操作并等待或者轮询的去查看IO 操作是否就绪，而异步是指用户进程触发IO 操作以后便开始做自己的事情，而当IO 操作已经完成的时候会得到IO 完成的通知。</p>
<p>以银行取款为例：</p>
<p>同步 ： 自己亲自出马持银行卡到银行取钱（使用同步 IO 时，Java 自己处理IO 读写）；</p>
<p>异步 ： 委托一小弟拿银行卡到银行取钱，然后给你（使用异步IO 时，Java 将 IO 读写委托给OS 处理，需要将数据缓冲区地址和大小传给OS(银行卡和密码)，OS 需要支持异步IO操作API）；</p>
<p>阻塞和非阻塞：阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式，说白了是一种读取或者写入操作方法的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入方法会立即返回一个状态值。</p>
<p>以银行取款为例：</p>
<p>阻塞 ： ATM排队取款，你只能等待（使用阻塞IO时，Java调用会一直阻塞到读写完成才返回）；</p>
<p>非阻塞 ： 柜台取款，取个号，然后坐在椅子上做其它事，等号广播会通知你办理，没到号你就不能去，你可以不断问大堂经理排到了没有，大堂经理如果说还没到你就不能去（使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器通知可读写时再继续进行读写，不断循环直到读写完成）</p>
<h2 id="inetaddress">InetAddress</h2>
<p>没有公有的构造函数，只能通过静态方法来创建实例。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">InetAddress<span style="color:#f92672">.</span><span style="color:#a6e22e">getByName</span><span style="color:#f92672">(</span>String host<span style="color:#f92672">);</span>
InetAddress<span style="color:#f92672">.</span><span style="color:#a6e22e">getByAddress</span><span style="color:#f92672">(</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> address<span style="color:#f92672">);</span>
</code></pre></div><h2 id="url">URL</h2>
<p>可以直接从 URL 中读取字节流数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>

    URL url <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> URL<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;http://www.baidu.com&#34;</span><span style="color:#f92672">);</span>

    <span style="color:#75715e">/* 字节流 */</span>
    InputStream is <span style="color:#f92672">=</span> url<span style="color:#f92672">.</span><span style="color:#a6e22e">openStream</span><span style="color:#f92672">();</span>

    <span style="color:#75715e">/* 字符流 */</span>
    InputStreamReader isr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> InputStreamReader<span style="color:#f92672">(</span>is<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;utf-8&#34;</span><span style="color:#f92672">);</span>

    <span style="color:#75715e">/* 提供缓存功能 */</span>
    BufferedReader br <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> BufferedReader<span style="color:#f92672">(</span>isr<span style="color:#f92672">);</span>

    String line<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>line <span style="color:#f92672">=</span> br<span style="color:#f92672">.</span><span style="color:#a6e22e">readLine</span><span style="color:#f92672">())</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>line<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    br<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="sockets">Sockets</h2>
<ul>
<li>ServerSocket：服务器端类</li>
<li>Socket：客户端类</li>
<li>服务器和客户端通过 InputStream 和 OutputStream 进行输入输出。</li>
</ul>
<h2 id="datagram">Datagram</h2>
<ul>
<li>DatagramSocket：通信类</li>
<li>DatagramPacket：数据包类</li>
</ul>
<h1 id="七nio">七、NIO</h1>
<p>新的输入/输出 (NIO) 库是在 JDK 1.4 中引入的，弥补了原来的 I/O 的不足，提供了高速的、面向块的 I/O。</p>
<h2 id="流与块">流与块</h2>
<p>I/O 与 NIO 最重要的区别是数据打包和传输的方式，I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。</p>
<p>面向流的 I/O 一次处理一个字节数据：一个输入流产生一个字节数据，一个输出流消费一个字节数据。为流式数据创建过滤器非常容易，链接几个过滤器，以便每个过滤器只负责复杂处理机制的一部分。不利的一面是，面向流的 I/O 通常相当慢。</p>
<p>面向块的 I/O 一次处理一个数据块，按块处理数据比按流处理数据要快得多。但是面向块的 I/O 缺少一些面向流的 I/O 所具有的优雅性和简单性。</p>
<p>I/O 包和 NIO 已经很好地集成了，java.io.* 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。例如，java.io.* 包中的一些类包含以块的形式读写数据的方法，这使得即使在面向流的系统中，处理速度也会更快。</p>
<h2 id="通道与缓冲区">通道与缓冲区</h2>
<h3 id="1-通道">1. 通道</h3>
<p>通道 Channel 是对原 I/O 包中的流的模拟，可以通过它读取和写入数据。</p>
<p>通道与流的不同之处在于，流只能在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)，而通道是双向的，可以用于读、写或者同时用于读写。</p>
<p>通道包括以下类型：</p>
<ul>
<li>FileChannel：从文件中读写数据；</li>
<li>DatagramChannel：通过 UDP 读写网络中数据；</li>
<li>SocketChannel：通过 TCP 读写网络中数据；</li>
<li>ServerSocketChannel：可以监听新进来的 TCP 连接，对每一个新进来的连接都会创建一个 SocketChannel。</li>
</ul>
<h3 id="2-缓冲区">2. 缓冲区</h3>
<p>发送给一个通道的所有数据都必须首先放到缓冲区中，同样地，从通道中读取的任何数据都要先读到缓冲区中。也就是说，不会直接对通道进行读写数据，而是要先经过缓冲区。</p>
<p>缓冲区实质上是一个数组，但它不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。</p>
<p>缓冲区包括以下类型：</p>
<ul>
<li>ByteBuffer</li>
<li>CharBuffer</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
</ul>
<h2 id="缓冲区状态变量">缓冲区状态变量</h2>
<ul>
<li>capacity：最大容量；</li>
<li>position：当前已经读写的字节数；</li>
<li>limit：还可以读写的字节数。</li>
</ul>
<h2 id="文件-nio-实例">文件 NIO 实例</h2>
<p>以下展示了使用 NIO 快速复制文件的实例：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fastCopy</span><span style="color:#f92672">(</span>String src<span style="color:#f92672">,</span> String dist<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>

    <span style="color:#75715e">/* 获得源文件的输入字节流 */</span>
    FileInputStream fin <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileInputStream<span style="color:#f92672">(</span>src<span style="color:#f92672">);</span>

    <span style="color:#75715e">/* 获取输入字节流的文件通道 */</span>
    FileChannel fcin <span style="color:#f92672">=</span> fin<span style="color:#f92672">.</span><span style="color:#a6e22e">getChannel</span><span style="color:#f92672">();</span>

    <span style="color:#75715e">/* 获取目标文件的输出字节流 */</span>
    FileOutputStream fout <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span>dist<span style="color:#f92672">);</span>

    <span style="color:#75715e">/* 获取输出字节流的文件通道 */</span>
    FileChannel fcout <span style="color:#f92672">=</span> fout<span style="color:#f92672">.</span><span style="color:#a6e22e">getChannel</span><span style="color:#f92672">();</span>

    <span style="color:#75715e">/* 为缓冲区分配 1024 个字节 */</span>
    ByteBuffer buffer <span style="color:#f92672">=</span> ByteBuffer<span style="color:#f92672">.</span><span style="color:#a6e22e">allocateDirect</span><span style="color:#f92672">(</span>1024<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

        <span style="color:#75715e">/* 从输入通道中读取数据到缓冲区中 */</span>
        <span style="color:#66d9ef">int</span> r <span style="color:#f92672">=</span> fcin<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>buffer<span style="color:#f92672">);</span>

        <span style="color:#75715e">/* read() 返回 -1 表示 EOF */</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>r <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">/* 切换读写 */</span>
        buffer<span style="color:#f92672">.</span><span style="color:#a6e22e">flip</span><span style="color:#f92672">();</span>

        <span style="color:#75715e">/* 把缓冲区的内容写入输出文件中 */</span>
        fcout<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>buffer<span style="color:#f92672">);</span>

        <span style="color:#75715e">/* 清空缓冲区 */</span>
        buffer<span style="color:#f92672">.</span><span style="color:#a6e22e">clear</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="选择器">选择器</h2>
<p>NIO 常常被叫做非阻塞 IO，主要是因为 NIO 在网络通信中的非阻塞特性被广泛使用。</p>
<p>NIO 实现了 IO 多路复用中的 Reactor 模型，一个线程 Thread 使用一个选择器 Selector 通过轮询的方式去监听多个通道 Channel 上的事件，从而让一个线程就可以处理多个事件。</p>
<p>通过配置监听的通道 Channel 为非阻塞，那么当 Channel 上的 IO 事件还未到达时，就不会进入阻塞状态一直等待，而是继续轮询其它 Channel，找到 IO 事件已经到达的 Channel 执行。</p>
<p>因为创建和切换线程的开销很大，因此使用一个线程来处理多个事件而不是一个线程处理一个事件，对于 IO 密集型的应用具有很好地性能。</p>
<p>应该注意的是，只有套接字 Channel 才能配置为非阻塞，而 FileChannel 不能，为 FileChannel 配置非阻塞也没有意义。</p>
<h3 id="1-创建选择器">1. 创建选择器</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Selector selector <span style="color:#f92672">=</span> Selector<span style="color:#f92672">.</span><span style="color:#a6e22e">open</span><span style="color:#f92672">();</span>
</code></pre></div><h3 id="2-将通道注册到选择器上">2. 将通道注册到选择器上</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">ServerSocketChannel ssChannel <span style="color:#f92672">=</span> ServerSocketChannel<span style="color:#f92672">.</span><span style="color:#a6e22e">open</span><span style="color:#f92672">();</span>
ssChannel<span style="color:#f92672">.</span><span style="color:#a6e22e">configureBlocking</span><span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
ssChannel<span style="color:#f92672">.</span><span style="color:#a6e22e">register</span><span style="color:#f92672">(</span>selector<span style="color:#f92672">,</span> SelectionKey<span style="color:#f92672">.</span><span style="color:#a6e22e">OP_ACCEPT</span><span style="color:#f92672">);</span>
</code></pre></div><p>通道必须配置为非阻塞模式，否则使用选择器就没有任何意义了，因为如果通道在某个事件上被阻塞，那么服务器就不能响应其它事件，必须等待这个事件处理完毕才能去处理其它事件，显然这和选择器的作用背道而驰。</p>
<p>在将通道注册到选择器上时，还需要指定要注册的具体事件，主要有以下几类：</p>
<ul>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ul>
<p>它们在 SelectionKey 的定义如下：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> OP_READ <span style="color:#f92672">=</span> 1 <span style="color:#f92672">&lt;&lt;</span> 0<span style="color:#f92672">;</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> OP_WRITE <span style="color:#f92672">=</span> 1 <span style="color:#f92672">&lt;&lt;</span> 2<span style="color:#f92672">;</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> OP_CONNECT <span style="color:#f92672">=</span> 1 <span style="color:#f92672">&lt;&lt;</span> 3<span style="color:#f92672">;</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> OP_ACCEPT <span style="color:#f92672">=</span> 1 <span style="color:#f92672">&lt;&lt;</span> 4<span style="color:#f92672">;</span>
</code></pre></div><p>可以看出每个事件可以被当成一个位域，从而组成事件集整数。例如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> interestSet <span style="color:#f92672">=</span> SelectionKey<span style="color:#f92672">.</span><span style="color:#a6e22e">OP_READ</span> <span style="color:#f92672">|</span> SelectionKey<span style="color:#f92672">.</span><span style="color:#a6e22e">OP_WRITE</span><span style="color:#f92672">;</span>
</code></pre></div><h3 id="3-监听事件">3. 监听事件</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> selector<span style="color:#f92672">.</span><span style="color:#a6e22e">select</span><span style="color:#f92672">();</span>
</code></pre></div><p>使用 select() 来监听到达的事件，它会一直阻塞直到有至少一个事件到达。</p>
<h3 id="4-获取到达的事件">4. 获取到达的事件</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Set<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> keys <span style="color:#f92672">=</span> selector<span style="color:#f92672">.</span><span style="color:#a6e22e">selectedKeys</span><span style="color:#f92672">();</span>
Iterator<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> keyIterator <span style="color:#f92672">=</span> keys<span style="color:#f92672">.</span><span style="color:#a6e22e">iterator</span><span style="color:#f92672">();</span>
<span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>keyIterator<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
    SelectionKey key <span style="color:#f92672">=</span> keyIterator<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">isAcceptable</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">isReadable</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
    keyIterator<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="5-事件循环">5. 事件循环</h3>
<p>因为一次 select() 调用不能处理完所有的事件，并且服务器端有可能需要一直监听事件，因此服务器端处理事件的代码一般会放在一个死循环内。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> num <span style="color:#f92672">=</span> selector<span style="color:#f92672">.</span><span style="color:#a6e22e">select</span><span style="color:#f92672">();</span>
    Set<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> keys <span style="color:#f92672">=</span> selector<span style="color:#f92672">.</span><span style="color:#a6e22e">selectedKeys</span><span style="color:#f92672">();</span>
    Iterator<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> keyIterator <span style="color:#f92672">=</span> keys<span style="color:#f92672">.</span><span style="color:#a6e22e">iterator</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>keyIterator<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
        SelectionKey key <span style="color:#f92672">=</span> keyIterator<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">isAcceptable</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">isReadable</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
        keyIterator<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="套接字-nio-实例">套接字 NIO 实例</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NIOServer</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>

        Selector selector <span style="color:#f92672">=</span> Selector<span style="color:#f92672">.</span><span style="color:#a6e22e">open</span><span style="color:#f92672">();</span>

        ServerSocketChannel ssChannel <span style="color:#f92672">=</span> ServerSocketChannel<span style="color:#f92672">.</span><span style="color:#a6e22e">open</span><span style="color:#f92672">();</span>
        ssChannel<span style="color:#f92672">.</span><span style="color:#a6e22e">configureBlocking</span><span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>
        ssChannel<span style="color:#f92672">.</span><span style="color:#a6e22e">register</span><span style="color:#f92672">(</span>selector<span style="color:#f92672">,</span> SelectionKey<span style="color:#f92672">.</span><span style="color:#a6e22e">OP_ACCEPT</span><span style="color:#f92672">);</span>

        ServerSocket serverSocket <span style="color:#f92672">=</span> ssChannel<span style="color:#f92672">.</span><span style="color:#a6e22e">socket</span><span style="color:#f92672">();</span>
        InetSocketAddress address <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> InetSocketAddress<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;127.0.0.1&#34;</span><span style="color:#f92672">,</span> 8888<span style="color:#f92672">);</span>
        serverSocket<span style="color:#f92672">.</span><span style="color:#a6e22e">bind</span><span style="color:#f92672">(</span>address<span style="color:#f92672">);</span>

        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

            selector<span style="color:#f92672">.</span><span style="color:#a6e22e">select</span><span style="color:#f92672">();</span>
            Set<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> keys <span style="color:#f92672">=</span> selector<span style="color:#f92672">.</span><span style="color:#a6e22e">selectedKeys</span><span style="color:#f92672">();</span>
            Iterator<span style="color:#f92672">&lt;</span>SelectionKey<span style="color:#f92672">&gt;</span> keyIterator <span style="color:#f92672">=</span> keys<span style="color:#f92672">.</span><span style="color:#a6e22e">iterator</span><span style="color:#f92672">();</span>

            <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>keyIterator<span style="color:#f92672">.</span><span style="color:#a6e22e">hasNext</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>

                SelectionKey key <span style="color:#f92672">=</span> keyIterator<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">();</span>

                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">isAcceptable</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>

                    ServerSocketChannel ssChannel1 <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>ServerSocketChannel<span style="color:#f92672">)</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">channel</span><span style="color:#f92672">();</span>

                    <span style="color:#75715e">// 服务器会为每个新连接创建一个 SocketChannel
</span><span style="color:#75715e"></span>                    SocketChannel sChannel <span style="color:#f92672">=</span> ssChannel1<span style="color:#f92672">.</span><span style="color:#a6e22e">accept</span><span style="color:#f92672">();</span>
                    sChannel<span style="color:#f92672">.</span><span style="color:#a6e22e">configureBlocking</span><span style="color:#f92672">(</span><span style="color:#66d9ef">false</span><span style="color:#f92672">);</span>

                    <span style="color:#75715e">// 这个新连接主要用于从客户端读取数据
</span><span style="color:#75715e"></span>                    sChannel<span style="color:#f92672">.</span><span style="color:#a6e22e">register</span><span style="color:#f92672">(</span>selector<span style="color:#f92672">,</span> SelectionKey<span style="color:#f92672">.</span><span style="color:#a6e22e">OP_READ</span><span style="color:#f92672">);</span>

                <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key<span style="color:#f92672">.</span><span style="color:#a6e22e">isReadable</span><span style="color:#f92672">())</span> <span style="color:#f92672">{</span>

                    SocketChannel sChannel <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>SocketChannel<span style="color:#f92672">)</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">channel</span><span style="color:#f92672">();</span>
                    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>readDataFromSocketChannel<span style="color:#f92672">(</span>sChannel<span style="color:#f92672">));</span>
                    sChannel<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
                <span style="color:#f92672">}</span>

                keyIterator<span style="color:#f92672">.</span><span style="color:#a6e22e">remove</span><span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> String <span style="color:#a6e22e">readDataFromSocketChannel</span><span style="color:#f92672">(</span>SocketChannel sChannel<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>

        ByteBuffer buffer <span style="color:#f92672">=</span> ByteBuffer<span style="color:#f92672">.</span><span style="color:#a6e22e">allocate</span><span style="color:#f92672">(</span>1024<span style="color:#f92672">);</span>
        StringBuilder data <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StringBuilder<span style="color:#f92672">();</span>

        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">true</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>

            buffer<span style="color:#f92672">.</span><span style="color:#a6e22e">clear</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> sChannel<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>buffer<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            buffer<span style="color:#f92672">.</span><span style="color:#a6e22e">flip</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">int</span> limit <span style="color:#f92672">=</span> buffer<span style="color:#f92672">.</span><span style="color:#a6e22e">limit</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">char</span><span style="color:#f92672">[]</span> dst <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">char</span><span style="color:#f92672">[</span>limit<span style="color:#f92672">];</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> limit<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
                dst<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">char</span><span style="color:#f92672">)</span> buffer<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            data<span style="color:#f92672">.</span><span style="color:#a6e22e">append</span><span style="color:#f92672">(</span>dst<span style="color:#f92672">);</span>
            buffer<span style="color:#f92672">.</span><span style="color:#a6e22e">clear</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> data<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NIOClient</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> IOException <span style="color:#f92672">{</span>
        Socket socket <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Socket<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;127.0.0.1&#34;</span><span style="color:#f92672">,</span> 8888<span style="color:#f92672">);</span>
        OutputStream out <span style="color:#f92672">=</span> socket<span style="color:#f92672">.</span><span style="color:#a6e22e">getOutputStream</span><span style="color:#f92672">();</span>
        String s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;hello world&#34;</span><span style="color:#f92672">;</span>
        out<span style="color:#f92672">.</span><span style="color:#a6e22e">write</span><span style="color:#f92672">(</span>s<span style="color:#f92672">.</span><span style="color:#a6e22e">getBytes</span><span style="color:#f92672">());</span>
        out<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="内存映射文件">内存映射文件</h2>
<p>内存映射文件 I/O 是一种读和写文件数据的方法，它可以比常规的基于流或者基于通道的 I/O 快得多。</p>
<p>向内存映射文件写入可能是危险的，只是改变数组的单个元素这样的简单操作，就可能会直接修改磁盘上的文件。修改数据与将数据保存到磁盘是没有分开的。</p>
<p>下面代码行将文件的前 1024 个字节映射到内存中，map() 方法返回一个 MappedByteBuffer，它是 ByteBuffer 的子类。因此，可以像使用其他任何 ByteBuffer 一样使用新映射的缓冲区，操作系统会在需要时负责执行映射。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">MappedByteBuffer mbb <span style="color:#f92672">=</span> fc<span style="color:#f92672">.</span><span style="color:#a6e22e">map</span><span style="color:#f92672">(</span>FileChannel<span style="color:#f92672">.</span><span style="color:#a6e22e">MapMode</span><span style="color:#f92672">.</span><span style="color:#a6e22e">READ_WRITE</span><span style="color:#f92672">,</span> 0<span style="color:#f92672">,</span> 1024<span style="color:#f92672">);</span>
</code></pre></div><h2 id="对比">对比</h2>
<p>NIO 与普通 I/O 的区别主要有以下两点：</p>
<ul>
<li>NIO 是非阻塞的；</li>
<li>NIO 面向块，I/O 面向流。</li>
</ul>
]]></content>
        </item>
        
        <item>
            <title>Java 基础</title>
            <link>https://oxygenbytes.github.io/posts/2020/10/java-%E5%9F%BA%E7%A1%80/</link>
            <pubDate>Tue, 27 Oct 2020 23:06:27 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2020/10/java-%E5%9F%BA%E7%A1%80/</guid>
            <description>一、数据类型 基本类型  byte/8 char/16 short/16 int/32 float/32 long/64 double/64 boolean/~  boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。
数据类型转换 从高到低转换 强制转换 从低到高转换 自动转换
int i = 128; byte b = (byte)i; double d = i; 包装类型 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。
Integer x = 2; // 装箱 int y = x; // 拆箱 缓存池 new Integer(123) 与 Integer.valueOf(123) 的区别在于：
 new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。  Integer x = new Integer(123); Integer y = new Integer(123); System.</description>
            <content type="html"><![CDATA[<h1 id="一数据类型">一、数据类型</h1>
<h2 id="基本类型">基本类型</h2>
<ul>
<li>byte/8</li>
<li>char/16</li>
<li>short/16</li>
<li>int/32</li>
<li>float/32</li>
<li>long/64</li>
<li>double/64</li>
<li>boolean/~</li>
</ul>
<p>boolean 只有两个值：true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。</p>
<h2 id="数据类型转换">数据类型转换</h2>
<p>从高到低转换 强制转换
从低到高转换 自动转换</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 128<span style="color:#f92672">;</span>
<span style="color:#66d9ef">byte</span> b <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">byte</span><span style="color:#f92672">)</span>i<span style="color:#f92672">;</span>
<span style="color:#66d9ef">double</span> d <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
</code></pre></div><h2 id="包装类型">包装类型</h2>
<p>基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Integer x <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span>     <span style="color:#75715e">// 装箱
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span>         <span style="color:#75715e">// 拆箱
</span></code></pre></div><h2 id="缓存池">缓存池</h2>
<p>new Integer(123) 与 Integer.valueOf(123) 的区别在于：</p>
<ul>
<li>new Integer(123) 每次都会新建一个对象；</li>
<li>Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Integer x <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>123<span style="color:#f92672">);</span>
Integer y <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>123<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> y<span style="color:#f92672">);</span>    <span style="color:#75715e">// false
</span><span style="color:#75715e"></span>Integer z <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span>123<span style="color:#f92672">);</span>
Integer k <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span>123<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>z <span style="color:#f92672">==</span> k<span style="color:#f92672">);</span>   <span style="color:#75715e">// true
</span></code></pre></div><p>valueOf() 方法的实现比较简单，就是先判断值是否在缓存池中，如果在的话就直接返回缓存池的内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> Integer <span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>i <span style="color:#f92672">&gt;=</span> IntegerCache<span style="color:#f92672">.</span><span style="color:#a6e22e">low</span> <span style="color:#f92672">&amp;&amp;</span> i <span style="color:#f92672">&lt;=</span> IntegerCache<span style="color:#f92672">.</span><span style="color:#a6e22e">high</span><span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> IntegerCache<span style="color:#f92672">.</span><span style="color:#a6e22e">cache</span><span style="color:#f92672">[</span>i <span style="color:#f92672">+</span> <span style="color:#f92672">(-</span>IntegerCache<span style="color:#f92672">.</span><span style="color:#a6e22e">low</span><span style="color:#f92672">)];</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>i<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>在 Java 8 中，Integer 缓存池的大小默认为 -128~127。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> low <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>128<span style="color:#f92672">;</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> high<span style="color:#f92672">;</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> Integer cache<span style="color:#f92672">[];</span>

<span style="color:#66d9ef">static</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// high value may be configured by property
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> 127<span style="color:#f92672">;</span>
    String integerCacheHighPropValue <span style="color:#f92672">=</span>
        sun<span style="color:#f92672">.</span><span style="color:#a6e22e">misc</span><span style="color:#f92672">.</span><span style="color:#a6e22e">VM</span><span style="color:#f92672">.</span><span style="color:#a6e22e">getSavedProperty</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;java.lang.Integer.IntegerCache.high&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>integerCacheHighPropValue <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> parseInt<span style="color:#f92672">(</span>integerCacheHighPropValue<span style="color:#f92672">);</span>
            i <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>i<span style="color:#f92672">,</span> 127<span style="color:#f92672">);</span>
            <span style="color:#75715e">// Maximum array size is Integer.MAX_VALUE
</span><span style="color:#75715e"></span>            h <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>i<span style="color:#f92672">,</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span> <span style="color:#f92672">-</span> <span style="color:#f92672">(-</span>low<span style="color:#f92672">)</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span><span style="color:#f92672">(</span> NumberFormatException nfe<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// If the property cannot be parsed into an int, ignore it.
</span><span style="color:#75715e"></span>        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    high <span style="color:#f92672">=</span> h<span style="color:#f92672">;</span>

    cache <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">[(</span>high <span style="color:#f92672">-</span> low<span style="color:#f92672">)</span> <span style="color:#f92672">+</span> 1<span style="color:#f92672">];</span>
    <span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> low<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> k <span style="color:#f92672">&lt;</span> cache<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> k<span style="color:#f92672">++)</span>
        cache<span style="color:#f92672">[</span>k<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>j<span style="color:#f92672">++);</span>

    <span style="color:#75715e">// range [-128, 127] must be interned (JLS7 5.1.7)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">assert</span> IntegerCache<span style="color:#f92672">.</span><span style="color:#a6e22e">high</span> <span style="color:#f92672">&gt;=</span> 127<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>编译器会在自动装箱过程调用 valueOf() 方法，因此多个 Integer 实例使用自动装箱来创建并且值相同，那么就会引用相同的对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Integer m <span style="color:#f92672">=</span> 123<span style="color:#f92672">;</span>
Integer n <span style="color:#f92672">=</span> 123<span style="color:#f92672">;</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>m <span style="color:#f92672">==</span> n<span style="color:#f92672">);</span> <span style="color:#75715e">// true
</span></code></pre></div><p>基本类型对应的缓冲池如下：</p>
<ul>
<li>boolean values true and false</li>
<li>all byte values</li>
<li>short values between -128 and 127</li>
<li>int values between -128 and 127</li>
<li>char in the range \u0000 to \u007F</li>
</ul>
<p>在使用这些基本类型对应的包装类型时，就可以直接使用缓冲池中的对象。</p>
<h1 id="二string">二、String</h1>
<h2 id="概览">概览</h2>
<p>String 被声明为 final，因此它不可被继承。</p>
<p>在 Java 8 中，String 内部使用 char 数组存储数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>
    <span style="color:#66d9ef">implements</span> java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Serializable</span><span style="color:#f92672">,</span> Comparable<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;,</span> CharSequence <span style="color:#f92672">{</span>
    <span style="color:#75715e">/** The value is used for character storage. */</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">char</span> value<span style="color:#f92672">[];</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>value 数组被声明为 final，这意味着 value 数组初始化之后就不能再引用其它数组。并且 String 内部没有改变 value 数组的方法，因此可以保证 String 不可变。</p>
<h2 id="不可变的好处">不可变的好处</h2>
<p><strong>1. 可以缓存 hash 值</strong></p>
<p>因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。</p>
<p><strong>2. String Pool 的需要</strong></p>
<p>如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。</p>
<p><strong>3. 安全性</strong></p>
<p>String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。</p>
<p><strong>4. 线程安全</strong></p>
<p>String 不可变性天生具备线程安全，可以在多个线程中安全地使用。</p>
<h2 id="string-stringbuffer-and-stringbuilder">String, StringBuffer and StringBuilder</h2>
<p><strong>1. 可变性</strong></p>
<ul>
<li>String 不可变</li>
<li>StringBuffer 和 StringBuilder 可变</li>
</ul>
<p><strong>2. 线程安全</strong></p>
<ul>
<li>String 不可变，因此是线程安全的</li>
<li>StringBuilder 不是线程安全的</li>
<li>StringBuffer 是线程安全的，内部使用 synchronized 进行同步</li>
</ul>
<h2 id="string-pool">String Pool</h2>
<p>字符串常量池（String Pool）保存着所有字符串字面量（literal strings），这些字面量在编译时期就确定。不仅如此，还可以使用 String 的 intern() 方法在运行过程中将字符串添加到 String Pool 中。</p>
<p>当一个字符串调用 intern() 方法时，如果 String Pool 中已经存在一个字符串和该字符串值相等（使用 equals() 方法进行确定），那么就会返回 String Pool 中字符串的引用；否则，就会在 String Pool 中添加一个新的字符串，并返回这个新字符串的引用。</p>
<p>下面示例中，s1 和 s2 采用 new String() 的方式新建了两个不同字符串，而 s3 和 s4 是通过 s1.intern() 方法取得一个字符串引用。intern() 首先把 s1 引用的字符串放到 String Pool 中，然后返回这个字符串引用。因此 s3 和 s4 引用的是同一个字符串。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String s1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;aaa&#34;</span><span style="color:#f92672">);</span>
String s2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;aaa&#34;</span><span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>s1 <span style="color:#f92672">==</span> s2<span style="color:#f92672">);</span>           <span style="color:#75715e">// false
</span><span style="color:#75715e"></span>String s3 <span style="color:#f92672">=</span> s1<span style="color:#f92672">.</span><span style="color:#a6e22e">intern</span><span style="color:#f92672">();</span>
String s4 <span style="color:#f92672">=</span> s1<span style="color:#f92672">.</span><span style="color:#a6e22e">intern</span><span style="color:#f92672">();</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>s3 <span style="color:#f92672">==</span> s4<span style="color:#f92672">);</span>           <span style="color:#75715e">// true
</span></code></pre></div><p>如果是采用 &ldquo;bbb&rdquo; 这种字面量的形式创建字符串，会自动地将字符串放入 String Pool 中。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String s5 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bbb&#34;</span><span style="color:#f92672">;</span>
String s6 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;bbb&#34;</span><span style="color:#f92672">;</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>s5 <span style="color:#f92672">==</span> s6<span style="color:#f92672">);</span>  <span style="color:#75715e">// true
</span></code></pre></div><h2 id="new-stringabc">new String(&ldquo;abc&rdquo;)</h2>
<p>使用这种方式一共会创建两个字符串对象（前提是 String Pool 中还没有 &ldquo;abc&rdquo; 字符串对象）。</p>
<ul>
<li>&ldquo;abc&rdquo; 属于字符串字面量，因此编译时期会在 String Pool 中创建一个字符串对象，指向这个 &ldquo;abc&rdquo; 字符串字面量；</li>
<li>而使用 new 的方式会在堆中创建一个字符串对象。</li>
</ul>
<p>创建一个测试类，其 main 方法中使用这种方式来创建字符串对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">NewStringTest</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        String s <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> String<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;abc&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>使用 javap -verbose 进行反编译，得到以下内容：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>Constant pool<span style="color:#f92672">:</span>
<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>   <span style="color:#960050;background-color:#1e0010">#</span>2 <span style="color:#f92672">=</span> Class              <span style="color:#960050;background-color:#1e0010">#</span>18            <span style="color:#75715e">// java/lang/String
</span><span style="color:#75715e"></span>   <span style="color:#960050;background-color:#1e0010">#</span>3 <span style="color:#f92672">=</span> String             <span style="color:#960050;background-color:#1e0010">#</span>19            <span style="color:#75715e">// abc
</span><span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>  <span style="color:#960050;background-color:#1e0010">#</span>18 <span style="color:#f92672">=</span> Utf8               java<span style="color:#f92672">/</span>lang<span style="color:#f92672">/</span>String
  <span style="color:#960050;background-color:#1e0010">#</span>19 <span style="color:#f92672">=</span> Utf8               abc
<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>java<span style="color:#f92672">.</span><span style="color:#a6e22e">lang</span><span style="color:#f92672">.</span><span style="color:#a6e22e">String</span><span style="color:#f92672">[]);</span>
    descriptor<span style="color:#f92672">:</span> <span style="color:#f92672">([</span>Ljava<span style="color:#f92672">/</span>lang<span style="color:#f92672">/</span>String<span style="color:#f92672">;)</span>V
    flags<span style="color:#f92672">:</span> ACC_PUBLIC<span style="color:#f92672">,</span> ACC_STATIC
    Code<span style="color:#f92672">:</span>
      stack<span style="color:#f92672">=</span>3<span style="color:#f92672">,</span> locals<span style="color:#f92672">=</span>2<span style="color:#f92672">,</span> args_size<span style="color:#f92672">=</span>1
         0<span style="color:#f92672">:</span> <span style="color:#66d9ef">new</span>           <span style="color:#960050;background-color:#1e0010">#</span>2                  <span style="color:#75715e">// class java/lang/String
</span><span style="color:#75715e"></span>         3<span style="color:#f92672">:</span> dup
         4<span style="color:#f92672">:</span> ldc           <span style="color:#960050;background-color:#1e0010">#</span>3                  <span style="color:#75715e">// String abc
</span><span style="color:#75715e"></span>         6<span style="color:#f92672">:</span> invokespecial <span style="color:#960050;background-color:#1e0010">#</span>4                  <span style="color:#75715e">// Method java/lang/String.&#34;&lt;init&gt;&#34;:(Ljava/lang/String;)V
</span><span style="color:#75715e"></span>         9<span style="color:#f92672">:</span> astore_1
<span style="color:#75715e">// ...
</span></code></pre></div><p>在 Constant Pool 中，#19 存储这字符串字面量 &ldquo;abc&rdquo;，#3 是 String Pool 的字符串对象，它指向 #19 这个字符串字面量。在 main 方法中，0: 行使用 new #2 在堆中创建一个字符串对象，并且使用 ldc #3 将 String Pool 中的字符串对象作为 String 构造函数的参数。</p>
<p>以下是 String 构造函数的源码，可以看到，在将一个字符串对象作为另一个字符串对象的构造函数参数时，并不会完全复制 value 数组内容，而是都会指向同一个 value 数组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">String</span><span style="color:#f92672">(</span>String original<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> original<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">=</span> original<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="三运算">三、运算</h1>
<h2 id="参数传递">参数传递</h2>
<p>Java 的参数是以值传递的形式传入方法中，而不是引用传递。</p>
<p>以下代码中 Dog dog 的 dog 是一个指针，存储的是对象的地址。在将一个参数传入一个方法时，本质上是将对象的地址以值的方式传递到形参中。因此在方法中使指针引用其它对象，那么这两个指针此时指向的是完全不同的对象，在一方改变其所指向对象的内容时对另一方没有影响。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Dog</span> <span style="color:#f92672">{</span>

    String name<span style="color:#f92672">;</span>

    Dog<span style="color:#f92672">(</span>String name<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    String <span style="color:#a6e22e">getName</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span>String name<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">name</span> <span style="color:#f92672">=</span> name<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    String <span style="color:#a6e22e">getObjectAddress</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PassByValueExample</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Dog dog <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Dog<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>dog<span style="color:#f92672">.</span><span style="color:#a6e22e">getObjectAddress</span><span style="color:#f92672">());</span> <span style="color:#75715e">// Dog@4554617c
</span><span style="color:#75715e"></span>        func<span style="color:#f92672">(</span>dog<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>dog<span style="color:#f92672">.</span><span style="color:#a6e22e">getObjectAddress</span><span style="color:#f92672">());</span> <span style="color:#75715e">// Dog@4554617c
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>dog<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">());</span>          <span style="color:#75715e">// A
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span><span style="color:#f92672">(</span>Dog dog<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>dog<span style="color:#f92672">.</span><span style="color:#a6e22e">getObjectAddress</span><span style="color:#f92672">());</span> <span style="color:#75715e">// Dog@4554617c
</span><span style="color:#75715e"></span>        dog <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Dog<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;B&#34;</span><span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>dog<span style="color:#f92672">.</span><span style="color:#a6e22e">getObjectAddress</span><span style="color:#f92672">());</span> <span style="color:#75715e">// Dog@74a14482
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>dog<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">());</span>          <span style="color:#75715e">// B
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>如果在方法中改变对象的字段值会改变原对象该字段值，因为改变的是同一个地址指向的内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">PassByValueExample</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Dog dog <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Dog<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;A&#34;</span><span style="color:#f92672">);</span>
        func<span style="color:#f92672">(</span>dog<span style="color:#f92672">);</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>dog<span style="color:#f92672">.</span><span style="color:#a6e22e">getName</span><span style="color:#f92672">());</span>          <span style="color:#75715e">// B
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span><span style="color:#f92672">(</span>Dog dog<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        dog<span style="color:#f92672">.</span><span style="color:#a6e22e">setName</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;B&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><a href="https://stackoverflow.com/questions/40480/is-java-pass-by-reference-or-pass-by-value">StackOverflow: Is Java “pass-by-reference” or “pass-by-value”?</a></p>
<h2 id="float-与-double">float 与 double</h2>
<p>Java 不能隐式执行向下转型，因为这会使得精度降低。</p>
<p>1.1 字面量属于 double 类型，不能直接将 1.1 直接赋值给 float 变量，因为这是向下转型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// float f = 1.1;
</span></code></pre></div><p>1.1f 字面量才是 float 类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">float</span> f <span style="color:#f92672">=</span> 1<span style="color:#f92672">.</span><span style="color:#a6e22e">1f</span><span style="color:#f92672">;</span>
</code></pre></div><h2 id="隐式类型转换">隐式类型转换</h2>
<p>因为字面量 1 是 int 类型，它比 short 类型精度要高，因此不能隐式地将 int 类型下转型为 short 类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">short</span> s1 <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
<span style="color:#75715e">// s1 = s1 + 1;
</span></code></pre></div><p>但是使用 += 或者 ++ 运算符可以执行隐式类型转换。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">s1 <span style="color:#f92672">+=</span> 1<span style="color:#f92672">;</span>
<span style="color:#75715e">// s1++;
</span></code></pre></div><p>上面的语句相当于将 s1 + 1 的计算结果进行了向下转型：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">s1 <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">short</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>s1 <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>
</code></pre></div><p><a href="https://stackoverflow.com/questions/8710619/why-dont-javas-compound-assignment-operators-require-casting">StackOverflow : Why don&rsquo;t Java&rsquo;s +=, -=, *=, /= compound assignment operators require casting?</a></p>
<h2 id="switch">switch</h2>
<p>从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">String s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">switch</span> <span style="color:#f92672">(</span>s<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">:</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;aaa&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">case</span> <span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">:</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;bbb&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// long x = 111;
</span><span style="color:#75715e">// switch (x) { // Incompatible types. Found: &#39;long&#39;, required: &#39;char, byte, short, int, Character, Byte, Short, Integer, String, or an enum&#39;
</span><span style="color:#75715e">//     case 111:
</span><span style="color:#75715e">//         System.out.println(111);
</span><span style="color:#75715e">//         break;
</span><span style="color:#75715e">//     case 222:
</span><span style="color:#75715e">//         System.out.println(222);
</span><span style="color:#75715e">//         break;
</span><span style="color:#75715e">// }
</span></code></pre></div><p><a href="https://stackoverflow.com/questions/2676210/why-cant-your-switch-statement-data-type-be-long-java">StackOverflow : Why can&rsquo;t your switch statement data type be long, Java?</a></p>
<h1 id="四继承">四、继承</h1>
<h2 id="访问权限">访问权限</h2>
<p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。</p>
<p>可以对类或类中的成员（字段以及方法）加上访问修饰符。</p>
<ul>
<li>类可见表示其它类可以用这个类创建实例对象。</li>
<li>成员可见表示其它类可以用这个类的实例对象访问到该成员；</li>
</ul>
<p>protected 用于修饰成员，表示在继承体系中成员对于子类可见，但是这个访问修饰符对于类没有意义。</p>
<p>设计良好的模块会隐藏所有的实现细节，把它的 API 与它的实现清晰地隔离开来。模块之间只通过它们的 API 进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏或封装。因此访问权限应当尽可能地使每个类或者成员不被外界访问。</p>
<p>如果子类的方法重写了父类的方法，那么子类中该方法的访问级别不允许低于父类的访问级别。这是为了确保可以使用父类实例的地方都可以使用子类实例，也就是确保满足里氏替换原则。</p>
<p>字段决不能是公有的，因为这么做的话就失去了对这个字段修改行为的控制，客户端可以对其随意修改。例如下面的例子中，AccessExample 拥有 id 公有字段，如果在某个时刻，我们想要使用 int 存储 id 字段，那么就需要修改所有的客户端代码。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AccessExample</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> String id<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>可以使用公有的 getter 和 setter 方法来替换公有字段，这样的话就可以控制对字段的修改行为。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AccessExample</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> id<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">getId</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> id <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setId</span><span style="color:#f92672">(</span>String id<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">id</span> <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">valueOf</span><span style="color:#f92672">(</span>id<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>但是也有例外，如果是包级私有的类或者私有的嵌套类，那么直接暴露成员不会有特别大的影响。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AccessWithInnerClassExample</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InnerClass</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> x<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">private</span> InnerClass innerClass<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">AccessWithInnerClassExample</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        innerClass <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> InnerClass<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getValue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> innerClass<span style="color:#f92672">.</span><span style="color:#a6e22e">x</span><span style="color:#f92672">;</span>  <span style="color:#75715e">// 直接访问
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="抽象类与接口">抽象类与接口</h2>
<p><strong>1. 抽象类</strong></p>
<p>抽象类和抽象方法都使用 abstract 关键字进行声明。抽象类一般会包含抽象方法，抽象方法一定位于抽象类中。</p>
<p>抽象类和普通类最大的区别是，抽象类不能被实例化，需要继承抽象类才能实例化其子类。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractClassExample</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> x<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> y<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func1</span><span style="color:#f92672">();</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func2</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;func2&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">AbstractExtendClassExample</span> <span style="color:#66d9ef">extends</span> AbstractClassExample <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func1</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;func1&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// AbstractClassExample ac1 = new AbstractClassExample(); // &#39;AbstractClassExample&#39; is abstract; cannot be instantiated
</span><span style="color:#75715e"></span>AbstractClassExample ac2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> AbstractExtendClassExample<span style="color:#f92672">();</span>
ac2<span style="color:#f92672">.</span><span style="color:#a6e22e">func1</span><span style="color:#f92672">();</span>
</code></pre></div><p><strong>2. 接口</strong></p>
<p>接口是抽象类的延伸，在 Java 8 之前，它可以看成是一个完全抽象的类，也就是说它不能有任何的方法实现。</p>
<p>从 Java 8 开始，接口也可以拥有默认的方法实现，这是因为不支持默认方法的接口的维护成本太高了。在 Java 8 之前，如果一个接口想要添加新的方法，那么要修改所有实现了该接口的类。</p>
<p>接口的成员（字段 + 方法）默认都是 public 的，并且不允许定义为 private 或者 protected。</p>
<p>接口的字段默认都是 static 和 final 的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">InterfaceExample</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func1</span><span style="color:#f92672">();</span>

    <span style="color:#66d9ef">default</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func2</span><span style="color:#f92672">(){</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;func2&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> 123<span style="color:#f92672">;</span>
    <span style="color:#75715e">// int y;               // Variable &#39;y&#39; might not have been initialized
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> z <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>       <span style="color:#75715e">// Modifier &#39;public&#39; is redundant for interface fields
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// private int k = 0;   // Modifier &#39;private&#39; not allowed here
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// protected int l = 0; // Modifier &#39;protected&#39; not allowed here
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// private void fun3(); // Modifier &#39;private&#39; not allowed here
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InterfaceImplementExample</span> <span style="color:#66d9ef">implements</span> InterfaceExample <span style="color:#f92672">{</span>
    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func1</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;func1&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">// InterfaceExample ie1 = new InterfaceExample(); // &#39;InterfaceExample&#39; is abstract; cannot be instantiated
</span><span style="color:#75715e"></span>InterfaceExample ie2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> InterfaceImplementExample<span style="color:#f92672">();</span>
ie2<span style="color:#f92672">.</span><span style="color:#a6e22e">func1</span><span style="color:#f92672">();</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>InterfaceExample<span style="color:#f92672">.</span><span style="color:#a6e22e">x</span><span style="color:#f92672">);</span>
</code></pre></div><p><strong>3. 比较</strong></p>
<ul>
<li>从设计层面上看，抽象类提供了一种 IS-A 关系，那么就必须满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。</li>
<li>从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。</li>
<li>接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。</li>
<li>接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。</li>
</ul>
<p><strong>4. 使用选择</strong></p>
<p>使用接口：</p>
<ul>
<li>需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；</li>
<li>需要使用多重继承。</li>
</ul>
<p>使用抽象类：</p>
<ul>
<li>需要在几个相关的类中共享代码。</li>
<li>需要能控制继承来的成员的访问权限，而不是都为 public。</li>
<li>需要继承非静态和非常量字段。</li>
</ul>
<p>在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/java/l-javainterface-abstract/">深入理解 abstract class 和 interface</a></li>
<li><a href="https://dzone.com/articles/when-to-use-abstract-class-and-intreface">When to Use Abstract Class and Interface</a></li>
</ul>
<h2 id="super">super</h2>
<ul>
<li>访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</li>
<li>访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SuperExample</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> x<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> y<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">SuperExample</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> y<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> y<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;SuperExample.func()&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SuperExtendExample</span> <span style="color:#66d9ef">extends</span> SuperExample <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> z<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">SuperExtendExample</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> y<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> z<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>x<span style="color:#f92672">,</span> y<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">z</span> <span style="color:#f92672">=</span> z<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">func</span><span style="color:#f92672">();</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;SuperExtendExample.func()&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">SuperExample e <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> SuperExtendExample<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> 2<span style="color:#f92672">,</span> 3<span style="color:#f92672">);</span>
e<span style="color:#f92672">.</span><span style="color:#a6e22e">func</span><span style="color:#f92672">();</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">SuperExample.func()
SuperExtendExample.func()
</code></pre></div><h2 id="重写与重载">重写与重载</h2>
<p><strong>1. 重写（Override）</strong></p>
<p>存在于继承体系中，指子类实现了一个与父类在方法声明上完全相同的一个方法。</p>
<p>为了满足里式替换原则，重写有有以下两个限制：</p>
<ul>
<li>子类方法的访问权限必须大于等于父类方法；</li>
<li>子类方法的返回类型必须是父类方法返回类型或为其子类型。</li>
</ul>
<p>使用 @Override 注解，可以让编译器帮忙检查是否满足上面的两个限制条件。</p>
<p><strong>2. 重载（Overload）</strong></p>
<p>存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是参数类型、个数、顺序至少有一个不同。</p>
<p>应该注意的是，返回值不同，其它都相同不算是重载。</p>
<p><strong>3. 实例</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">show</span><span style="color:#f92672">(</span>D obj<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;A and D&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">show</span><span style="color:#f92672">(</span>A obj<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;A and A&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#66d9ef">extends</span> A <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">show</span><span style="color:#f92672">(</span>B obj<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;B and B&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">show</span><span style="color:#f92672">(</span>A obj<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span><span style="color:#e6db74">&#34;B and A&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">C</span> <span style="color:#66d9ef">extends</span> B <span style="color:#f92672">{</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">D</span> <span style="color:#66d9ef">extends</span> B <span style="color:#f92672">{</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Test</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        A a1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> A<span style="color:#f92672">();</span>
        A a2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> B<span style="color:#f92672">();</span>
        B b <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> B<span style="color:#f92672">();</span>
        C c <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> C<span style="color:#f92672">();</span>
        D d <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> D<span style="color:#f92672">();</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>a1<span style="color:#f92672">.</span><span style="color:#a6e22e">show</span><span style="color:#f92672">(</span>b<span style="color:#f92672">));</span> <span style="color:#75715e">// A and A
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>a1<span style="color:#f92672">.</span><span style="color:#a6e22e">show</span><span style="color:#f92672">(</span>c<span style="color:#f92672">));</span> <span style="color:#75715e">// A and A
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>a1<span style="color:#f92672">.</span><span style="color:#a6e22e">show</span><span style="color:#f92672">(</span>d<span style="color:#f92672">));</span> <span style="color:#75715e">// A and D
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>a2<span style="color:#f92672">.</span><span style="color:#a6e22e">show</span><span style="color:#f92672">(</span>b<span style="color:#f92672">));</span> <span style="color:#75715e">// B and A
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>a2<span style="color:#f92672">.</span><span style="color:#a6e22e">show</span><span style="color:#f92672">(</span>c<span style="color:#f92672">));</span> <span style="color:#75715e">// B and A
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>a2<span style="color:#f92672">.</span><span style="color:#a6e22e">show</span><span style="color:#f92672">(</span>d<span style="color:#f92672">));</span> <span style="color:#75715e">// A and D
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>b<span style="color:#f92672">.</span><span style="color:#a6e22e">show</span><span style="color:#f92672">(</span>b<span style="color:#f92672">));</span>  <span style="color:#75715e">// B and B
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>b<span style="color:#f92672">.</span><span style="color:#a6e22e">show</span><span style="color:#f92672">(</span>c<span style="color:#f92672">));</span>  <span style="color:#75715e">// B and B
</span><span style="color:#75715e"></span>        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>b<span style="color:#f92672">.</span><span style="color:#a6e22e">show</span><span style="color:#f92672">(</span>d<span style="color:#f92672">));</span>  <span style="color:#75715e">// A and D
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>涉及到重写时，方法调用的优先级为：</p>
<ul>
<li>this.show(O)</li>
<li>super.show(O)</li>
<li>this.show((super)O)</li>
<li>super.show((super)O)</li>
</ul>
<h1 id="五object-通用方法">五、Object 通用方法</h1>
<h2 id="概览-1">概览</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">native</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object obj<span style="color:#f92672">)</span>

<span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">native</span> Object <span style="color:#a6e22e">clone</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> CloneNotSupportedException

<span style="color:#66d9ef">public</span> String <span style="color:#a6e22e">toString</span><span style="color:#f92672">()</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">native</span> Class<span style="color:#f92672">&lt;?&gt;</span> getClass<span style="color:#f92672">()</span>

<span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">finalize</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> Throwable <span style="color:#f92672">{}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">native</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">notify</span><span style="color:#f92672">()</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">native</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">notifyAll</span><span style="color:#f92672">()</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">native</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">wait</span><span style="color:#f92672">(</span><span style="color:#66d9ef">long</span> timeout<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> InterruptedException

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">wait</span><span style="color:#f92672">(</span><span style="color:#66d9ef">long</span> timeout<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> nanos<span style="color:#f92672">)</span> <span style="color:#66d9ef">throws</span> InterruptedException

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">wait</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> InterruptedException
</code></pre></div><h2 id="equals">equals()</h2>
<p><strong>1. 等价关系</strong></p>
<p>Ⅰ 自反性</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">x<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>x<span style="color:#f92672">);</span> <span style="color:#75715e">// true
</span></code></pre></div><p>Ⅱ 对称性</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">x<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>y<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> y<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>x<span style="color:#f92672">);</span> <span style="color:#75715e">// true
</span></code></pre></div><p>Ⅲ 传递性</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>y<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> y<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>z<span style="color:#f92672">))</span>
    x<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>z<span style="color:#f92672">);</span> <span style="color:#75715e">// true;
</span></code></pre></div><p>Ⅳ 一致性</p>
<p>多次调用 equals() 方法结果不变</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">x<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>y<span style="color:#f92672">)</span> <span style="color:#f92672">==</span> x<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>y<span style="color:#f92672">);</span> <span style="color:#75715e">// true
</span></code></pre></div><p>Ⅴ 与 null 的比较</p>
<p>对任何不是 null 的对象 x 调用 x.equals(null) 结果都为 false</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">x<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span><span style="color:#66d9ef">null</span><span style="color:#f92672">);</span> <span style="color:#75715e">// false;
</span></code></pre></div><p><strong>2. 等价与相等</strong></p>
<ul>
<li>对于基本类型，== 判断两个值是否相等，基本类型没有 equals() 方法。</li>
<li>对于引用类型，== 判断两个变量是否引用同一个对象，而 equals() 判断引用的对象是否等价。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Integer x <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
Integer y <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Integer<span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>x<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>y<span style="color:#f92672">));</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>x <span style="color:#f92672">==</span> y<span style="color:#f92672">);</span>      <span style="color:#75715e">// false
</span></code></pre></div><p><strong>3. 实现</strong></p>
<ul>
<li>检查是否为同一个对象的引用，如果是直接返回 true；</li>
<li>检查是否是同一个类型，如果不是，直接返回 false；</li>
<li>将 Object 对象进行转型；</li>
<li>判断每个关键域是否相等。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EqualExample</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> x<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> y<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> z<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">EqualExample</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> x<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> y<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> z<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> y<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">z</span> <span style="color:#f92672">=</span> z<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object o<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span> <span style="color:#f92672">==</span> o<span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>o <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">||</span> getClass<span style="color:#f92672">()</span> <span style="color:#f92672">!=</span> o<span style="color:#f92672">.</span><span style="color:#a6e22e">getClass</span><span style="color:#f92672">())</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>

        EqualExample that <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>EqualExample<span style="color:#f92672">)</span> o<span style="color:#f92672">;</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>x <span style="color:#f92672">!=</span> that<span style="color:#f92672">.</span><span style="color:#a6e22e">x</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>y <span style="color:#f92672">!=</span> that<span style="color:#f92672">.</span><span style="color:#a6e22e">y</span><span style="color:#f92672">)</span> <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> z <span style="color:#f92672">==</span> that<span style="color:#f92672">.</span><span style="color:#a6e22e">z</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="hashcode">hashCode()</h2>
<p>hashCode() 返回散列值，而 equals() 是用来判断两个对象是否等价。等价的两个对象散列值一定相同，但是散列值相同的两个对象不一定等价。</p>
<p>在覆盖 equals() 方法时应当总是覆盖 hashCode() 方法，保证等价的两个对象散列值也相等。</p>
<p>下面的代码中，新建了两个等价的对象，并将它们添加到 HashSet 中。我们希望将这两个对象当成一样的，只在集合中添加一个对象，但是因为 EqualExample 没有实现 hasCode() 方法，因此这两个对象的散列值是不同的，最终导致集合添加了两个等价的对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">EqualExample e1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> EqualExample<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> 1<span style="color:#f92672">,</span> 1<span style="color:#f92672">);</span>
EqualExample e2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> EqualExample<span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> 1<span style="color:#f92672">,</span> 1<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>e1<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>e2<span style="color:#f92672">));</span> <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>HashSet<span style="color:#f92672">&lt;</span>EqualExample<span style="color:#f92672">&gt;</span> set <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashSet<span style="color:#f92672">&lt;&gt;();</span>
set<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>e1<span style="color:#f92672">);</span>
set<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>e2<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>set<span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">());</span>   <span style="color:#75715e">// 2
</span></code></pre></div><p>理想的散列函数应当具有均匀性，即不相等的对象应当均匀分布到所有可能的散列值上。这就要求了散列函数要把所有域的值都考虑进来。可以将每个域都当成 R 进制的某一位，然后组成一个 R 进制的整数。R 一般取 31，因为它是一个奇素数，如果是偶数的话，当出现乘法溢出，信息就会丢失，因为与 2 相乘相当于向左移一位。</p>
<p>一个数与 31 相乘可以转换成移位和减法：<code>31*x == (x&lt;&lt;5)-x</code>，编译器会自动进行这个优化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@Override</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> 17<span style="color:#f92672">;</span>
    result <span style="color:#f92672">=</span> 31 <span style="color:#f92672">*</span> result <span style="color:#f92672">+</span> x<span style="color:#f92672">;</span>
    result <span style="color:#f92672">=</span> 31 <span style="color:#f92672">*</span> result <span style="color:#f92672">+</span> y<span style="color:#f92672">;</span>
    result <span style="color:#f92672">=</span> 31 <span style="color:#f92672">*</span> result <span style="color:#f92672">+</span> z<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="tostring">toString()</h2>
<p>默认返回 ToStringExample@4554617c 这种形式，其中 @ 后面的数值为散列码的无符号十六进制表示。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ToStringExample</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> number<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ToStringExample</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> number<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">number</span> <span style="color:#f92672">=</span> number<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">ToStringExample example <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ToStringExample<span style="color:#f92672">(</span>123<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>example<span style="color:#f92672">.</span><span style="color:#a6e22e">toString</span><span style="color:#f92672">());</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">ToStringExample@4554617c
</code></pre></div><h2 id="clone">clone()</h2>
<p><strong>1. cloneable</strong></p>
<p>clone() 是 Object 的 protected 方法，它不是 public，一个类不显式去重写 clone()，其它类就不能直接去调用该类实例的 clone() 方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CloneExample</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> a<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> b<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">CloneExample e1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CloneExample<span style="color:#f92672">();</span>
<span style="color:#75715e">// CloneExample e2 = e1.clone(); // &#39;clone()&#39; has protected access in &#39;java.lang.Object&#39;
</span></code></pre></div><p>重写 clone() 得到以下实现：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CloneExample</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> a<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> b<span style="color:#f92672">;</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> CloneExample <span style="color:#a6e22e">clone</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> CloneNotSupportedException <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>CloneExample<span style="color:#f92672">)</span><span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">clone</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">CloneExample e1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CloneExample<span style="color:#f92672">();</span>
<span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
    CloneExample e2 <span style="color:#f92672">=</span> e1<span style="color:#f92672">.</span><span style="color:#a6e22e">clone</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>CloneNotSupportedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">java.lang.CloneNotSupportedException: CloneExample
</code></pre></div><p>以上抛出了 CloneNotSupportedException，这是因为 CloneExample 没有实现 Cloneable 接口。</p>
<p>应该注意的是，clone() 方法并不是 Cloneable 接口的方法，而是 Object 的一个 protected 方法。Cloneable 接口只是规定，如果一个类没有实现 Cloneable 接口又调用了 clone() 方法，就会抛出 CloneNotSupportedException。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CloneExample</span> <span style="color:#66d9ef">implements</span> Cloneable <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> a<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> b<span style="color:#f92672">;</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> Object <span style="color:#a6e22e">clone</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> CloneNotSupportedException <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">clone</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><strong>2. 浅拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用同一个对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ShallowCloneExample</span> <span style="color:#66d9ef">implements</span> Cloneable <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ShallowCloneExample</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        arr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>10<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        arr<span style="color:#f92672">[</span>index<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">[</span>index<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">protected</span> ShallowCloneExample <span style="color:#a6e22e">clone</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> CloneNotSupportedException <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>ShallowCloneExample<span style="color:#f92672">)</span> <span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">clone</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">ShallowCloneExample e1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ShallowCloneExample<span style="color:#f92672">();</span>
ShallowCloneExample e2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
    e2 <span style="color:#f92672">=</span> e1<span style="color:#f92672">.</span><span style="color:#a6e22e">clone</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>CloneNotSupportedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
e1<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>2<span style="color:#f92672">,</span> 222<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>e2<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>2<span style="color:#f92672">));</span> <span style="color:#75715e">// 222
</span></code></pre></div><p><strong>3. 深拷贝</strong></p>
<p>拷贝对象和原始对象的引用类型引用不同对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">DeepCloneExample</span> <span style="color:#66d9ef">implements</span> Cloneable <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">DeepCloneExample</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        arr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>10<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        arr<span style="color:#f92672">[</span>index<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">[</span>index<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">protected</span> DeepCloneExample <span style="color:#a6e22e">clone</span><span style="color:#f92672">()</span> <span style="color:#66d9ef">throws</span> CloneNotSupportedException <span style="color:#f92672">{</span>
        DeepCloneExample result <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>DeepCloneExample<span style="color:#f92672">)</span> <span style="color:#66d9ef">super</span><span style="color:#f92672">.</span><span style="color:#a6e22e">clone</span><span style="color:#f92672">();</span>
        result<span style="color:#f92672">.</span><span style="color:#a6e22e">arr</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            result<span style="color:#f92672">.</span><span style="color:#a6e22e">arr</span><span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> arr<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> result<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">DeepCloneExample e1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> DeepCloneExample<span style="color:#f92672">();</span>
DeepCloneExample e2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
    e2 <span style="color:#f92672">=</span> e1<span style="color:#f92672">.</span><span style="color:#a6e22e">clone</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span> <span style="color:#66d9ef">catch</span> <span style="color:#f92672">(</span>CloneNotSupportedException e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    e<span style="color:#f92672">.</span><span style="color:#a6e22e">printStackTrace</span><span style="color:#f92672">();</span>
<span style="color:#f92672">}</span>
e1<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>2<span style="color:#f92672">,</span> 222<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>e2<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>2<span style="color:#f92672">));</span> <span style="color:#75715e">// 2
</span></code></pre></div><p><strong>4. clone() 的替代方案</strong></p>
<p>使用 clone() 方法来拷贝一个对象即复杂又有风险，它会抛出异常，并且还需要类型转换。Effective Java 书上讲到，最好不要去使用 clone()，可以使用拷贝构造函数或者拷贝工厂来拷贝一个对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CloneConstructorExample</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> arr<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">CloneConstructorExample</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        arr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>10<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> arr<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> i<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">CloneConstructorExample</span><span style="color:#f92672">(</span>CloneConstructorExample original<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        arr <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>original<span style="color:#f92672">.</span><span style="color:#a6e22e">arr</span><span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">];</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> i <span style="color:#f92672">&lt;</span> original<span style="color:#f92672">.</span><span style="color:#a6e22e">arr</span><span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            arr<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> original<span style="color:#f92672">.</span><span style="color:#a6e22e">arr</span><span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        arr<span style="color:#f92672">[</span>index<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> arr<span style="color:#f92672">[</span>index<span style="color:#f92672">];</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">CloneConstructorExample e1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CloneConstructorExample<span style="color:#f92672">();</span>
CloneConstructorExample e2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CloneConstructorExample<span style="color:#f92672">(</span>e1<span style="color:#f92672">);</span>
e1<span style="color:#f92672">.</span><span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>2<span style="color:#f92672">,</span> 222<span style="color:#f92672">);</span>
System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>e2<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>2<span style="color:#f92672">));</span> <span style="color:#75715e">// 2
</span></code></pre></div><h1 id="六关键字">六、关键字</h1>
<h2 id="final">final</h2>
<p><strong>1. 数据</strong></p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
<span style="color:#75715e">// x = 2;  // cannot assign value to final variable &#39;x&#39;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">final</span> A y <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> A<span style="color:#f92672">();</span>
y<span style="color:#f92672">.</span><span style="color:#a6e22e">a</span> <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
</code></pre></div><p><strong>2. 方法</strong></p>
<p>声明方法不能被子类重写。</p>
<p>private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。</p>
<p><strong>3. 类</strong></p>
<p>声明类不允许被继承。</p>
<h2 id="static">static</h2>
<p><strong>1. 静态变量</strong></p>
<ul>
<li>静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</li>
<li>实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> x<span style="color:#f92672">;</span>         <span style="color:#75715e">// 实例变量
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> y<span style="color:#f92672">;</span>  <span style="color:#75715e">// 静态变量
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// int x = A.x;  // Non-static field &#39;x&#39; cannot be referenced from a static context
</span><span style="color:#75715e"></span>        A a <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> A<span style="color:#f92672">();</span>
        <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> a<span style="color:#f92672">.</span><span style="color:#a6e22e">x</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span> y <span style="color:#f92672">=</span> A<span style="color:#f92672">.</span><span style="color:#a6e22e">y</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><strong>2. 静态方法</strong></p>
<p>静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func1</span><span style="color:#f92672">(){</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// public abstract static void func2();  // Illegal combination of modifiers: &#39;abstract&#39; and &#39;static&#39;
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><p>只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> x<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> y<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">func1</span><span style="color:#f92672">(){</span>
        <span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> x<span style="color:#f92672">;</span>
        <span style="color:#75715e">// int b = y;  // Non-static field &#39;y&#39; cannot be referenced from a static context
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// int b = this.y;     // &#39;A.this&#39; cannot be referenced from a static context
</span><span style="color:#75715e"></span>    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><strong>3. 静态语句块</strong></p>
<p>静态语句块在类初始化时运行一次。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">static</span> <span style="color:#f92672">{</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;123&#34;</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        A a1 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> A<span style="color:#f92672">();</span>
        A a2 <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> A<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">123
</code></pre></div><p><strong>4. 静态内部类</strong></p>
<p>非静态内部类依赖于外部类的实例，而静态内部类不需要。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">OuterClass</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">InnerClass</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">StaticInnerClass</span> <span style="color:#f92672">{</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// InnerClass innerClass = new InnerClass(); // &#39;OuterClass.this&#39; cannot be referenced from a static context
</span><span style="color:#75715e"></span>        OuterClass outerClass <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> OuterClass<span style="color:#f92672">();</span>
        InnerClass innerClass <span style="color:#f92672">=</span> outerClass<span style="color:#f92672">.</span><span style="color:#a6e22e">new</span> <span style="color:#a6e22e">InnerClass</span><span style="color:#f92672">();</span>
        StaticInnerClass staticInnerClass <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> StaticInnerClass<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>静态内部类不能访问外部类的非静态的变量和方法。</p>
<p><strong>5. 静态导包</strong></p>
<p>在使用静态变量和方法时不用再指明 ClassName，从而简化代码，但可读性大大降低。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">import static</span> com.xxx.ClassName.*
</code></pre></div><p><strong>6. 初始化顺序</strong></p>
<p>静态变量和静态语句块优先于实例变量和普通语句块，静态变量和静态语句块的初始化顺序取决于它们在代码中的顺序。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> String staticField <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;静态变量&#34;</span><span style="color:#f92672">;</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> <span style="color:#f92672">{</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;静态语句块&#34;</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> String field <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;实例变量&#34;</span><span style="color:#f92672">;</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#f92672">{</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;普通语句块&#34;</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>最后才是构造函数的初始化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#a6e22e">InitialOrderTest</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;构造函数&#34;</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>存在继承的情况下，初始化顺序为：</p>
<ul>
<li>父类（静态变量、静态语句块）</li>
<li>子类（静态变量、静态语句块）</li>
<li>父类（实例变量、普通语句块）</li>
<li>父类（构造函数）</li>
<li>子类（实例变量、普通语句块）</li>
<li>子类（构造函数）</li>
</ul>
<h1 id="七反射">七、反射</h1>
<p>每个类都有一个  <strong>Class</strong>  对象，包含了与类有关的信息。当编译一个新类时，会产生一个同名的 .class 文件，该文件内容保存着 Class 对象。</p>
<p>类加载相当于 Class 对象的加载，类在第一次使用时才动态加载到 JVM 中。也可以使用 <code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;)</code> 这种方式来控制类的加载，该方法会返回一个 Class 对象。</p>
<p>反射可以提供运行时的类信息，并且这个类可以在运行时才加载进来，甚至在编译时期该类的 .class 不存在也可以加载进来。</p>
<p>Class 和 java.lang.reflect 一起对反射提供了支持，java.lang.reflect 类库主要包含了以下三个类：</p>
<ul>
<li><strong>Field</strong> ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；</li>
<li><strong>Method</strong> ：可以使用 invoke() 方法调用与 Method 对象关联的方法；</li>
<li><strong>Constructor</strong> ：可以用 Constructor 创建新的对象。</li>
</ul>
<p><strong>反射的优点：</strong></p>
<ul>
<li><strong>可扩展性</strong>  ：应用程序可以利用全限定名创建可扩展对象的实例，来使用来自外部的用户自定义类。</li>
<li><strong>类浏览器和可视化开发环境</strong>  ：一个类浏览器需要可以枚举类的成员。可视化开发环境（如 IDE）可以从利用反射中可用的类型信息中受益，以帮助程序员编写正确的代码。</li>
<li><strong>调试器和测试工具</strong>  ： 调试器需要能够检查一个类里的私有成员。测试工具可以利用反射来自动地调用类里定义的可被发现的 API 定义，以确保一组测试中有较高的代码覆盖率。</li>
</ul>
<p><strong>反射的缺点：</strong></p>
<p>尽管反射非常强大，但也不能滥用。如果一个功能可以不用反射完成，那么最好就不用。在我们使用反射技术时，下面几条内容应该牢记于心。</p>
<ul>
<li>
<p><strong>性能开销</strong>  ：反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。</p>
</li>
<li>
<p><strong>安全限制</strong>  ：使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。</p>
</li>
<li>
<p><strong>内部暴露</strong>  ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。</p>
</li>
</ul>
<h1 id="八异常">八、异常</h1>
<p>Throwable 可以用来表示任何可以作为异常抛出的类，分为两种： <strong>Error</strong>  和 <strong>Exception</strong>。其中 Error 用来表示 JVM 无法处理的错误，Exception 分为两种：</p>
<ul>
<li><strong>受检异常</strong> ：需要用 try&hellip;catch&hellip; 语句捕获并进行处理，并且可以从异常中恢复；</li>
<li><strong>非受检异常</strong> ：是程序运行时错误，例如除 0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。</li>
</ul>
<h1 id="九泛型">九、泛型</h1>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Box</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// T stands for &#34;Type&#34;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">private</span> T t<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">set</span><span style="color:#f92672">(</span>T t<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">t</span> <span style="color:#f92672">=</span> t<span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">public</span> T <span style="color:#a6e22e">get</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span> <span style="color:#66d9ef">return</span> t<span style="color:#f92672">;</span> <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h1 id="十注解">十、注解</h1>
<p>Java 注解是附加在代码中的一些元信息，用于一些工具在编译、运行时进行解析和使用，起到说明、配置的功能。注解不会也不能影响代码的实际逻辑，仅仅起到辅助性的作用。</p>
<h1 id="十一其他">十一、其他</h1>
<h2 id="java-与-c-的区别">Java 与 C++ 的区别</h2>
<ul>
<li>Java 是纯粹的面向对象语言，所有的对象都继承自 java.lang.Object，C++ 为了兼容 C 即支持面向对象也支持面向过程。</li>
<li>Java 通过虚拟机从而实现跨平台特性，但是 C++ 依赖于特定的平台。</li>
<li>Java 没有指针，它的引用可以理解为安全指针，而 C++ 具有和 C 一样的指针。</li>
<li>Java 支持自动垃圾回收，而 C++ 需要手动回收。</li>
<li>Java 不支持多重继承，只能通过实现多个接口来达到相同目的，而 C++ 支持多重继承。</li>
<li>Java 不支持操作符重载，虽然可以对两个 String 对象执行加法运算，但是这是语言内置支持的操作，不属于操作符重载，而 C++ 可以。</li>
<li>Java 的 goto 是保留字，但是不可用，C++ 可以使用 goto。</li>
<li>Java 不支持条件编译，C++ 通过 #ifdef #ifndef 等预处理命令从而实现条件编译。</li>
</ul>
<h2 id="jre-or-jdk">JRE or JDK</h2>
<ul>
<li>JRE is the JVM program, Java application need to run on JRE.</li>
<li>JDK is a superset of JRE, JRE + tools for developing java programs. e.g, it provides the compiler &ldquo;javac&rdquo;</li>
</ul>
<h2 id="java变量命名规范">Java变量命名规范</h2>
<p>所有变量、方法、类名见名知意
类成员变量：首字母小写和驼峰原则：monthSalary,除了第一个单词以外，其他单词首字母大写
局部变量：首字母小写和驼峰原则
常量：大写字母和下划线：MAX_VALUE
类名：首字母大写和驼峰原则:Man,GoodMan
方法名：首字母小写和驼峰原则：getClass();</p>
]]></content>
        </item>
        
        <item>
            <title>Java 容器</title>
            <link>https://oxygenbytes.github.io/posts/2020/10/java-%E5%AE%B9%E5%99%A8/</link>
            <pubDate>Tue, 27 Oct 2020 23:06:27 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2020/10/java-%E5%AE%B9%E5%99%A8/</guid>
            <description>一、概览 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。
1. Set   TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。
  HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。
  LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。
  2. List   ArrayList：基于动态数组实现，支持随机访问。
  Vector：和 ArrayList 类似，但它是线程安全的。
  LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。
  3. Queue   LinkedList：可以用它来实现双向队列。
  PriorityQueue：基于堆结构实现，可以用它来实现优先队列。
  Map   TreeMap：基于红黑树实现。
  HashMap：基于哈希表实现。
  HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</description>
            <content type="html"><![CDATA[<h1 id="一概览">一、概览</h1>
<p>容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。</p>
<h3 id="1-set">1. Set</h3>
<ul>
<li>
<p>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</p>
</li>
<li>
<p>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</p>
</li>
<li>
<p>LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</p>
</li>
</ul>
<h3 id="2-list">2. List</h3>
<ul>
<li>
<p>ArrayList：基于动态数组实现，支持随机访问。</p>
</li>
<li>
<p>Vector：和 ArrayList 类似，但它是线程安全的。</p>
</li>
<li>
<p>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</p>
</li>
</ul>
<h3 id="3-queue">3. Queue</h3>
<ul>
<li>
<p>LinkedList：可以用它来实现双向队列。</p>
</li>
<li>
<p>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</p>
</li>
</ul>
<h2 id="map">Map</h2>
<ul>
<li>
<p>TreeMap：基于红黑树实现。</p>
</li>
<li>
<p>HashMap：基于哈希表实现。</p>
</li>
<li>
<p>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</p>
</li>
<li>
<p>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</p>
</li>
</ul>
<h1 id="二容器中的设计模式">二、容器中的设计模式</h1>
<h2 id="迭代器模式">迭代器模式</h2>
<p>Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。</p>
<p>从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">);</span>
list<span style="color:#f92672">.</span><span style="color:#a6e22e">add</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">);</span>
<span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>String item <span style="color:#f92672">:</span> list<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>item<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><h2 id="适配器模式">适配器模式</h2>
<p>java.util.Arrays#asList() 可以把数组类型转换为 List 类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@SafeVarargs</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> List<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>T<span style="color:#f92672">...</span> a<span style="color:#f92672">)</span>
</code></pre></div><p>应该注意的是 asList() 的参数为泛型的变长参数，不能使用基本类型数组作为参数，只能使用相应的包装类型数组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Integer<span style="color:#f92672">[]</span> arr <span style="color:#f92672">=</span> <span style="color:#f92672">{</span>1<span style="color:#f92672">,</span> 2<span style="color:#f92672">,</span> 3<span style="color:#f92672">};</span>
List list <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>arr<span style="color:#f92672">);</span>
</code></pre></div><p>也可以使用以下方式调用 asList()：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">List list <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">asList</span><span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> 2<span style="color:#f92672">,</span> 3<span style="color:#f92672">);</span>
</code></pre></div><h1 id="三源码分析">三、源码分析</h1>
<p>如果没有特别说明，以下源码分析基于 JDK 1.8。</p>
<p>在 IDEA 中 double shift 调出 Search EveryWhere，查找源码文件，找到之后就可以阅读源码。</p>
<h2 id="arraylist">ArrayList</h2>
<h3 id="1-概览">1. 概览</h3>
<p>实现了 RandomAccess 接口，因此支持随机访问。这是理所当然的，因为 ArrayList 是基于数组实现的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ArrayList</span><span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">extends</span> AbstractList<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span>
        <span style="color:#66d9ef">implements</span> List<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;,</span> RandomAccess<span style="color:#f92672">,</span> Cloneable<span style="color:#f92672">,</span> java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Serializable</span>
</code></pre></div><p>数组的默认大小为 10。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> DEFAULT_CAPACITY <span style="color:#f92672">=</span> 10<span style="color:#f92672">;</span>
</code></pre></div><h3 id="2-扩容">2. 扩容</h3>
<p>添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 <code>oldCapacity + (oldCapacity &gt;&gt; 1)</code>，也就是旧容量的 1.5 倍。</p>
<p>扩容操作需要调用 <code>Arrays.copyOf()</code> 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>E e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    ensureCapacityInternal<span style="color:#f92672">(</span>size <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>  <span style="color:#75715e">// Increments modCount!!
</span><span style="color:#75715e"></span>    elementData<span style="color:#f92672">[</span>size<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ensureCapacityInternal</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> minCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>elementData <span style="color:#f92672">==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        minCapacity <span style="color:#f92672">=</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">max</span><span style="color:#f92672">(</span>DEFAULT_CAPACITY<span style="color:#f92672">,</span> minCapacity<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    ensureExplicitCapacity<span style="color:#f92672">(</span>minCapacity<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ensureExplicitCapacity</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> minCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    modCount<span style="color:#f92672">++;</span>
    <span style="color:#75715e">// overflow-conscious code
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>minCapacity <span style="color:#f92672">-</span> elementData<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span> <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span>
        grow<span style="color:#f92672">(</span>minCapacity<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">grow</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> minCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// overflow-conscious code
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> oldCapacity <span style="color:#f92672">=</span> elementData<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> newCapacity <span style="color:#f92672">=</span> oldCapacity <span style="color:#f92672">+</span> <span style="color:#f92672">(</span>oldCapacity <span style="color:#f92672">&gt;&gt;</span> 1<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">-</span> minCapacity <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
        newCapacity <span style="color:#f92672">=</span> minCapacity<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">-</span> MAX_ARRAY_SIZE <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span>
        newCapacity <span style="color:#f92672">=</span> hugeCapacity<span style="color:#f92672">(</span>minCapacity<span style="color:#f92672">);</span>
    <span style="color:#75715e">// minCapacity is usually close to size, so this is a win:
</span><span style="color:#75715e"></span>    elementData <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">copyOf</span><span style="color:#f92672">(</span>elementData<span style="color:#f92672">,</span> newCapacity<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="3-删除元素">3. 删除元素</h3>
<p>需要调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，该操作的时间复杂度为 O(N)，可以看出 ArrayList 删除元素的代价是非常高的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> E <span style="color:#a6e22e">remove</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    rangeCheck<span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>
    modCount<span style="color:#f92672">++;</span>
    E oldValue <span style="color:#f92672">=</span> elementData<span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> numMoved <span style="color:#f92672">=</span> size <span style="color:#f92672">-</span> index <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>numMoved <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span>
        System<span style="color:#f92672">.</span><span style="color:#a6e22e">arraycopy</span><span style="color:#f92672">(</span>elementData<span style="color:#f92672">,</span> index<span style="color:#f92672">+</span>1<span style="color:#f92672">,</span> elementData<span style="color:#f92672">,</span> index<span style="color:#f92672">,</span> numMoved<span style="color:#f92672">);</span>
    elementData<span style="color:#f92672">[--</span>size<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> <span style="color:#75715e">// clear to let GC do its work
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> oldValue<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="4-fail-fast">4. Fail-Fast</h3>
<p>modCount 用来记录 ArrayList 结构发生变化的次数。结构发生变化是指添加或者删除至少一个元素的所有操作，或者是调整内部数组的大小，仅仅只是设置元素的值不算结构发生变化。</p>
<p>在进行序列化或者迭代等操作时，需要比较操作前后 modCount 是否改变，如果改变了需要抛出 ConcurrentModificationException。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">writeObject</span><span style="color:#f92672">(</span>java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">ObjectOutputStream</span> s<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">throws</span> java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">IOException</span><span style="color:#f92672">{</span>
    <span style="color:#75715e">// Write out element count, and any hidden stuff
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> expectedModCount <span style="color:#f92672">=</span> modCount<span style="color:#f92672">;</span>
    s<span style="color:#f92672">.</span><span style="color:#a6e22e">defaultWriteObject</span><span style="color:#f92672">();</span>

    <span style="color:#75715e">// Write out size as capacity for behavioural compatibility with clone()
</span><span style="color:#75715e"></span>    s<span style="color:#f92672">.</span><span style="color:#a6e22e">writeInt</span><span style="color:#f92672">(</span>size<span style="color:#f92672">);</span>

    <span style="color:#75715e">// Write out all elements in the proper order.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span> i<span style="color:#f92672">&lt;</span>size<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        s<span style="color:#f92672">.</span><span style="color:#a6e22e">writeObject</span><span style="color:#f92672">(</span>elementData<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>modCount <span style="color:#f92672">!=</span> expectedModCount<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ConcurrentModificationException<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="5-序列化">5. 序列化</h3>
<p>ArrayList 基于数组实现，并且具有动态扩容特性，因此保存元素的数组不一定都会被使用，那么就没必要全部进行序列化。</p>
<p>保存元素的数组 elementData 使用 transient 修饰，该关键字声明数组默认不会被序列化。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">transient</span> Object<span style="color:#f92672">[]</span> elementData<span style="color:#f92672">;</span> <span style="color:#75715e">// non-private to simplify nested class access
</span></code></pre></div><p>ArrayList 实现了 writeObject() 和 readObject() 来控制只序列化数组中有元素填充那部分内容。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">readObject</span><span style="color:#f92672">(</span>java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">ObjectInputStream</span> s<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">throws</span> java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">IOException</span><span style="color:#f92672">,</span> ClassNotFoundException <span style="color:#f92672">{</span>
    elementData <span style="color:#f92672">=</span> EMPTY_ELEMENTDATA<span style="color:#f92672">;</span>

    <span style="color:#75715e">// Read in size, and any hidden stuff
</span><span style="color:#75715e"></span>    s<span style="color:#f92672">.</span><span style="color:#a6e22e">defaultReadObject</span><span style="color:#f92672">();</span>

    <span style="color:#75715e">// Read in capacity
</span><span style="color:#75715e"></span>    s<span style="color:#f92672">.</span><span style="color:#a6e22e">readInt</span><span style="color:#f92672">();</span> <span style="color:#75715e">// ignored
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>size <span style="color:#f92672">&gt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#75715e">// be like clone(), allocate array based upon size not capacity
</span><span style="color:#75715e"></span>        ensureCapacityInternal<span style="color:#f92672">(</span>size<span style="color:#f92672">);</span>

        Object<span style="color:#f92672">[]</span> a <span style="color:#f92672">=</span> elementData<span style="color:#f92672">;</span>
        <span style="color:#75715e">// Read in all elements in the proper order.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span> i<span style="color:#f92672">&lt;</span>size<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
            a<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> s<span style="color:#f92672">.</span><span style="color:#a6e22e">readObject</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">writeObject</span><span style="color:#f92672">(</span>java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">ObjectOutputStream</span> s<span style="color:#f92672">)</span>
    <span style="color:#66d9ef">throws</span> java<span style="color:#f92672">.</span><span style="color:#a6e22e">io</span><span style="color:#f92672">.</span><span style="color:#a6e22e">IOException</span><span style="color:#f92672">{</span>
    <span style="color:#75715e">// Write out element count, and any hidden stuff
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> expectedModCount <span style="color:#f92672">=</span> modCount<span style="color:#f92672">;</span>
    s<span style="color:#f92672">.</span><span style="color:#a6e22e">defaultWriteObject</span><span style="color:#f92672">();</span>

    <span style="color:#75715e">// Write out size as capacity for behavioural compatibility with clone()
</span><span style="color:#75715e"></span>    s<span style="color:#f92672">.</span><span style="color:#a6e22e">writeInt</span><span style="color:#f92672">(</span>size<span style="color:#f92672">);</span>

    <span style="color:#75715e">// Write out all elements in the proper order.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span>0<span style="color:#f92672">;</span> i<span style="color:#f92672">&lt;</span>size<span style="color:#f92672">;</span> i<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        s<span style="color:#f92672">.</span><span style="color:#a6e22e">writeObject</span><span style="color:#f92672">(</span>elementData<span style="color:#f92672">[</span>i<span style="color:#f92672">]);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>modCount <span style="color:#f92672">!=</span> expectedModCount<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ConcurrentModificationException<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>序列化时需要使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。反序列化使用的是 ObjectInputStream 的 readObject() 方法，原理类似。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">ArrayList list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">();</span>
ObjectOutputStream oos <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ObjectOutputStream<span style="color:#f92672">(</span><span style="color:#66d9ef">new</span> FileOutputStream<span style="color:#f92672">(</span>file<span style="color:#f92672">));</span>
oos<span style="color:#f92672">.</span><span style="color:#a6e22e">writeObject</span><span style="color:#f92672">(</span>list<span style="color:#f92672">);</span>
</code></pre></div><h2 id="vector">Vector</h2>
<h3 id="1-同步">1. 同步</h3>
<p>它的实现与 ArrayList 类似，但是使用了 synchronized 进行同步。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>E e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    modCount<span style="color:#f92672">++;</span>
    ensureCapacityHelper<span style="color:#f92672">(</span>elementCount <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>
    elementData<span style="color:#f92672">[</span>elementCount<span style="color:#f92672">++]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">synchronized</span> E <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>index <span style="color:#f92672">&gt;=</span> elementCount<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArrayIndexOutOfBoundsException<span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">return</span> elementData<span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="2-与-arraylist-的比较">2. 与 ArrayList 的比较</h3>
<ul>
<li>Vector 是同步的，因此开销就比 ArrayList 要大，访问速度更慢。最好使用 ArrayList 而不是 Vector，因为同步操作完全可以由程序员自己来控制；</li>
<li>Vector 每次扩容请求其大小的 2 倍空间，而 ArrayList 是 1.5 倍。</li>
</ul>
<h3 id="3-替代方案">3. 替代方案</h3>
<p>可以使用 <code>Collections.synchronizedList();</code> 得到一个线程安全的 ArrayList。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ArrayList<span style="color:#f92672">&lt;&gt;();</span>
List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> synList <span style="color:#f92672">=</span> Collections<span style="color:#f92672">.</span><span style="color:#a6e22e">synchronizedList</span><span style="color:#f92672">(</span>list<span style="color:#f92672">);</span>
</code></pre></div><p>也可以使用 concurrent 并发包下的 CopyOnWriteArrayList 类。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">List<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> list <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> CopyOnWriteArrayList<span style="color:#f92672">&lt;&gt;();</span>
</code></pre></div><h2 id="copyonwritearraylist">CopyOnWriteArrayList</h2>
<h3 id="读写分离">读写分离</h3>
<p>写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。</p>
<p>写操作需要加锁，防止并发写入时导致写入数据丢失。</p>
<p>写操作结束之后需要把原始数组指向新的复制数组。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">add</span><span style="color:#f92672">(</span>E e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">final</span> ReentrantLock lock <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">;</span>
    lock<span style="color:#f92672">.</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span>
    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
        Object<span style="color:#f92672">[]</span> elements <span style="color:#f92672">=</span> getArray<span style="color:#f92672">();</span>
        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> elements<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
        Object<span style="color:#f92672">[]</span> newElements <span style="color:#f92672">=</span> Arrays<span style="color:#f92672">.</span><span style="color:#a6e22e">copyOf</span><span style="color:#f92672">(</span>elements<span style="color:#f92672">,</span> len <span style="color:#f92672">+</span> 1<span style="color:#f92672">);</span>
        newElements<span style="color:#f92672">[</span>len<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
        setArray<span style="color:#f92672">(</span>newElements<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
        lock<span style="color:#f92672">.</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setArray</span><span style="color:#f92672">(</span>Object<span style="color:#f92672">[]</span> a<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    array <span style="color:#f92672">=</span> a<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@SuppressWarnings</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;unchecked&#34;</span><span style="color:#f92672">)</span>
<span style="color:#66d9ef">private</span> E <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>Object<span style="color:#f92672">[]</span> a<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>E<span style="color:#f92672">)</span> a<span style="color:#f92672">[</span>index<span style="color:#f92672">];</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="适用场景">适用场景</h3>
<p>CopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。</p>
<p>但是 CopyOnWriteArrayList 有其缺陷：</p>
<ul>
<li>内存占用：在写操作时需要复制一个新的数组，使得内存占用为原来的两倍左右；</li>
<li>数据不一致：读操作不能读取实时性的数据，因为部分写操作的数据还未同步到读数组中。</li>
</ul>
<p>所以 CopyOnWriteArrayList 不适合内存敏感以及对实时性要求很高的场景。</p>
<h2 id="linkedlist">LinkedList</h2>
<h3 id="1-概览-1">1. 概览</h3>
<p>基于双向链表实现，使用 Node 存储链表节点信息。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Node</span><span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
    E item<span style="color:#f92672">;</span>
    Node<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> next<span style="color:#f92672">;</span>
    Node<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> prev<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>每个链表存储了 first 和 last 指针：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">transient</span> Node<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> first<span style="color:#f92672">;</span>
<span style="color:#66d9ef">transient</span> Node<span style="color:#f92672">&lt;</span>E<span style="color:#f92672">&gt;</span> last<span style="color:#f92672">;</span>
</code></pre></div><h3 id="2-与-arraylist-的比较-1">2. 与 ArrayList 的比较</h3>
<ul>
<li>ArrayList 基于动态数组实现，LinkedList 基于双向链表实现；</li>
<li>ArrayList 支持随机访问，LinkedList 不支持；</li>
<li>LinkedList 在任意位置添加删除元素更快。</li>
</ul>
<h2 id="hashmap">HashMap</h2>
<p>为了便于理解，以下源码分析以 JDK 1.7 为主。</p>
<h3 id="1-存储结构">1. 存储结构</h3>
<p>内部包含了一个 Entry 类型的数组 table。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">transient</span> Entry<span style="color:#f92672">[]</span> table<span style="color:#f92672">;</span>
</code></pre></div><p>Entry 存储着键值对。它包含了四个字段，从 next 字段我们可以看出 Entry 是一个链表。即数组中的每个位置被当成一个桶，一个桶存放一个链表。HashMap 使用拉链法来解决冲突，同一个链表中存放哈希值相同的 Entry。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">implements</span> Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">final</span> K key<span style="color:#f92672">;</span>
    V value<span style="color:#f92672">;</span>
    Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> next<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> hash<span style="color:#f92672">;</span>

    Entry<span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> h<span style="color:#f92672">,</span> K k<span style="color:#f92672">,</span> V v<span style="color:#f92672">,</span> Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        value <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span>
        next <span style="color:#f92672">=</span> n<span style="color:#f92672">;</span>
        key <span style="color:#f92672">=</span> k<span style="color:#f92672">;</span>
        hash <span style="color:#f92672">=</span> h<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> K <span style="color:#a6e22e">getKey</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> key<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">getValue</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> value<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> V <span style="color:#a6e22e">setValue</span><span style="color:#f92672">(</span>V newValue<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        V oldValue <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
        value <span style="color:#f92672">=</span> newValue<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> oldValue<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>Object o<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!(</span>o <span style="color:#66d9ef">instanceof</span> Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">))</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
        Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span> e <span style="color:#f92672">=</span> <span style="color:#f92672">(</span>Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">)</span>o<span style="color:#f92672">;</span>
        Object k1 <span style="color:#f92672">=</span> getKey<span style="color:#f92672">();</span>
        Object k2 <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">getKey</span><span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>k1 <span style="color:#f92672">==</span> k2 <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>k1 <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> k1<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k2<span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
            Object v1 <span style="color:#f92672">=</span> getValue<span style="color:#f92672">();</span>
            Object v2 <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">getValue</span><span style="color:#f92672">();</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>v1 <span style="color:#f92672">==</span> v2 <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>v1 <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> v1<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>v2<span style="color:#f92672">)))</span>
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">(</span>getKey<span style="color:#f92672">())</span> <span style="color:#f92672">^</span> Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">(</span>getValue<span style="color:#f92672">());</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> String <span style="color:#a6e22e">toString</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> getKey<span style="color:#f92672">()</span> <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34;=&#34;</span> <span style="color:#f92672">+</span> getValue<span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="2-拉链法的工作原理">2. 拉链法的工作原理</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">HashMap<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">,</span> String<span style="color:#f92672">&gt;</span> map <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> HashMap<span style="color:#f92672">&lt;&gt;();</span>
map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;K1&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;V1&#34;</span><span style="color:#f92672">);</span>
map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;K2&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;V2&#34;</span><span style="color:#f92672">);</span>
map<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;K3&#34;</span><span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;V3&#34;</span><span style="color:#f92672">);</span>
</code></pre></div><ul>
<li>新建一个 HashMap，默认大小为 16；</li>
<li>插入 &lt;K1,V1&gt; 键值对，先计算 K1 的 hashCode 为 115，使用除留余数法得到所在的桶下标 115%16=3。</li>
<li>插入 &lt;K2,V2&gt; 键值对，先计算 K2 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6。</li>
<li>插入 &lt;K3,V3&gt; 键值对，先计算 K3 的 hashCode 为 118，使用除留余数法得到所在的桶下标 118%16=6，插在 &lt;K2,V2&gt; 前面。</li>
</ul>
<p>应该注意到链表的插入是以头插法方式进行的，例如上面的 &lt;K3,V3&gt; 不是插在 &lt;K2,V2&gt; 后面，而是插入在链表头部。</p>
<p>查找需要分成两步进行：</p>
<ul>
<li>计算键值对所在的桶；</li>
<li>在链表上顺序查找，时间复杂度显然和链表的长度成正比。</li>
</ul>
<h3 id="3-put-操作">3. put 操作</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>table <span style="color:#f92672">==</span> EMPTY_TABLE<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        inflateTable<span style="color:#f92672">(</span>threshold<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">// 键为 null 单独处理
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>key <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> putForNullKey<span style="color:#f92672">(</span>value<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">int</span> hash <span style="color:#f92672">=</span> hash<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
    <span style="color:#75715e">// 确定桶下标
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> indexFor<span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> table<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>
    <span style="color:#75715e">// 先找出是否已经存在键为 key 的键值对，如果存在的话就更新这个键值对的值为 value
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> table<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span> e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        Object k<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span> <span style="color:#f92672">==</span> hash <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">((</span>k <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">)</span> <span style="color:#f92672">==</span> key <span style="color:#f92672">||</span> key<span style="color:#f92672">.</span><span style="color:#a6e22e">equals</span><span style="color:#f92672">(</span>k<span style="color:#f92672">)))</span> <span style="color:#f92672">{</span>
            V oldValue <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
            e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
            e<span style="color:#f92672">.</span><span style="color:#a6e22e">recordAccess</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span> oldValue<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    modCount<span style="color:#f92672">++;</span>
    <span style="color:#75715e">// 插入新键值对
</span><span style="color:#75715e"></span>    addEntry<span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> i<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> V <span style="color:#a6e22e">putForNullKey</span><span style="color:#f92672">(</span>V value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span>Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> table<span style="color:#f92672">[</span>0<span style="color:#f92672">];</span> e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span> e <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            V oldValue <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span><span style="color:#f92672">;</span>
            e<span style="color:#f92672">.</span><span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> value<span style="color:#f92672">;</span>
            e<span style="color:#f92672">.</span><span style="color:#a6e22e">recordAccess</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">return</span> oldValue<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    modCount<span style="color:#f92672">++;</span>
    addEntry<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> 0<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>使用链表的头插法，也就是新的键值对插在链表的头部，而不是链表的尾部。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addEntry</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> bucketIndex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">((</span>size <span style="color:#f92672">&gt;=</span> threshold<span style="color:#f92672">)</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">null</span> <span style="color:#f92672">!=</span> table<span style="color:#f92672">[</span>bucketIndex<span style="color:#f92672">]))</span> <span style="color:#f92672">{</span>
        resize<span style="color:#f92672">(</span>2 <span style="color:#f92672">*</span> table<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>
        hash <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">null</span> <span style="color:#f92672">!=</span> key<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> hash<span style="color:#f92672">(</span>key<span style="color:#f92672">)</span> <span style="color:#f92672">:</span> 0<span style="color:#f92672">;</span>
        bucketIndex <span style="color:#f92672">=</span> indexFor<span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> table<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    createEntry<span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> bucketIndex<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">createEntry</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> bucketIndex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> table<span style="color:#f92672">[</span>bucketIndex<span style="color:#f92672">];</span>
    <span style="color:#75715e">// 头插法，链表头部指向新的键值对
</span><span style="color:#75715e"></span>    table<span style="color:#f92672">[</span>bucketIndex<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Entry<span style="color:#f92672">&lt;&gt;(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> e<span style="color:#f92672">);</span>
    size<span style="color:#f92672">++;</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">Entry<span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> h<span style="color:#f92672">,</span> K k<span style="color:#f92672">,</span> V v<span style="color:#f92672">,</span> Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> n<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    value <span style="color:#f92672">=</span> v<span style="color:#f92672">;</span>
    next <span style="color:#f92672">=</span> n<span style="color:#f92672">;</span>
    key <span style="color:#f92672">=</span> k<span style="color:#f92672">;</span>
    hash <span style="color:#f92672">=</span> h<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="4-确定桶下标">4. 确定桶下标</h3>
<p>很多操作都需要先确定一个键值对所在的桶下标。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">int</span> hash <span style="color:#f92672">=</span> hash<span style="color:#f92672">(</span>key<span style="color:#f92672">);</span>
<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> indexFor<span style="color:#f92672">(</span>hash<span style="color:#f92672">,</span> table<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>
</code></pre></div><p><strong>4.1 计算 hash 值</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hash</span><span style="color:#f92672">(</span>Object k<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> h <span style="color:#f92672">=</span> hashSeed<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>0 <span style="color:#f92672">!=</span> h <span style="color:#f92672">&amp;&amp;</span> k <span style="color:#66d9ef">instanceof</span> String<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> sun<span style="color:#f92672">.</span><span style="color:#a6e22e">misc</span><span style="color:#f92672">.</span><span style="color:#a6e22e">Hashing</span><span style="color:#f92672">.</span><span style="color:#a6e22e">stringHash32</span><span style="color:#f92672">((</span>String<span style="color:#f92672">)</span> k<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    h <span style="color:#f92672">^=</span> k<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">();</span>

    <span style="color:#75715e">// This function ensures that hashCodes that differ only by
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// constant multiples at each bit position have a bounded
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// number of collisions (approximately 8 at default load factor).
</span><span style="color:#75715e"></span>    h <span style="color:#f92672">^=</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 20<span style="color:#f92672">)</span> <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 12<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">return</span> h <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 7<span style="color:#f92672">)</span> <span style="color:#f92672">^</span> <span style="color:#f92672">(</span>h <span style="color:#f92672">&gt;&gt;&gt;</span> 4<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">hashCode</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">(</span>key<span style="color:#f92672">)</span> <span style="color:#f92672">^</span> Objects<span style="color:#f92672">.</span><span style="color:#a6e22e">hashCode</span><span style="color:#f92672">(</span>value<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p><strong>4.2 取模</strong></p>
<p>令 x = 1&laquo;4，即 x 为 2 的 4 次方，它具有以下性质：</p>
<pre tabindex="0"><code>x   : 00010000
x-1 : 00001111
</code></pre><p>令一个数 y 与 x-1 做与运算，可以去除 y 位级表示的第 4 位以上数：</p>
<pre tabindex="0"><code>y       : 10110010
x-1     : 00001111
y&amp;(x-1) : 00000010
</code></pre><p>这个性质和 y 对 x 取模效果是一样的：</p>
<pre tabindex="0"><code>y   : 10110010
x   : 00010000
y%x : 00000010
</code></pre><p>我们知道，位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能。</p>
<p>确定桶下标的最后一步是将 key 的 hash 值对桶个数取模：hash%capacity，如果能保证 capacity 为 2 的 n 次方，那么就可以将这个操作转换为位运算。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">indexFor</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> h<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> length<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> h <span style="color:#f92672">&amp;</span> <span style="color:#f92672">(</span>length<span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="5-扩容-基本原理">5. 扩容-基本原理</h3>
<p>设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N，如果哈希函数满足均匀性的要求，那么每条链表的长度大约为 N/M，因此平均查找次数的复杂度为 O(N/M)。</p>
<p>为了让查找的成本降低，应该尽可能使得 N/M 尽可能小，因此需要保证 M 尽可能大，也就是说 table 要尽可能大。HashMap 采用动态扩容来根据当前的 N 值来调整 M 值，使得空间效率和时间效率都能得到保证。</p>
<p>和扩容相关的参数主要有：capacity、size、threshold 和 load_factor。</p>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:left">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">capacity</td>
<td style="text-align:left">table 的容量大小，默认为 16。需要注意的是 capacity 必须保证为 2 的 n 次方。</td>
</tr>
<tr>
<td style="text-align:center">size</td>
<td style="text-align:left">键值对数量。</td>
</tr>
<tr>
<td style="text-align:center">threshold</td>
<td style="text-align:left">size 的临界值，当 size 大于等于 threshold 就必须进行扩容操作。</td>
</tr>
<tr>
<td style="text-align:center">loadFactor</td>
<td style="text-align:left">装载因子，table 能够使用的比例，threshold = capacity * loadFactor。</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> DEFAULT_INITIAL_CAPACITY <span style="color:#f92672">=</span> 16<span style="color:#f92672">;</span>

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> MAXIMUM_CAPACITY <span style="color:#f92672">=</span> 1 <span style="color:#f92672">&lt;&lt;</span> 30<span style="color:#f92672">;</span>

<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">float</span> DEFAULT_LOAD_FACTOR <span style="color:#f92672">=</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">75f</span><span style="color:#f92672">;</span>

<span style="color:#66d9ef">transient</span> Entry<span style="color:#f92672">[]</span> table<span style="color:#f92672">;</span>

<span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">int</span> size<span style="color:#f92672">;</span>

<span style="color:#66d9ef">int</span> threshold<span style="color:#f92672">;</span>

<span style="color:#66d9ef">final</span> <span style="color:#66d9ef">float</span> loadFactor<span style="color:#f92672">;</span>

<span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">int</span> modCount<span style="color:#f92672">;</span>
</code></pre></div><p>从下面的添加元素代码中可以看出，当需要扩容时，令 capacity 为原来的两倍。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">addEntry</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> hash<span style="color:#f92672">,</span> K key<span style="color:#f92672">,</span> V value<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> bucketIndex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> table<span style="color:#f92672">[</span>bucketIndex<span style="color:#f92672">];</span>
    table<span style="color:#f92672">[</span>bucketIndex<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Entry<span style="color:#f92672">&lt;&gt;(</span>hash<span style="color:#f92672">,</span> key<span style="color:#f92672">,</span> value<span style="color:#f92672">,</span> e<span style="color:#f92672">);</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>size<span style="color:#f92672">++</span> <span style="color:#f92672">&gt;=</span> threshold<span style="color:#f92672">)</span>
        resize<span style="color:#f92672">(</span>2 <span style="color:#f92672">*</span> table<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>扩容使用 resize() 实现，需要注意的是，扩容操作同样需要把 oldTable 的所有键值对重新插入 newTable 中，因此这一步是很费时的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">resize</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> newCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Entry<span style="color:#f92672">[]</span> oldTable <span style="color:#f92672">=</span> table<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> oldCapacity <span style="color:#f92672">=</span> oldTable<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>oldCapacity <span style="color:#f92672">==</span> MAXIMUM_CAPACITY<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        threshold <span style="color:#f92672">=</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    Entry<span style="color:#f92672">[]</span> newTable <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Entry<span style="color:#f92672">[</span>newCapacity<span style="color:#f92672">];</span>
    transfer<span style="color:#f92672">(</span>newTable<span style="color:#f92672">);</span>
    table <span style="color:#f92672">=</span> newTable<span style="color:#f92672">;</span>
    threshold <span style="color:#f92672">=</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)(</span>newCapacity <span style="color:#f92672">*</span> loadFactor<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">transfer</span><span style="color:#f92672">(</span>Entry<span style="color:#f92672">[]</span> newTable<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    Entry<span style="color:#f92672">[]</span> src <span style="color:#f92672">=</span> table<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> newCapacity <span style="color:#f92672">=</span> newTable<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> src<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> j<span style="color:#f92672">++)</span> <span style="color:#f92672">{</span>
        Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e <span style="color:#f92672">=</span> src<span style="color:#f92672">[</span>j<span style="color:#f92672">];</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            src<span style="color:#f92672">[</span>j<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">do</span> <span style="color:#f92672">{</span>
                Entry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> next <span style="color:#f92672">=</span> e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span><span style="color:#f92672">;</span>
                <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> indexFor<span style="color:#f92672">(</span>e<span style="color:#f92672">.</span><span style="color:#a6e22e">hash</span><span style="color:#f92672">,</span> newCapacity<span style="color:#f92672">);</span>
                e<span style="color:#f92672">.</span><span style="color:#a6e22e">next</span> <span style="color:#f92672">=</span> newTable<span style="color:#f92672">[</span>i<span style="color:#f92672">];</span>
                newTable<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> e<span style="color:#f92672">;</span>
                e <span style="color:#f92672">=</span> next<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>e <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="6-扩容-重新计算桶下标">6. 扩容-重新计算桶下标</h3>
<p>在进行扩容时，需要把键值对重新放到对应的桶上。HashMap 使用了一个特殊的机制，可以降低重新计算桶下标的操作。</p>
<p>假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">capacity     : 00010000
new capacity : 00100000
</code></pre></div><p>对于一个 Key，</p>
<ul>
<li>它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；</li>
<li>如果为 1，那么得到的结果为原来的结果 +16。</li>
</ul>
<h3 id="7-计算数组容量">7. 计算数组容量</h3>
<p>HashMap 构造函数允许用户传入的容量不是 2 的 n 次方，因为它可以自动地将传入的容量转换为 2 的 n 次方。</p>
<p>先考虑如何求一个数的掩码，对于 10010000，它的掩码为 11111111，可以使用以下方法得到：</p>
<pre tabindex="0"><code>mask |= mask &gt;&gt; 1    11011000
mask |= mask &gt;&gt; 2    11111110
mask |= mask &gt;&gt; 4    11111111
</code></pre><p>mask+1 是大于原始数字的最小的 2 的 n 次方。</p>
<pre tabindex="0"><code>num     10010000
mask+1 100000000
</code></pre><p>以下是 HashMap 中计算数组容量的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tableSizeFor</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> cap<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> cap <span style="color:#f92672">-</span> 1<span style="color:#f92672">;</span>
    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 1<span style="color:#f92672">;</span>
    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 2<span style="color:#f92672">;</span>
    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 4<span style="color:#f92672">;</span>
    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 8<span style="color:#f92672">;</span>
    n <span style="color:#f92672">|=</span> n <span style="color:#f92672">&gt;&gt;&gt;</span> 16<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> 1 <span style="color:#f92672">:</span> <span style="color:#f92672">(</span>n <span style="color:#f92672">&gt;=</span> MAXIMUM_CAPACITY<span style="color:#f92672">)</span> <span style="color:#f92672">?</span> MAXIMUM_CAPACITY <span style="color:#f92672">:</span> n <span style="color:#f92672">+</span> 1<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="8-链表转红黑树">8. 链表转红黑树</h3>
<p>从 JDK 1.8 开始，一个桶存储的链表长度大于 8 时会将链表转换为红黑树。</p>
<h3 id="9-与-hashtable-的比较">9. 与 HashTable 的比较</h3>
<ul>
<li>HashTable 使用 synchronized 来进行同步。</li>
<li>HashMap 可以插入键为 null 的 Entry。</li>
<li>HashMap 的迭代器是 fail-fast 迭代器。</li>
<li>HashMap 不能保证随着时间的推移 Map 中的元素次序是不变的。</li>
</ul>
<h2 id="concurrenthashmap">ConcurrentHashMap</h2>
<h3 id="1-存储结构-1">1. 存储结构</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">HashEntry</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> hash<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">final</span> K key<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">volatile</span> V value<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">volatile</span> HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> next<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。</p>
<p>Segment 继承自 ReentrantLock。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Segment</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">extends</span> ReentrantLock <span style="color:#66d9ef">implements</span> Serializable <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> serialVersionUID <span style="color:#f92672">=</span> 2249069246763182397L<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> MAX_SCAN_RETRIES <span style="color:#f92672">=</span>
        Runtime<span style="color:#f92672">.</span><span style="color:#a6e22e">getRuntime</span><span style="color:#f92672">().</span><span style="color:#a6e22e">availableProcessors</span><span style="color:#f92672">()</span> <span style="color:#f92672">&gt;</span> 1 <span style="color:#f92672">?</span> 64 <span style="color:#f92672">:</span> 1<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">volatile</span> HashEntry<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> table<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">int</span> modCount<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">int</span> threshold<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">float</span> loadFactor<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> Segment<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> segments<span style="color:#f92672">;</span>
</code></pre></div><p>默认的并发级别为 16，也就是说默认创建 16 个 Segment。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> DEFAULT_CONCURRENCY_LEVEL <span style="color:#f92672">=</span> 16<span style="color:#f92672">;</span>
</code></pre></div><h3 id="2-size-操作">2. size 操作</h3>
<p>每个 Segment 维护了一个 count 变量来统计该 Segment 中的键值对个数。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * The number of elements. Accessed only either within locks
</span><span style="color:#75715e"> * or among other volatile reads that maintain visibility.
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">transient</span> <span style="color:#66d9ef">int</span> count<span style="color:#f92672">;</span>
</code></pre></div><p>在执行 size 操作时，需要遍历所有 Segment 然后把 count 累计起来。</p>
<p>ConcurrentHashMap 在执行 size 操作时先尝试不加锁，如果连续两次不加锁操作得到的结果一致，那么可以认为这个结果是正确的。</p>
<p>尝试次数使用 RETRIES_BEFORE_LOCK 定义，该值为 2，retries 初始值为 -1，因此尝试次数为 3。</p>
<p>如果尝试的次数超过 3 次，就需要对每个 Segment 加锁。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">
<span style="color:#75715e">/**
</span><span style="color:#75715e"> * Number of unsynchronized retries in size and containsValue
</span><span style="color:#75715e"> * methods before resorting to locking. This is used to avoid
</span><span style="color:#75715e"> * unbounded retries if tables undergo continuous modification
</span><span style="color:#75715e"> * which would make it impossible to obtain an accurate result.
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> RETRIES_BEFORE_LOCK <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span>

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">// Try a few times to get accurate count. On failure due to
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// continuous async changes in table, resort to locking.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">final</span> Segment<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;[]</span> segments <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">segments</span><span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> size<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">boolean</span> overflow<span style="color:#f92672">;</span> <span style="color:#75715e">// true if size overflows 32 bits
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> sum<span style="color:#f92672">;</span>         <span style="color:#75715e">// sum of modCounts
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">long</span> last <span style="color:#f92672">=</span> 0L<span style="color:#f92672">;</span>   <span style="color:#75715e">// previous sum
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> retries <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span> <span style="color:#75715e">// first iteration isn&#39;t retry
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">try</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
            <span style="color:#75715e">// 超过尝试次数，则对每个 Segment 加锁
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>retries<span style="color:#f92672">++</span> <span style="color:#f92672">==</span> RETRIES_BEFORE_LOCK<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> segments<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> <span style="color:#f92672">++</span>j<span style="color:#f92672">)</span>
                    ensureSegment<span style="color:#f92672">(</span>j<span style="color:#f92672">).</span><span style="color:#a6e22e">lock</span><span style="color:#f92672">();</span> <span style="color:#75715e">// force creation
</span><span style="color:#75715e"></span>            <span style="color:#f92672">}</span>
            sum <span style="color:#f92672">=</span> 0L<span style="color:#f92672">;</span>
            size <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
            overflow <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> segments<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> <span style="color:#f92672">++</span>j<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                Segment<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> seg <span style="color:#f92672">=</span> segmentAt<span style="color:#f92672">(</span>segments<span style="color:#f92672">,</span> j<span style="color:#f92672">);</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>seg <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    sum <span style="color:#f92672">+=</span> seg<span style="color:#f92672">.</span><span style="color:#a6e22e">modCount</span><span style="color:#f92672">;</span>
                    <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> seg<span style="color:#f92672">.</span><span style="color:#a6e22e">count</span><span style="color:#f92672">;</span>
                    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>c <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span> <span style="color:#f92672">(</span>size <span style="color:#f92672">+=</span> c<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span>
                        overflow <span style="color:#f92672">=</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
            <span style="color:#f92672">}</span>
            <span style="color:#75715e">// 连续两次得到的结果一致，则认为这个结果是正确的
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>sum <span style="color:#f92672">==</span> last<span style="color:#f92672">)</span>
                <span style="color:#66d9ef">break</span><span style="color:#f92672">;</span>
            last <span style="color:#f92672">=</span> sum<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span> <span style="color:#66d9ef">finally</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>retries <span style="color:#f92672">&gt;</span> RETRIES_BEFORE_LOCK<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">for</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> j <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span> j <span style="color:#f92672">&lt;</span> segments<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span> <span style="color:#f92672">++</span>j<span style="color:#f92672">)</span>
                segmentAt<span style="color:#f92672">(</span>segments<span style="color:#f92672">,</span> j<span style="color:#f92672">).</span><span style="color:#a6e22e">unlock</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">return</span> overflow <span style="color:#f92672">?</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">MAX_VALUE</span> <span style="color:#f92672">:</span> size<span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="3-jdk-18-的改动">3. JDK 1.8 的改动</h3>
<p>JDK 1.7 使用分段锁机制来实现并发更新操作，核心类为 Segment，它继承自重入锁 ReentrantLock，并发度与 Segment 数量相等。</p>
<p>JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。</p>
<p>并且 JDK 1.8 的实现也在链表过长时会转换为红黑树。</p>
<h2 id="linkedhashmap">LinkedHashMap</h2>
<h3 id="存储结构">存储结构</h3>
<p>继承自 HashMap，因此具有和 HashMap 一样的快速查找特性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LinkedHashMap</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">extends</span> HashMap<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">implements</span> Map<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span>
</code></pre></div><p>内部维护了一个双向链表，用来维护插入顺序或者 LRU 顺序。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * The head (eldest) of the doubly linked list.
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">transient</span> LinkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> head<span style="color:#f92672">;</span>

<span style="color:#75715e">/**
</span><span style="color:#75715e"> * The tail (youngest) of the doubly linked list.
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">transient</span> LinkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> tail<span style="color:#f92672">;</span>
</code></pre></div><p>accessOrder 决定了顺序，默认为 false，此时维护的是插入顺序。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> accessOrder<span style="color:#f92672">;</span>
</code></pre></div><p>LinkedHashMap 最重要的是以下用于维护顺序的函数，它们会在 put、get 等方法中调用。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">afterNodeAccess</span><span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#f92672">}</span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">afterNodeInsertion</span><span style="color:#f92672">(</span><span style="color:#66d9ef">boolean</span> evict<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#f92672">}</span>
</code></pre></div><h3 id="afternodeaccess">afterNodeAccess()</h3>
<p>当一个节点被访问时，如果 accessOrder 为 true，则会将该节点移到链表尾部。也就是说指定为 LRU 顺序之后，在每次访问一个节点时，会将这个节点移到链表尾部，保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">afterNodeAccess</span><span style="color:#f92672">(</span>Node<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// move node to last
</span><span style="color:#75715e"></span>    LinkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> last<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>accessOrder <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>last <span style="color:#f92672">=</span> tail<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> e<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        LinkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> p <span style="color:#f92672">=</span>
            <span style="color:#f92672">(</span>LinkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;)</span>e<span style="color:#f92672">,</span> b <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">before</span><span style="color:#f92672">,</span> a <span style="color:#f92672">=</span> p<span style="color:#f92672">.</span><span style="color:#a6e22e">after</span><span style="color:#f92672">;</span>
        p<span style="color:#f92672">.</span><span style="color:#a6e22e">after</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>b <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
            head <span style="color:#f92672">=</span> a<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">else</span>
            b<span style="color:#f92672">.</span><span style="color:#a6e22e">after</span> <span style="color:#f92672">=</span> a<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>a <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
            a<span style="color:#f92672">.</span><span style="color:#a6e22e">before</span> <span style="color:#f92672">=</span> b<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">else</span>
            last <span style="color:#f92672">=</span> b<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>last <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
            head <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            p<span style="color:#f92672">.</span><span style="color:#a6e22e">before</span> <span style="color:#f92672">=</span> last<span style="color:#f92672">;</span>
            last<span style="color:#f92672">.</span><span style="color:#a6e22e">after</span> <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        tail <span style="color:#f92672">=</span> p<span style="color:#f92672">;</span>
        <span style="color:#f92672">++</span>modCount<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="afternodeinsertion">afterNodeInsertion()</h3>
<p>在 put 等操作之后执行，当 removeEldestEntry() 方法返回 true 时会移除最晚的节点，也就是链表首部节点 first。</p>
<p>evict 只有在构建 Map 的时候才为 false，在这里为 true。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">afterNodeInsertion</span><span style="color:#f92672">(</span><span style="color:#66d9ef">boolean</span> evict<span style="color:#f92672">)</span> <span style="color:#f92672">{</span> <span style="color:#75715e">// possibly remove eldest
</span><span style="color:#75715e"></span>    LinkedHashMap<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> first<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>evict <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">(</span>first <span style="color:#f92672">=</span> head<span style="color:#f92672">)</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span> <span style="color:#f92672">&amp;&amp;</span> removeEldestEntry<span style="color:#f92672">(</span>first<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
        K key <span style="color:#f92672">=</span> first<span style="color:#f92672">.</span><span style="color:#a6e22e">key</span><span style="color:#f92672">;</span>
        removeNode<span style="color:#f92672">(</span>hash<span style="color:#f92672">(</span>key<span style="color:#f92672">),</span> key<span style="color:#f92672">,</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>removeEldestEntry() 默认为 false，如果需要让它为 true，需要继承 LinkedHashMap 并且覆盖这个方法的实现，这在实现 LRU 的缓存中特别有用，通过移除最近最久未使用的节点，从而保证缓存空间足够，并且缓存的数据都是热点数据。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">removeEldestEntry</span><span style="color:#f92672">(</span>Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> eldest<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="lru-缓存">LRU 缓存</h3>
<p>以下是使用 LinkedHashMap 实现的一个 LRU 缓存：</p>
<ul>
<li>设定最大缓存空间 MAX_ENTRIES  为 3；</li>
<li>使用 LinkedHashMap 的构造函数将 accessOrder 设置为 true，开启 LRU 顺序；</li>
<li>覆盖 removeEldestEntry() 方法实现，在节点多于 MAX_ENTRIES 就会将最近最久未使用的数据移除。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">LRUCache</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span> V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">extends</span> LinkedHashMap<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span> V<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> MAX_ENTRIES <span style="color:#f92672">=</span> 3<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">removeEldestEntry</span><span style="color:#f92672">(</span>Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span> eldest<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> size<span style="color:#f92672">()</span> <span style="color:#f92672">&gt;</span> MAX_ENTRIES<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    LRUCache<span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">super</span><span style="color:#f92672">(</span>MAX_ENTRIES<span style="color:#f92672">,</span> 0<span style="color:#f92672">.</span><span style="color:#a6e22e">75f</span><span style="color:#f92672">,</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">main</span><span style="color:#f92672">(</span>String<span style="color:#f92672">[]</span> args<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    LRUCache<span style="color:#f92672">&lt;</span>Integer<span style="color:#f92672">,</span> String<span style="color:#f92672">&gt;</span> cache <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> LRUCache<span style="color:#f92672">&lt;&gt;();</span>
    cache<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>1<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;a&#34;</span><span style="color:#f92672">);</span>
    cache<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>2<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;b&#34;</span><span style="color:#f92672">);</span>
    cache<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>3<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;c&#34;</span><span style="color:#f92672">);</span>
    cache<span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>1<span style="color:#f92672">);</span>
    cache<span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>4<span style="color:#f92672">,</span> <span style="color:#e6db74">&#34;d&#34;</span><span style="color:#f92672">);</span>
    System<span style="color:#f92672">.</span><span style="color:#a6e22e">out</span><span style="color:#f92672">.</span><span style="color:#a6e22e">println</span><span style="color:#f92672">(</span>cache<span style="color:#f92672">.</span><span style="color:#a6e22e">keySet</span><span style="color:#f92672">());</span>
<span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-html" data-lang="html">[3, 1, 4]
</code></pre></div><h2 id="weakhashmap">WeakHashMap</h2>
<h3 id="存储结构-1">存储结构</h3>
<p>WeakHashMap 的 Entry 继承自 WeakReference，被 WeakReference 关联的对象在下一次垃圾回收时会被回收。</p>
<p>WeakHashMap 主要用来实现缓存，通过使用 WeakHashMap 来引用缓存对象，由 JVM 对这部分缓存进行回收。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">private</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">extends</span> WeakReference<span style="color:#f92672">&lt;</span>Object<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">implements</span> Map<span style="color:#f92672">.</span><span style="color:#a6e22e">Entry</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span>V<span style="color:#f92672">&gt;</span>
</code></pre></div><h3 id="concurrentcache">ConcurrentCache</h3>
<p>Tomcat 中的 ConcurrentCache 使用了 WeakHashMap 来实现缓存功能。</p>
<p>ConcurrentCache 采取的是分代缓存：</p>
<ul>
<li>经常使用的对象放入 eden 中，eden 使用 ConcurrentHashMap 实现，不用担心会被回收（伊甸园）；</li>
<li>不常用的对象放入 longterm，longterm 使用 WeakHashMap 实现，这些老对象会被垃圾收集器回收。</li>
<li>当调用  get() 方法时，会先从 eden 区获取，如果没有找到的话再到 longterm 获取，当从 longterm 获取到就把对象放入 eden 中，从而保证经常被访问的节点不容易被回收。</li>
<li>当调用 put() 方法时，如果 eden 的大小超过了 size，那么就将 eden 中的所有对象都放入 longterm 中，利用虚拟机回收掉一部分不经常使用的对象。</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ConcurrentCache</span><span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span> V<span style="color:#f92672">&gt;</span> <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> size<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Map<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span> V<span style="color:#f92672">&gt;</span> eden<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> Map<span style="color:#f92672">&lt;</span>K<span style="color:#f92672">,</span> V<span style="color:#f92672">&gt;</span> longterm<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">ConcurrentCache</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> size<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">size</span> <span style="color:#f92672">=</span> size<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">eden</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> ConcurrentHashMap<span style="color:#f92672">&lt;&gt;(</span>size<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">longterm</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> WeakHashMap<span style="color:#f92672">&lt;&gt;(</span>size<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> V <span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>K k<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        V v <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">eden</span><span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>k<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>v <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            v <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">longterm</span><span style="color:#f92672">.</span><span style="color:#a6e22e">get</span><span style="color:#f92672">(</span>k<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>v <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span>
                <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">eden</span><span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>k<span style="color:#f92672">,</span> v<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> v<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>K k<span style="color:#f92672">,</span> V v<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">eden</span><span style="color:#f92672">.</span><span style="color:#a6e22e">size</span><span style="color:#f92672">()</span> <span style="color:#f92672">&gt;=</span> size<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">longterm</span><span style="color:#f92672">.</span><span style="color:#a6e22e">putAll</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">eden</span><span style="color:#f92672">);</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">eden</span><span style="color:#f92672">.</span><span style="color:#a6e22e">clear</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">eden</span><span style="color:#f92672">.</span><span style="color:#a6e22e">put</span><span style="color:#f92672">(</span>k<span style="color:#f92672">,</span> v<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Java 网络编程</title>
            <link>https://oxygenbytes.github.io/posts/2020/10/java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</link>
            <pubDate>Tue, 27 Oct 2020 23:06:27 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2020/10/java-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</guid>
            <description>HTTP请求过程 以www.baidu.com为例子
1.chrome自己的缓存,存留时间大概1min
Notes:chrome://net-internals/#dns中查询 2.chrome搜索操作系统自身的DNS缓存(浏览器没有找到缓存或者缓存已经失效)
3.读取本地的HOST文件
4.浏览器发起一个DNS的一个系统调用
​	- 宽带运营商服务器查看本身的本地缓存
​	- 运营商服务器发起一个迭代DNS解析请求(-&amp;gt;根-&amp;gt;顶级域名地址-&amp;gt;目标)
​	- 运营商服务器把结果返回给操作系统内核,同时缓存起来
​	- 操作系统内核把结果返回浏览器
​	- 最终浏览器拿到了www.baidu.com对应的IP地址
5.建立TCP/IP连接
TCP/IP连接,属于计算机网络的事情,包括运输层的连续ARQ协议,TCP/UDP等,以及IP层路由选择算法(RIP,OSPF),ARP地址解析,再往下CSMA/CD(载波监听,碰撞检测)以及CSMA/CA等&amp;hellip;
6.TCP/IP 链接建立起来之后,浏览器就可以向服务器发送HTTP请求了使用了.比如说,用HTTP的GET方法请求一个根域名的一个域名,协议可以采用HTTP1.0的一个协议(HTTP1.1 是保持连接,与此有所不同,对于同义词请求中,可以同时包含)
7.服务器端接受到了这个请求,根据路径参数,经过后端的一些处理后,把处理后的一个结果的数据返回给浏览器,如果是百度的页面,就会把完整的HTML页面代码返回给浏览器
8.浏览器拿到了完整的HTML页面代码,在解析和渲染这个页面的时候,里面的JS,CSS, 图片静态资源,他们同样也是一个个的HTTP请求,都需要经过上述的主要七个步骤
9.浏览器根据拿到的资源对页面进行渲染,最终把一个完整的页面呈现给了用户.
心跳机制简介 在分布式系统中，分布在不同主机上的节点需要检测其他节点的状态，如服务器节点需要检测从节点是否失效。为了检测对方节点的有效性，每隔固定时间就发送一个固定信息给对方，对方回复一个固定信息，如果长时间没有收到对方的回复，则断开与对方的连接。
发包方既可以是服务端，也可以是客户端，这要看具体实现。因为是每隔固定时间发送一次，类似心跳，所以发送的固定信息称为心跳包。心跳包一般为比较小的包，可根据具体实现。心跳包主要应用于长连接的保持与短线链接。
一般而言，应该客户端主动向服务器发送心跳包，因为服务器向客户端发送心跳包会影响服务器的性能。
TCP和UDP的区别 1.对比     UDP TCP     是否连接 无连接 面向连接   是否可靠 不可靠传输，不使用流量控制和拥塞控制 可靠传输，使用流量控制和拥塞控制   连接对象个数 支持一对一，一对多，多对一和多对多交互通信 只能是一对一通信   传输方式 面向报文 面向字节流   首部开销 首部开销小，仅 8 字节 首部最小 20 字节，最大 60 字节   适用场景 适用于实时应用（IP 电话、视频会议、直播等） 适用于要求可靠传输的应用，例如文件传输    2.</description>
            <content type="html"><![CDATA[<hr>
<h3 id="http请求过程">HTTP请求过程</h3>
<p>以www.baidu.com为例子</p>
<p>1.chrome自己的缓存,存留时间大概1min</p>
<p>Notes:chrome://net-internals/#dns中查询
2.chrome搜索操作系统自身的DNS缓存(浏览器没有找到缓存或者缓存已经失效)</p>
<p>3.读取本地的HOST文件</p>
<p>4.浏览器发起一个DNS的一个系统调用</p>
<p>​	- 宽带运营商服务器查看本身的本地缓存</p>
<p>​	- 运营商服务器发起一个迭代DNS解析请求(-&gt;根-&gt;顶级域名地址-&gt;目标)</p>
<p>​	- 运营商服务器把结果返回给操作系统内核,同时缓存起来</p>
<p>​	- 操作系统内核把结果返回浏览器</p>
<p>​	- 最终浏览器拿到了www.baidu.com对应的IP地址</p>
<p>5.建立TCP/IP连接</p>
<p>TCP/IP连接,属于计算机网络的事情,包括运输层的连续ARQ协议,TCP/UDP等,以及IP层路由选择算法(RIP,OSPF),ARP地址解析,再往下CSMA/CD(载波监听,碰撞检测)以及CSMA/CA等&hellip;</p>
<p>6.TCP/IP 链接建立起来之后,浏览器就可以向服务器发送HTTP请求了使用了.比如说,用HTTP的GET方法请求一个根域名的一个域名,协议可以采用HTTP1.0的一个协议(HTTP1.1 是保持连接,与此有所不同,对于同义词请求中,可以同时包含)</p>
<p>7.服务器端接受到了这个请求,根据路径参数,经过后端的一些处理后,把处理后的一个结果的数据返回给浏览器,如果是百度的页面,就会把完整的HTML页面代码返回给浏览器</p>
<p>8.浏览器拿到了完整的HTML页面代码,在解析和渲染这个页面的时候,里面的JS,CSS, 图片静态资源,他们同样也是一个个的HTTP请求,都需要经过上述的主要七个步骤</p>
<p>9.浏览器根据拿到的资源对页面进行渲染,最终把一个完整的页面呈现给了用户.</p>
<h3 id="心跳机制简介">心跳机制简介</h3>
<p>在分布式系统中，分布在不同主机上的节点需要检测其他节点的状态，如服务器节点需要检测从节点是否失效。为了检测对方节点的有效性，每隔固定时间就发送一个固定信息给对方，对方回复一个固定信息，如果长时间没有收到对方的回复，则断开与对方的连接。</p>
<p>发包方既可以是服务端，也可以是客户端，这要看具体实现。因为是每隔固定时间发送一次，类似心跳，所以发送的固定信息称为心跳包。心跳包一般为比较小的包，可根据具体实现。心跳包主要应用于长连接的保持与短线链接。</p>
<p>一般而言，应该客户端主动向服务器发送心跳包，因为服务器向客户端发送心跳包会影响服务器的性能。</p>
<h3 id="tcp和udp的区别">TCP和UDP的区别</h3>
<h3 id="1对比">1.对比</h3>
<table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否连接</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅 8 字节</td>
<td>首部最小 20 字节，最大 60 字节</td>
</tr>
<tr>
<td>适用场景</td>
<td>适用于实时应用（IP 电话、视频会议、直播等）</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody>
</table>
<h3 id="2总结">2.总结</h3>
<ul>
<li>TCP 向上层提供面向连接的可靠服务 ，UDP 向上层提供无连接不可靠服务。</li>
<li>虽然 UDP 并没有 TCP 传输来的准确，但是也能在很多实时性要求高的地方有所作为</li>
<li>对数据准确性要求高，速度可以相对较慢的，可以选用 TCP</li>
</ul>
<h3 id="流量控制和拥塞控制">流量控制和拥塞控制</h3>
<ul>
<li>拥塞控制
网络拥塞现象是指到达通信子网中某一部分的分组数量过多,使得该部分网络来不及处理,以致引起这部分乃至整个网络性能下降的现象,严重时甚至会导致网络通信业务陷入停顿,即出现死锁现象。拥塞控制是处理网络拥塞现象的一种机制。</li>
<li>流量控制
数据的传送与接收过程当中很可能出现收方来不及接收的情况,这时就需要对发方进行控制,以免数据丢失。</li>
</ul>
<h3 id="多线程如何同步">多线程如何同步</h3>
<ul>
<li>
<p>windows
线程同步有四种方式：临界区、内核对象、互斥量、信号量。</p>
</li>
<li>
<p>Linux
线程同步有最常用的是：互斥锁、条件变量和信号量。</p>
</li>
</ul>
<h3 id="进程间通讯的方式有哪些各有什么优缺点">进程间通讯的方式有哪些，各有什么优缺点</h3>
<p>进程间通信
Linux 进程间通信（IPC）以下以几部分发展而来：
早期UNIX进程间通信、基于System V进程间通信、基于Socket进程间通信和POSIX进程间通信。
UNIX进程间通信方式包括：管道、FIFO、信号。
System V进程间通信方式包括：System V消息队列、System V信号灯、System V共享内存、
POSIX进程间通信包括：posix消息队列、posix信号灯、posix共享内存。
现在linux使用的进程间通信方式：
（1）管道（pipe）和有名管道（FIFO）
（2）信号（signal）
（3）消息队列
（4）共享内存
（5）信号量
（6）套接字（socket)</p>
<h3 id="tcp连接建立的时候3次握手断开连接的4次握手的具体过程">tcp连接建立的时候3次握手，断开连接的4次握手的具体过程</h3>
<p>建立连接采用的3次握手协议，具体是指：
第一次握手是客户端connect连接到server，server accept client的请求之后，向client端发送一个消息，相当于说我都准备好了，你连接上我了，这是第二次握手，第3次握手就是client向server发送的，就是对第二次握手消息的确认。之后client和server就开始通讯了。
断开连接的4次握手,具体如下：
断开连接的一端发送close请求是第一次握手，另外一端接收到断开连接的请求之后需要对close进行确认，发送一个消息，这是第二次握手，发送了确认消息之后还要向对端发送close消息，要关闭对对端的连接，这是第3次握手，而在最初发送断开连接的一端接收到消息之后，进入到一个很重要的状态time_wait状态，这个状态也是面试官经常问道的问题，最后一次握手是最初发送断开连接的一端接收到消息之后。对消息的确认。</p>
<h3 id="epoll与select的区别">epoll与select的区别</h3>
<p>select在一个进程中打开的最大fd是有限制的，由FD_SETSIZE设置，默认值是2048。不过 epoll则没有这个限制，它所支持的fd上限是最大可以打开文件的数目，这个数字一般远大于2048，一般来说内存越大，fd上限越大，1G内存都能达到大约10w左右。</p>
<p>select的轮询机制是系统会去查找每个fd是否数据已准备好，当fd很多的时候，效率当然就直线下降了，epoll采用基于事件的通知方式，一旦某个fd数据就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，而不需要不断的去轮询查找就绪的描述符，这就是epoll高效最本质的原因。</p>
<p>无论是select还是epoll都需要内核把FD消息通知给用户空间，如何避免不必要的内存拷贝就很重要，在这点上，epoll是通过内核于用户空间mmap同一块内存实现的，而select则做了不必要的拷贝</p>
<h3 id="epoll中et和lt的区别与实现原理">epoll中et和lt的区别与实现原理</h3>
<p>LT：水平触发，效率会低于ET触发，尤其在大并发，大流量的情况下。但是LT对代码编写要求比较低，不容易出现问题。LT模式服务编写上的表现是：只要有数据没有被获取，内核就不断通知你，因此不用担心事件丢失的情况。
ET：边缘触发，效率非常高，在并发，大流量的情况下，会比LT少很多epoll的系统调用，因此效率高。但是对编程要求高，需要细致的处理每个请求，否则容易发生丢失事件的情况。</p>
<h3 id="connect方法会阻塞请问有什么方法可以避免其长时间阻塞">connect方法会阻塞，请问有什么方法可以避免其长时间阻塞？</h3>
<p>答:最通常的方法最有效的是加定时器；也可以采用非阻塞模式。</p>
<h3 id="网络中如果客户端突然掉线或者重启服务器端怎么样才能立刻知道">网络中，如果客户端突然掉线或者重启，服务器端怎么样才能立刻知道？</h3>
<p>答:若客户端掉线或者重新启动，服务器端会收到复位信号，每一种tcp/ip得实现不一样，控制机制也不一样。</p>
<h3 id="在子网21027482130种有多少个可用地址分别是什么">在子网210.27.48.21/30种有多少个可用地址？分别是什么？</h3>
<p>简:
30表示的是网络号(network number)是30位，剩下2位中11是广播(broadcast)地址，00是multicast地址，只有01和10可以作为host address。</p>
<p>详:
210.27.48.21/30代表的子网的网络号是30位，即网络号是210.27.48.21 &amp; 255.255.255.251=210.27.48.20，此子网的地址空间是2位，即可以有4个地址：210.27.48.20, 210.27.48.21, 210.27.48.22, 210.27.48.23。第一个地址的主机号(host number/id)是0，而主机号0代表的是multicast地址。最后一个地址的最后两位是11，主机号每一位都为1代表的是广播(broadcast)地址。所以只有中间两个地址可以给host使用。其实那个问题本身不准确，广播或multicast地止也是可以使用的地址，所以回答4也应该正确，当然问的人也可能是想要你回答2。我个人觉得最好的回答是一个广播地址，一个multicast地址，2个unicast地址。</p>
<h3 id="ttl是什么有什么用处通常那些工具会用到它ping-traceroute-ifconfig-netstat">TTL是什么？有什么用处，通常那些工具会用到它？（ping? traceroute? ifconfig? netstat?）</h3>
<p>简:TTL是Time To Live，一般是hup count，每经过一个路由就会被减去一，如果它变成0，包会被丢掉。它的主要目的是防止包在有回路的网络上死转，浪费网络资源。ping和traceroute用到它。</p>
<p>详:TTL是Time To Live，目前是hup count，当包每经过一个路由器它就会被减去一，如果它变成0，路由器就会把包丢掉。IP网络往往带有环(loop)，比如子网A和子网B有两个路由器相连，它就是一个loop。TTL的主要目的是防止包在有回路的网络上死转，因为包的TTL最终后变成0而使得此包从网上消失(此时往往路由器会送一个ICMP包回来，traceroute就是根据这个做的)。ping会送包出去，所以里面有它，但是ping不一定非要不可它。traceroute则是完全因为有它才能成的。ifconfig是用来配置网卡的，netstat -rn 是用来列路由表的，所以都用不着它</p>
<h3 id="路由表示做什么用的在linux环境中怎么来配置一条默认路由">路由表示做什么用的？在linux环境中怎么来配置一条默认路由？</h3>
<p>简:路由表是用来决定如何将包从一个子网传送到另一个子网的，换局话说就是用来决定从一个网卡接收到的包应该送的哪一张网卡上的。在Linux上可以用“route add default gw &lt;默认路由器IP&gt;”来配置一条默认路由。</p>
<p>详:路由表是用来决定如何将包从一个子网传送到另一个子网的，换局话说就是用来决定从一个网卡接收到的包应该送的哪一张网卡上的。路由表的每一行至少有目标网络号、netmask、到这个子网应该使用的网卡。当路由器从一个网卡接收到一个包时，它扫描路由表的每一行，用里面的netmask和包里的目标IP地址做并逻辑运算(&amp;)找出目标网络号，如果此网络号和这一行里的网络号相同就将这条路由保留下来做为备用路由，如果已经有备用路由了就在这两条路由里将网络号最长的留下来，另一条丢掉，如此接着扫描下一行直到结束。如果扫描结束任没有找到任何路由，就用默认路由。确定路由后，直接将包送到对应的网卡上去。在具体的实现中，路由表可能包含更多的信息为选路由算法的细节所用。题外话：路由算法其实效率很差，而且不scalable，解决办法是使用IP交换机，比如MPLS。
在Linux上可以用“route add default gw &lt;默认路由器IP&gt;”来配置一条默认路由。</p>
<h3 id="在网络中有两台主机a和b并通过路由器和其他交换设备连接起来已经确认物理连接正确无误怎么来测试这两台机器是否连通如果不通怎么来判断故障点怎么排除故障">在网络中有两台主机A和B，并通过路由器和其他交换设备连接起来，已经确认物理连接正确无误，怎么来测试这两台机器是否连通？如果不通，怎么来判断故障点？怎么排除故障？</h3>
<p>答:测试这两台机器是否连通：从一台机器ping另一台机器
如果ping不通，用traceroute可以确定是哪个路由器不能连通，然后再找问题是在交换设备/hup/cable等。</p>
<h3 id="网络编程中设计并发服务器使用多进程与多线程-请问有什么区别">网络编程中设计并发服务器，使用多进程与多线程 ，请问有什么区别？</h3>
<p>答案一:
1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。
2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。
两者都可以提高程序的并发度，提高程序运行效率和响应时间。
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。</p>
<p>答案二:
根本区别就一点：用多进程每个进程有自己的地址空间(address space)，线程则共享地址空间。所有其它区别都是由此而来的：
1。速度：线程产生的速度快，线程间的通讯快、切换快等，因为他们在同一个地址空间内。
2。资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。
3。同步问题：线程使用公共变量/内存时需要使用同步机制还是因为他们在同一个地址空间内。
等等</p>
<h3 id="网络编程的一般步骤">网络编程的一般步骤</h3>
<p>对于TCP连接：
1.服务器端1）创建套接字create；2）绑定端口号bind；3）监听连接listen；4）接受连接请求accept，并返回新的套接字；5）用新返回的套接字recv/send；6）关闭套接字。
2.客户端1）创建套接字create; 2）发起建立连接请求connect; 3）发送/接收数据send/recv；4）关闭套接字。
TCP总结：
Server端：create &ndash; bind &ndash; listen&ndash;  accept&ndash;  recv/send&ndash; close
Client端：create&mdash;&mdash;- conncet&mdash;&mdash;send/recv&mdash;&mdash;close.</p>
<p>对于UDP连接：
1.服务器端:1）创建套接字create；2）绑定端口号bind；3）接收/发送消息recvfrom/sendto；4）关闭套接字。
2.客户端:1）创建套接字create；2）发送/接收消息sendto/recvfrom；3）关闭套接字.
UDP总结:
Server端：create&mdash;-bind &mdash;-recvfrom/sendto&mdash;-close
Client端：create&mdash;-  sendto/recvfrom&mdash;-close.</p>
<h3 id="tcp的重发机制是怎么实现的">TCP的重发机制是怎么实现的？</h3>
<p>1.滑动窗口机制，确立收发的边界，能让发送方知道已经发送了多少（已确认）、尚未确认的字节数、尚待发送的字节数；让接收方知道（已经确认收到的字节数）。</p>
<p>2.选择重传，用于对传输出错的序列进行重传。</p>
<h3 id="tcp为什么不是两次连接而是三次握手">TCP为什么不是两次连接？而是三次握手？</h3>
<p>如果A与B两个进程通信，如果仅是两次连接。可能出现的一种情况就是：A发送完请报文以后，由于网络情况不好，出现了网络拥塞，即B延时很长时间后收到报文，即此时A将此报文认定为失效的报文。B收到报文后，会向A发起连接。此时两次握手完毕，B会认为已经建立了连接可以通信，B会一直等到A发送的连接请求，而A对失效的报文回复自然不会处理。依次会陷入B忙等的僵局，造成资源的浪费。</p>
<h3 id="connect方法会阻塞请问有什么方法可以避免其长时间阻塞-1">connect方法会阻塞，请问有什么方法可以避免其长时间阻塞？</h3>
<p>可以考虑采用异步传输机制，同步传输与异步传输的主要区别在于同步传输中，如果调用recvfrom后会一致阻塞运行，从而导致调用线程暂停运行；异步传输机制则不然，会立即返回。</p>
<h3 id="网络编程中设计并发服务器使用多进程与多线程请问有什么区别">网络编程中设计并发服务器，使用多进程与多线程，请问有什么区别？</h3>
<p>答案一:
1，进程：子进程是父进程的复制品。子进程获得父进程数据空间、堆和栈的复制品。
2，线程：相对与进程而言，线程是一个更加接近与执行体的概念，它可以与同进程的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。两者都可以提高程序的并发度，提高程序运行效率和响应时间。
线程和进程在使用上各有优缺点：线程执行开销小，但不利于资源管理和保护；而进程正相反。同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。
答案二:
根本区别就一点：用多进程每个进程有自己的地址空间(address space)，线程则共享地址空间。所有其它区别都是由此而来的：
1。速度：线程产生的速度快，线程间的通讯快、切换快等，因为他们在同一个地址空间内。
2。资源利用率：线程的资源利用率比较好也是因为他们在同一个地址空间内。
3。同步问题：线程使用公共变量/内存时需要使用同步机制还是因为他们在同一个地址空间内。
等等</p>
<h3 id="流量控制和拥塞控制的实现机制">流量控制和拥塞控制的实现机制</h3>
<p>拥塞控制
网络拥塞现象是指到达通信子网中某一部分的分组数量过多,使得该部分网络来不及处理,以致引起这部分乃至整个网络性能下降的现象,严重时甚至会导致网络通信业务陷入停顿,即出现死锁现象。拥塞控制是处理网络拥塞现象的一种机制。
流量控制
数据的传送与接收过程当中很可能出现收方来不及接收的情况,这时就需要对发方进行控制,以免数据丢失。
流量控制机制：
　　流量控制用于防止在端口阻塞的情况下丢帧，这种方法是当发送或接收缓冲区开始溢出时通过将阻塞信号发送回源地址实现的。流量控制可以有效的防止由于网络中瞬间的大量数据对网络带来的冲击，保证用户网络高效而稳定的运行。</p>
<h3 id="多线程如何同步-1">多线程如何同步：</h3>
<p>在这里简单说一下linux多线程同步的方法吧（win上有一定的差别，也有一定的累似）
1：线程数据，每个线程数据创建一个键，它和这个键相关联，在各个线程里，都使用这个键来指代线程数据，但在不同的线程里，这个键代表的数据是不同的，在同一个线程里，它代表同样的数据内容。以此来达到线程安全的目的。
2：互斥锁，就是在各个线程要使用的一些公共数据之前加锁，使用之后释放锁，这个是非常常用的线程安全控制的方法，而频繁的加解锁也对效率有一定的影响。
3：条件变量，而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，它常和互斥锁一起使用。使用时，条件变量被用来阻塞一个线程，当条件不满足时，线程往往解开相应的互斥锁并等待条件发生变化。一旦其它的某个线程改变了条件变量，它将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。这些线程将重新锁定互斥锁并重新测试条件是否满足。一般说来，条件变量被用来进行线程间的同步。
4：信号量，信号量本质上是一个非负的整数计数器，它被用来控制对公共资源的访问。当公共资源增加时，调用函数sem_post（）增加信号量。只有当信号量值大于０时，才能使用公共资源，使用后，函数sem_wait（）减少信号量。函数sem_trywait（）和函数pthread_ mutex_trylock（）起同样的作用，它是函数sem_wait（）的非阻塞版本
另外pthread_join也可以等待一个线程的终止。</p>
<h3 id="进程间通讯的方式有哪些各有什么优缺点-1">进程间通讯的方式有哪些，各有什么优缺点</h3>
<p>进程间通信主要包括管道, 系统IPC(包括消息队列,信号量,共享存储), socket.</p>
<p>管道包括三种:1)普通管道PIPE, 通常有种限制,一是半双工,只能单向传输;二是只能在父子进程间使用. 2)流管道s_pipe: 去除了第一种限制,可以双向传输. 3)命名管道:name_pipe, 去除了第二种限制,可以在许多并不相关的进程之间进行通讯.</p>
<p>系统IPC的三种方式类同,都是使用了内核里的标识符来识别</p>
<p>管道: 优点是所有的UNIX实现都支持, 并且在最后一个访问管道的进程终止后,管道就被完全删除;缺陷是管道只允许单向传输或者用于父子进程之间</p>
<p>系统IPC: 优点是功能强大,能在毫不相关进程之间进行通讯; 缺陷是关键字KEY_T使用了内核标识,占用了内核资源,而且只能被显式删除,而且不能使用SOCKET的一些机制,例如select,epoll等.</p>
<p>socket可以跨网络通讯，其他进程间通讯的方式都不可以，只能是本机进程通讯。</p>
<h3 id="tcp连接建立的时候3次握手的具体过程以及其中的每一步是为什么">tcp连接建立的时候3次握手的具体过程，以及其中的每一步是为什么</h3>
<p>建立连接采用的3次握手协议，具体是指：
第一次握手是客户端connect连接到server，server accept client的请求之后，向client端发送一个消息，相当于说我都准备好了，你连接上我了，这是第二次握手，第3次握手就是client向server发送的，就是对第二次握手消息的确认。之后client和server就开始通讯了。</p>
<h3 id="tcp断开连接的具体过程其中每一步是为什么那么做">tcp断开连接的具体过程，其中每一步是为什么那么做</h3>
<p>断开连接的4次握手,具体如下：
断开连接的一端发送close请求是第一次握手，另外一端接收到断开连接的请求之后需要对close进行确认，发送一个消息，这是第二次握手，发送了确认消息之后还要向对端发送close消息，要关闭对对端的连接，这是第3次握手，而在最初发送断开连接的一端接收到消息之后，进入到一个很重要的状态time_wait状态，这个状态也是面试官经常问道的问题，最后一次握手是最初发送断开连接的一端接收到消息之后。对消息的确认。</p>
<h3 id="socket编程如果client断电了服务器如何快速知道">socket编程，如果client断电了，服务器如何快速知道？？？</h3>
<p>有以下几个技术：
使用定时器（适合有数据流动的情况）； 使用socket选项SO_KEEPALIVE（适合没有数据流动的情况）;</p>
<h3 id="fork一子进程程后-父进程癿全局变量能不能使用">fork()一子进程程后 父进程癿全局变量能不能使用？？？</h3>
<p>fork后子进程将会拥有父进程的几乎一切资源，父子进程的都各自有自己的全局变量。不能通用，不同于线程。对于线程，各个线程共享全局变量。</p>
<h3 id="4g的long型整数中找到一个最大的如何做">4G的long型整数中找到一个最大的，如何做？？？？</h3>
<p>我的想法是要找到最大的肯定要遍历所有的数的，而且不能将数据全部读入内存，可能不足。算法的时间复杂度肯定是O（n）
感觉就是遍历，比较。。。。还能怎么改进呢？？？？
可以改进的地方，就是读入内存的时候，一次多读些。。。。
需 要注意的就是每次从磁盘上尽量多读一些数到内存区，然后处理完之后再读入一批。减少IO次数，自然能够提高效率。而对于类快速排序方法，稍微要麻烦一些： 分批读入，假设是M个数，然后从这M个数中选出n个最大的数缓存起来，直到所有的N个数都分批处理完之后，再将各批次缓存的n个数合并起来再进行一次类快 速排序得到最终的n个最大的数就可以了。在运行过程中，如果缓存数太多，可以不断地将多个缓存合并，保留这些缓存中最大的n个数即可。由于类快速排序的时 间复杂度是O（N），这样分批处理再合并的办法，依然有极大的可能会比堆和败者树更优。当然，在空间上会占用较多的内存。</p>
<p>此题还有个变种，就是寻找K个最大或者最小的数。有以下几种算法：
容量为K的最大堆/最小堆，假设K可以装入内存；
如果N个数可以装入内存，且都小于MAX，那么可以开辟一个MAX大的数组，类似计数排序。。。从数组尾部扫描K个最大的数，头部扫描K个最小的数。</p>
<h3 id="tcp三次握手的过程accept发生在三次握手哪个阶段">tcp三次握手的过程，accept发生在三次握手哪个阶段？</h3>
<p>三次握手：C&mdash;&ndash;&gt;SYN K
S&mdash;&mdash;&gt;ACK K+1 SYN J
C&mdash;&mdash;-&gt;ACK J+1<br>
DONE!
client 的 connect  引起3次握手
server 在socket， bind， listen后，阻塞在accept，三次握手完成后，accept返回一个fd，
因此accept发生在三次握手之后。。。。。。</p>
<h3 id="tcp流udp的数据报之间有什么区别为什么tcp要叫做数据流">Tcp流，udp的数据报，之间有什么区别，为什么TCP要叫做数据流？</h3>
<p>TCP本身是面向连接的协议，S和C之间要使用TCP，必须先建立连接，数据就在该连接上流动，可以是双向的，没有边界。所以叫数据流 ，占系统资源多
UDP不是面向连接的，不存在建立连接，释放连接，每个数据包都是独立的包，有边界，一般不会合并。
TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证</p>
<h3 id="volatile的含义">volatile的含义。</h3>
<p>变量可能在编译器的控制或监控之外改变，告诉编译器不要优化该变量，如被系统时钟更新的变量。</p>
<h3 id="100亿个数求最大的1万个数并说出算法的时间复杂度">100亿个数，求最大的1万个数，并说出算法的时间复杂度。</h3>
<p>用小根堆来实现。注意是小根堆，
读入1万个数，然后做
时间复杂度是O（NlogK）</p>
<h3 id="设计一个洗牌的算法并说出算法的时间复杂度">设计一个洗牌的算法，并说出算法的时间复杂度。</h3>
<p>第一种： for i:=1 to n do swap(a[i], a[random(1,n)]);  // 凑合，但不是真正随机
第二种： for i:=1 to n do swap(a[i], a[random(i,n)]);   // 真正的随机算法
其中，random(a,b)函数用于返回一个从a到b（包括a和b）的随机整数。
至于怎么证明上两个算法，没想好。
算法复杂度是O（n。。。），要研究下random的实现。</p>
<h3 id="流量控制与拥塞控制的区别节点计算机怎样感知网络拥塞了">流量控制与拥塞控制的区别，节点计算机怎样感知网络拥塞了？</h3>
<p>拥塞控制是把整体看成一个处理对象的，流量控制是对单个的节点。
感知的手段应该不少，比如在TCP协议里，TCP报文的重传本身就可以作为拥塞的依据。依据这样的原理， 应该可以设计出很多手段。</p>
<h3 id="tcp通讯中select到读事件但是读到的数据量是0为什么如何解决">TCP通讯中，select到读事件，但是读到的数据量是0，为什么，如何解决?</h3>
<p>select 返回0代表超时。select出错返回-1。</p>
<p>select到读事件，但是读到的数据量为0，说明对方已经关闭了socket的读端。本端关闭读即可。</p>
<p>当select出错时，会将接口置为可读又可写。这时就要通过判断select的返回值为-1来区分。</p>
]]></content>
        </item>
        
        <item>
            <title>二叉树的遍历算法</title>
            <link>https://oxygenbytes.github.io/posts/2020/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/</link>
            <pubDate>Sun, 30 Aug 2020 21:49:10 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2020/08/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95/</guid>
            <description>二叉树的遍历算法是理解递归和搜索的关键算法，也可以用来思考程序状态问题和分类讨论思想。
二叉树的先序遍历 非递归版本
class Solution { public: vector&amp;lt;int&amp;gt; preorderTraversal(TreeNode* root) { if(!root) return {}; vector&amp;lt;int&amp;gt; result; stack&amp;lt;TreeNode*&amp;gt; s; TreeNode* ptr = root; while(!s.empty() || ptr){ if(ptr){ result.push_back(ptr-&amp;gt;val); s.push(ptr); ptr = ptr-&amp;gt;left; }else{ ptr = s.top();s.pop(); ptr = ptr-&amp;gt;right; } } return result; } }; 递归版本
class Solution { public: vector&amp;lt;int&amp;gt; postorderTraversal(TreeNode* root) { vector&amp;lt;int&amp;gt; result; dfs(root, result); return result; } private: void dfs(TreeNode* root, vector&amp;lt;int&amp;gt;&amp;amp; res){ if(root){ dfs(root-&amp;gt;left,res); dfs(root-&amp;gt;right, res); res.</description>
            <content type="html"><![CDATA[<p>二叉树的遍历算法是理解递归和搜索的关键算法，也可以用来思考程序状态问题和分类讨论思想。</p>
<h3 id="二叉树的先序遍历">二叉树的先序遍历</h3>
<p>非递归版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> preorderTraversal(TreeNode<span style="color:#f92672">*</span> root) {
        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>root) <span style="color:#66d9ef">return</span> {};
        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
        stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> s;
        TreeNode<span style="color:#f92672">*</span> ptr <span style="color:#f92672">=</span> root;
        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>s.empty() <span style="color:#f92672">||</span> ptr){
            <span style="color:#66d9ef">if</span>(ptr){
                result.push_back(ptr<span style="color:#f92672">-&gt;</span>val);
                s.push(ptr);
                ptr <span style="color:#f92672">=</span> ptr<span style="color:#f92672">-&gt;</span>left;
            }<span style="color:#66d9ef">else</span>{
                ptr <span style="color:#f92672">=</span> s.top();s.pop();
                ptr <span style="color:#f92672">=</span> ptr<span style="color:#f92672">-&gt;</span>right;
            }
        }
        <span style="color:#66d9ef">return</span> result;
    }
};
</code></pre></div><p>递归版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> postorderTraversal(TreeNode<span style="color:#f92672">*</span> root) {
        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
        dfs(root, result);
        <span style="color:#66d9ef">return</span> result;
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> dfs(TreeNode<span style="color:#f92672">*</span> root, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> res){
        <span style="color:#66d9ef">if</span>(root){
            dfs(root<span style="color:#f92672">-&gt;</span>left,res);
            dfs(root<span style="color:#f92672">-&gt;</span>right, res);
            res.push_back(root<span style="color:#f92672">-&gt;</span>val);
        }
    }
};
</code></pre></div><h3 id="中序遍历">中序遍历</h3>
<p>非递归版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> inorderTraversal(TreeNode<span style="color:#f92672">*</span> root) {
        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>root) <span style="color:#66d9ef">return</span> result;
        stack<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*&gt;</span> s;
        TreeNode<span style="color:#f92672">*</span> ptr <span style="color:#f92672">=</span> root;
        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>s.empty() <span style="color:#f92672">||</span> ptr){ <span style="color:#75715e">// 指针不空或者stack不空
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span>(ptr){ <span style="color:#75715e">// 1. 指针不空，stack空 2.指针不空，stack不空
</span><span style="color:#75715e"></span>                s.push(ptr);
                ptr <span style="color:#f92672">=</span> ptr <span style="color:#f92672">-&gt;</span> left;
            }<span style="color:#66d9ef">else</span>{ <span style="color:#75715e">// 3. 指针空，stack不空  4. 指针空，stack空（这种情况进不了while循环的）
</span><span style="color:#75715e"></span>                ptr <span style="color:#f92672">=</span> s.top();s.pop();
                result.push_back(ptr<span style="color:#f92672">-&gt;</span>val);
                ptr <span style="color:#f92672">=</span> ptr<span style="color:#f92672">-&gt;</span>right;
            }
        }
        <span style="color:#66d9ef">return</span> result;
    }
};
</code></pre></div><p>递归版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> inorderTraversal(TreeNode<span style="color:#f92672">*</span> root) {
        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
        dfs(root, result);
        <span style="color:#66d9ef">return</span> result;
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> dfs(TreeNode<span style="color:#f92672">*</span> root, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> res){
        <span style="color:#66d9ef">if</span>(root){
            dfs(root<span style="color:#f92672">-&gt;</span>left,res);
            res.push_back(root<span style="color:#f92672">-&gt;</span>val);
            dfs(root<span style="color:#f92672">-&gt;</span>right, res);
        }
    }
};
</code></pre></div><h3 id="后序遍历">后序遍历</h3>
<p>非递归版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> postorderTraversal(TreeNode<span style="color:#f92672">*</span> root) {
        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>root) <span style="color:#66d9ef">return</span> {};
        stack<span style="color:#f92672">&lt;</span>pair<span style="color:#f92672">&lt;</span>TreeNode<span style="color:#f92672">*</span>,<span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;&gt;</span> s;
        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
        TreeNode<span style="color:#f92672">*</span> ptr <span style="color:#f92672">=</span> root;
        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>s.empty() <span style="color:#f92672">||</span> ptr){
            <span style="color:#66d9ef">if</span>(ptr){
                s.push(make_pair(ptr,false));
                ptr <span style="color:#f92672">=</span> ptr<span style="color:#f92672">-&gt;</span>left;
            }<span style="color:#66d9ef">else</span>{
                <span style="color:#66d9ef">auto</span> now <span style="color:#f92672">=</span> s.top();s.pop();
                <span style="color:#66d9ef">if</span>(now.second <span style="color:#f92672">==</span> false){
                    s.push(make_pair(now.first,true));
                    ptr <span style="color:#f92672">=</span> now.first<span style="color:#f92672">-&gt;</span>right;
                }<span style="color:#66d9ef">else</span>{
                    result.push_back(now.first<span style="color:#f92672">-&gt;</span>val);
                }
            }
        }
        <span style="color:#66d9ef">return</span> result;
    }
};
</code></pre></div><p>递归版本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> postorderTraversal(TreeNode<span style="color:#f92672">*</span> root) {
        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> result;
        dfs(root, result);
        <span style="color:#66d9ef">return</span> result;
    }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span> dfs(TreeNode<span style="color:#f92672">*</span> root, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> res){
        <span style="color:#66d9ef">if</span>(root){
            dfs(root<span style="color:#f92672">-&gt;</span>left,res);
            dfs(root<span style="color:#f92672">-&gt;</span>right, res);
            res.push_back(root<span style="color:#f92672">-&gt;</span>val);
        }
    }
};
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>Termux 使用指南</title>
            <link>https://oxygenbytes.github.io/posts/2020/08/termux-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
            <pubDate>Wed, 12 Aug 2020 09:30:07 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2020/08/termux-%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
            <description>安装 Termux 是一款基于 Android 平台的开源 Linux 终端模拟器，使用 pkg(apt) 进行软件包的管理。可以在 Google play 安装最新版的 termux 和 termux-API 。Termux 支持缩放手势来调整字体大小，长按屏幕可以调出菜单选项，可以实现粘贴复制等操作。侧边栏可以新建、切换、重命名会话session。
安装常用的基本软件
pkg install termux-api vim -y 配置ssh 首先PC端需要安装 openssh-client, termux中安装 openssh。
# PC端 sudo apt-get install openssh-client # termux中 pkg install openssh # PC端生成ssh秘钥 ssh-keygen # Termux开启ssh服务 sshd # 将PC端 ~/.ssh/ 目录下的id_rsa.pub中的内容写入termux中的 ~/.ssh/authorized_keys文件内 # 注意： PC端 ~/.ssh/know_hosts文件中不应有与termux的ssh进程重复的条目 # 一旦出现 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! 的提示，删除PC端 ~/.ssh/know_hosts文件中的对应条目即可 新版本的 termux 已经支持 ssh 的密码登录，可以使用 passwd 初始化 ssh 密码</description>
            <content type="html"><![CDATA[<h3 id="安装">安装</h3>
<p><a href="https://termux.com/">Termux</a> 是一款基于 Android 平台的开源 Linux 终端模拟器，使用 pkg(apt) 进行软件包的管理。可以在 <code>Google play</code> 安装最新版的 <code>termux</code> 和 <code>termux-API</code> 。<code>Termux</code> 支持缩放手势来调整字体大小，长按屏幕可以调出菜单选项，可以实现粘贴复制等操作。侧边栏可以新建、切换、重命名会话session。</p>
<p>安装常用的基本软件</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">pkg install termux-api vim -y
</code></pre></div><h3 id="配置ssh">配置ssh</h3>
<p>首先PC端需要安装 <code>openssh-client</code>, <code>termux</code>中安装 <code>openssh</code>。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># PC端</span>
sudo apt-get install openssh-client
<span style="color:#75715e"># termux中</span>
pkg install openssh 
<span style="color:#75715e"># PC端生成ssh秘钥</span>
ssh-keygen
<span style="color:#75715e"># Termux开启ssh服务</span>
sshd
<span style="color:#75715e"># 将PC端 ~/.ssh/ 目录下的id_rsa.pub中的内容写入termux中的 ~/.ssh/authorized_keys文件内</span>
<span style="color:#75715e"># 注意： PC端 ~/.ssh/know_hosts文件中不应有与termux的ssh进程重复的条目</span>
<span style="color:#75715e"># 一旦出现 WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! 的提示，删除PC端 ~/.ssh/know_hosts文件中的对应条目即可</span>
</code></pre></div><p>新版本的 <code>termux</code> 已经支持 <code>ssh</code> 的密码登录，可以使用 <code>passwd</code> 初始化 <code>ssh</code> 密码</p>
<h3 id="定制常用按键">定制常用按键</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 新建并编辑配置文件</span>
vim ~/.termux/termux.properties
</code></pre></div><p>内容为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">extra-keys <span style="color:#f92672">=</span> <span style="color:#f92672">[</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#39;ESC&#39;</span>,<span style="color:#e6db74">&#39;|&#39;</span>,<span style="color:#e6db74">&#39;CTRL&#39;</span>,<span style="color:#e6db74">&#39;HOME&#39;</span>,<span style="color:#e6db74">&#39;UP&#39;</span>,<span style="color:#e6db74">&#39;END&#39;</span>,<span style="color:#e6db74">&#39;~&#39;</span>,<span style="color:#e6db74">&#39;DEL&#39;</span><span style="color:#f92672">]</span>, <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span> <span style="color:#f92672">[</span><span style="color:#e6db74">&#39;TAB&#39;</span>,<span style="color:#e6db74">&#39;/&#39;</span>,<span style="color:#e6db74">&#39;&gt;&#39;</span>,<span style="color:#e6db74">&#39;LEFT&#39;</span>,<span style="color:#e6db74">&#39;DOWN&#39;</span>,<span style="color:#e6db74">&#39;RIGHT&#39;</span>,<span style="color:#e6db74">&#39;BACKSLASH&#39;</span>,<span style="color:#e6db74">&#39;BKSP&#39;</span><span style="color:#f92672">]</span> <span style="color:#ae81ff">\
</span><span style="color:#ae81ff"></span><span style="color:#f92672">]</span>
<span style="color:#75715e"># 重启键盘就会出现，上述键位出现次数高，常用，建议添加</span>
</code></pre></div><h3 id="配置剪切板共享">配置剪切板共享</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># clipboard</span>
alias cg<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;termux-clipboard-get&#39;</span>
alias cs<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;termux-clipboard-set&#39;</span>
​<span style="color:#e6db74">```</span>
<span style="color:#75715e">### 配置zsh&amp;&amp;oh-my-zsh</span>

<span style="color:#e6db74">```</span>bash
pkg install zsh
sh -c <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>curl -fsSL https://github.com/Cabbagec/termux-ohmyzsh/raw/master/install.sh<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>  
vim .zshrc <span style="color:#75715e"># 修改主题为random</span>
</code></pre></div><h3 id="配置chfs">配置Chfs</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 电脑上下载chfs-linux-arm64-2.0.zip</span>
<span style="color:#75715e"># 网址： https://iscute.cn/tar/chfs/2.0/chfs-linux-arm64-2.0.zip</span>
<span style="color:#75715e"># 使用scp命令将下载的电脑上的文件传输给termux，在PC端执行：</span>
scp -P <span style="color:#ae81ff">8022</span> chfs-linux-arm64-2.0.zip u0_a165@192.168.43.1:~/.chfs
unzip chfs-linux-arm64-2.0.zip
</code></pre></div><p>编写脚本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e">#!/data/data/com.termux/files/usr/bin/bash
</span><span style="color:#75715e"></span><span style="color:#75715e"># 参考自：https://github.com/zsxwz/zstermux/blob/master/chfs.sh</span>
<span style="color:#75715e"># 记得授予termux访问文件的权限</span>
<span style="color:#66d9ef">if</span> ! <span style="color:#f92672">[</span> -x <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>command -v screen<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>  <span style="color:#f92672">]</span> ; <span style="color:#66d9ef">then</span>
apt install screen -y
<span style="color:#66d9ef">fi</span>

<span style="color:#66d9ef">if</span> <span style="color:#f92672">[</span> ! -x <span style="color:#e6db74">&#34;</span><span style="color:#66d9ef">$(</span>command -v chfs<span style="color:#66d9ef">)</span><span style="color:#e6db74">&#34;</span>  <span style="color:#f92672">]</span> ; <span style="color:#66d9ef">then</span>
    cd ~/.chfs
    chmod +x chfs
    mv chfs /data/data/com.termux/files/usr/bin/chfs
    read -p <span style="color:#e6db74">&#34;请输入用户名:&#34;</span> name
    echo <span style="color:#e6db74">&#34;</span>$name<span style="color:#e6db74">&#34;</span> &gt; name
    var1<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>cat name<span style="color:#66d9ef">)</span>
    read -p <span style="color:#e6db74">&#34;请输入密码:&#34;</span> password
    echo <span style="color:#e6db74">&#34;</span>$password<span style="color:#e6db74">&#34;</span> |base64 -i &gt; password
    var2<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>base64 -d password<span style="color:#66d9ef">)</span>
    screen -dmS chfs chfs --port<span style="color:#f92672">=</span><span style="color:#ae81ff">1234</span> --path<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/sdcard&#34;</span> --rule<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;::r|</span>$var1<span style="color:#e6db74">:</span>$var2<span style="color:#e6db74">:rwd&#34;</span>
    echo -e <span style="color:#e6db74">&#34;\033[31m请用chrome浏览器打开，127.0.0.1:1234\033[0m&#34;</span>dd
	echo <span style="color:#e6db74">&#34;&#34;</span>
    am start -a android.intent.action.VIEW -d http://127.0.0.1:1234
    
<span style="color:#66d9ef">else</span>
    cd ~/.chfs
    var1<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>cat name<span style="color:#66d9ef">)</span>
    var2<span style="color:#f92672">=</span><span style="color:#66d9ef">$(</span>base64 -d password<span style="color:#66d9ef">)</span>
    screen -dmS chfs chfs --port<span style="color:#f92672">=</span><span style="color:#ae81ff">1234</span> --path<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;/sdcard&#34;</span> --rule<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;::r|</span>$var1<span style="color:#e6db74">:</span>$var2<span style="color:#e6db74">:rwd&#34;</span>
<span style="color:#66d9ef">fi</span>
exit
</code></pre></div><p>修改脚本权限并执行脚本</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">chmod +x chfs.sh
./chfs.sh
bash chfs.sh
<span style="color:#75715e"># 浏览器打开 http://127.0.0.1:1234 查看是否配置成功</span>
<span style="color:#75715e"># 当打开chfs服务后，就可以在局域网中利用：&lt;ip&gt;:&lt;port&gt; ip=手机ip，port=1234 访问手机文件了</span>
</code></pre></div><h3 id="利用scp进行局域网文件传输">利用SCP进行局域网文件传输</h3>
<ol>
<li>修改 <code>~/.zshrc</code></li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">alias tomix2<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;~/.ssh/tomix2.sh&#34;</span>
</code></pre></div><ol start="2">
<li><code>~/.ssh/tomix2.sh</code> 的脚本内容为</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># 其中8022是termux默认的ssh端口</span>
<span style="color:#75715e"># u0_a165是安装termux时安卓系统分配的虚拟用户</span>
<span style="color:#75715e"># 192.168.43.1是安卓手机的局域网ip</span>
scp -P <span style="color:#ae81ff">8022</span> $1 u0_a165@192.168.43.1:/sdcard/
</code></pre></div><h3 id="termux备份httpswikitermuxcomwikibacking_up_termux"><a href="https://wiki.termux.com/wiki/Backing_up_Termux">termux备份</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Backing up</span>
<span style="color:#75715e"># In this example, a backup of both home and sysroot will be shown. The resulting archive will be stored on your shared storage (/sdcard) and compressed with gzip.</span>
<span style="color:#75715e"># 1. Ensure that storage permission is granted:</span>
termux-setup-storage
<span style="color:#75715e"># 2. Go to Termux base directory:</span>

cd /data/data/com.termux/files
<span style="color:#75715e"># 3. Backing up files:</span>
tar -zcvf /sdcard/termux-backup.tar.gz home usr
<span style="color:#75715e"># Backup should be finished without any error. </span>
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># Restoring</span>
<span style="color:#75715e">#Here will be assumed that you have backed up both home and usr directory into same archive. Please note that all files would be overwritten during the process.</span>
<span style="color:#75715e"># 1. Ensure that storage permission is granted:</span>
termux-setup-storage

<span style="color:#75715e"># 2. Go to Termux base directory:</span>
cd /data/data/com.termux/files

<span style="color:#75715e"># 3. Extract home and usr with overwriting everything and deleting stale files:</span>

tar -zxf /sdcard/termux-backup.tar.gz --recursive-unlink --preserve-permissions

<span style="color:#75715e"># Now close Termux with the &#34;exit&#34; button from notification and open it again.</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>线性代数的本质</title>
            <link>https://oxygenbytes.github.io/posts/2020/08/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/</link>
            <pubDate>Thu, 06 Aug 2020 19:42:44 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2020/08/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8/</guid>
            <description>1p 什么是向量？  定义坐标系 物理系，计算机系，数学系对向量的不同认识 向量可以是任何东西，只要保证两个向量相加以及数字与向量想成是有意义的即可。 可以将向量看作一种运动。从运动的角度定义向量加法和数乘运算。标量对向量而言，作用就是缩放。  2p 向量的线性组合，张成的空间和基   作为标量的向量坐标
  将向量的每个坐标看作一个标量，考虑它们如何拉伸或压缩一个向量
  引入单位向量作为坐标系的基，基向量是坐标缩放的对象
  定义向量的线性组合：两个数乘向量的和被称为这两个向量的线性组合
  定义向量张成的空间(span)：所有可以表示为给定向量线性组合的向量的集合成为给定向量张成的空间
  定义线性相关和线性无关：N个向量可以张成的空间为N维空间，则这N个向量是线性无关的，否则是线性相关的。
  定义空间的一组基：张成该空间的一个线性无关向量的集合。
  3p 矩阵与空间线性变换  “变换”实际上就是函数，它接受输入内容并输出对应结果，而在线性变换中输入的是向量，输出的也是一个向量，这中间的这个函数就是变换矩阵。 线性变换的几何约束：线性变换必须满足两点要求，首先变换前后直线依旧是直线，其次 原点保持不变 。值得注意的是不仅仅要考虑水平与竖直的直线变换前后是否依旧是直线，还要考虑对角线的不是水平的线。线性变换应该是一种 保持网格平行且等距分布 的变换。 记录两个基向量i帽和j帽变换后的位置，其他向量都会随之而动；只要记录了变换后的i帽和j帽，我们就可以推断出任意向量在变换之后的位置，完全不必观察变换本身是什么样。 矩阵：矩阵只是一个记号，它含有描述一个线性变换的信息。向量的列可以理解为变换后对应原基向量的一组基。  4p 矩阵乘法与线性复合变换  两个矩阵相乘有着几何意义，也就是两个线性变换相继作用。乘积需要从右向左读，首先应用右侧矩阵所描述的变换，然后再应用左侧矩阵所描述的变换，它起源于函数的记号，每次将两个函数复合时，你总是要从右向左读。  5p 三维空间中的线性变换  三维空间的概念可以由二维推广得到。 三维线性变换由基向量的去向完全决定，只考虑跟踪这些基向量的话会更容易观察这些线性变换。  6p 行列式  矩阵的行列式可以衡量矩阵对应的线性变换对空间的缩放程度。 对二维空间来说，线性变换改变面积的比例，被称为这个变换的行列式。 只需要检验一个矩阵的行列式是否为0，我们就能了解这个矩阵所代表的变换是否将空间压缩到更小的维度上。 完整概念下的行列式是允许出现负值的，这和定向的概念有关，当空间定向改变的情况发生时，行列式为负，但是行列式的绝对值依然表示区域面积的缩放比例。行列式在三维空间中的意义仍然是变换前后的缩放比例，但在三维空间中表现为体积的缩放。  7p 逆矩阵，列空间，零空间  总的来说， $A^{-1}$ 是满足以下性质的唯一变换，首先应用 $A$ 代表的变换，再应用 $A^{-1}$ 代表的变换，你会回到原始状态。两个变换相继作用在代数上体现为矩阵乘法。 $A^{-1}A$ 等于一个“什么都不做”的矩阵。 如果变换后的向量落在某个二维平面上，所以说 “秩”代表着变换后空间的维数 ，意味着基向量仍旧能张成整个二维空间。 不管是一条直线、一个平面还是三维空间等，所有可能的变换结果的集合，被称为矩阵的“列空间”。换句话说，列空间就是矩阵的列所张成的空间。所以更精确的秩的定义是列空间的维数。 对一个满秩变换来说，唯一能在变换后落在原点的就是零向量自身，如果一个三维线性变换将空间压缩到一条直线上，那么就有一整个平面上的向量在变换后落在原点，变换后落在原点的向量的集合，被称为矩阵的“零空间”或“核”。 每个线性方程组都有一个线性变换与之联系。矩阵 $A$ 代表一种线性变换。 ，所以求解 $Ax=v$ 意味着我们去寻找一个向量 $x$，使得它在变换后与 $v$ 重合。 每个方程组都有一个线性变换与之联系，当逆变换存在时，你就能用这个逆变换求解方程组，否则，列空间的概念让我们清楚什么时候存在解，零空间的概念有助于我们理解所有可能的解的集合是什么样的。  8p 非方阵  一个 $3×2$ 矩阵，这个矩阵的列空间，是三维空间中一个过原点的二维平面，但是这个矩阵仍然是满秩的，因为列空间的维数与输入空间的维数相等。它的几何意义是将二维空间映射到三维空间上，矩阵有两列表明输入空间有两个基向量，有三行表明每一个基向量在变换后都用三个独立的坐标来描述。可以理解为将二维坐标系扩充为三维。  9p 点积与对偶性  多维空间到一维空间（数轴）的线性变换，有不少函数能够接收二维向量并输出一个数。 两个向量点乘，就是将其中一个向量转化为线性变换。 向量仿佛是一个特定变换的概念性记号。对一般人类来说，想象空间中的向量比想象这个空间移动到数轴上更加容易。  10p 叉积  假如你有两个向量 $\vec v$ 和 $\vec w$ ，考虑它们所张成的平行四边形， $\vec v$ 和 $\vec w$ 的叉积，就是这个平行四边形的面积。我们还要考虑定向问题，大致来讲，如果 $\vec v$ 在 $\vec w$ 的右侧，那么$\vec v$ 叉乘 $\vec w$ 为正，并且值等于平行四边形的面积。但是如果 $\vec v$ 在 $\vec w$ 的左侧那么 $\vec v$ 叉乘 $\vec w$ 为负，即平行四边形面积的相反数。注意，这就是说顺序会对叉积有影响。 真正的叉积是通过两个三维向量生成一个新的三维向量。这个向量的长度就是平行四边形的面积，而这个向量的方向与平行四边形（所在的面）垂直。 对于给定的向量 $\vec v$ 和 $\vec w$ ,其对应着唯一一个叉积向量 $\vec x$ 。对于任意的向量 $\vec u$ 而言，$\vec u,\vec v,\vec w$ 三个向量组成的六面体的体积（行列式值）等于$\vec x$ 与 $\vec u$ 点积的结果。这也就是为什么可以使用行列式来记忆叉积。而使用 $\vec i,\vec j,\vec k$ 的单位向量的作用仅仅是根据 $\vec u$ 向量的坐标值将 $\vec u $ 向量化。  11p 基变换  空间的原点重合，但是基向量不同。所有基向量在其自身的坐标系中都是单位向量。 现在给定两个坐标系，一个是我们的坐标系，另外一个是詹妮佛的坐标系。在不同坐标系之间进行转化的时候可以使用矩阵向量乘法。转移矩阵 用我们的语言表达詹妮佛的基向量，称为基变换。反之，转移矩阵的逆，表示用詹妮佛的基底表示我们的基底，可以实现从詹妮佛的矩阵向我们矩阵的变换。 一个矩阵的列为詹妮弗的基向量，这个矩阵可以看作一个线性变换，它将我们的基向量i帽和j帽，也就是我们眼中的 $(1, 0)$ 和 $(0, 1)$ ，变换为用詹妮弗的基向量描述的我们的 $(1, 0)$ 和 $(0, 1)$ 。 理解 $A^{-1}MA$ 的意义。 $M$ 是在我们的空间描述某一特定的线性变换。$A$ 是从詹妮佛坐标系向我们坐标系进行基变换的转移矩阵，$A^{-1}$ 是从我们坐标系向詹妮佛坐标系进行基变换的转移矩阵。最终 $A^{-1}MA$ 就是用詹妮佛坐标系描述的同样意义的线性变换。 $A^{-1}MA\vec x = \vec b$ 中对于詹妮佛空间的向量 $\vec x$ 而言，首先左乘基变换矩阵，那么$\vec x$ 就会变成用我们空间描述的向量；接着左乘线性变换矩阵，即在我们的空间进行线性变换 $M$ ,并且变换后的结果向量依然用我们的空间描述；最后左乘基变换矩阵的逆阵，结果向量就成为了使用詹妮佛空间描述的向量。 表达式中 $A^{-1}MA$ 暗示着一种数学上的转移作用。两侧的矩阵完成了视角上的转换。  12p 特征向量和特征值  一个向量张成的空间是当前向量所在的直线。 对于某个特定的线性变换，在变换前后，大部分向量都在变换中离开了其张成的空间，但是某些特殊向量的确落在它们张成的空间里，这意味着矩阵对它们的作用仅仅是拉伸或者压缩而已，如同一个标量一样。这些特殊向量就被称为变换的“特征向量”，每个特征向量都有一个所属的值，被称为“特征值”，即衡量特征向量在变换中拉伸或压缩比例的因子。 处理 $A\vec x = \lambda \vec x$ 这个式子，在满足这个式子的时候，其中$\vec x$ 是 $A$ 的特征向量，$\lambda$ 是A的特征向量。 如果我们的基向量刚好是特征向量，那么对于这个线性变换来说，其对应的矩阵为对角矩阵（所有的基向量都是特征向量）。 对角矩阵有很多良好的性质。其中一个重要的方面是，矩阵与自己多次相乘的结果更容易计算，因为对角矩阵仅仅让基向量与某个特征值相乘。上一节的基变换，描述的是如何在另一个坐标系中表达当前坐标系所描述的变换。 $A^{-1}MA$ 取出你想用作新基的向量的坐标，在这里指的是两个特征向量，然后将坐标作为一个矩阵的列，这个矩阵就是基变换矩阵（ $M$ ），在右侧写下基变换矩阵（$A$），在左侧写下基变换矩阵的逆（$A^{-1}$），当你将原始的变换夹在两个矩阵中间时，所得的矩阵代表的是同一个变换，不过是从新基向量所构成的坐标系的角度来看的。 一组基向量（同样是特征向量）构成的集合被称为一组“特征基”。如果你要计算这个矩阵的n次幂，一种更容易的做法是先变换到特征基，在那个坐标系中计算n次幂，然后转换回标准坐标系。  13p 抽象向量空间  数学中有很多类似向量的事物。只要所处理对象，具有合理的数乘和加和概念，不管是空间中的箭头、一组数还是函数集合，线性代数中所有关于向量、线性变换和其他的概念都应该适用于它。这些类似向量的事物，它们构成的集合被称为向量空间。 在数学的表达中，我们倾向于得到用普适的概念，而普适的代价就是抽象。  14p 番外之伴随矩阵的几何意义   伴随矩阵 $A^{-1}$ 是求逆矩阵时 $A^{-1}$ 的一个过程量。为什么要费劲周折地求逆矩阵 $A^{-1}$ 呢，为了解方程。 $A\vec x = \vec b \Rightarrow \vec x = \vec bA^{-1}$ 从上面公式可以看出，当经过 $A^{-1}$ 和 $A$ 的复合变换之后，新的向量空间与原来形状相似，但是拉伸为原来的 $|A|$ 倍, $A^{*}A = AA^{*} = |A|E$ 。</description>
            <content type="html"><![CDATA[<h3 id="1p-什么是向量">1p 什么是向量？</h3>
<ol>
<li>定义坐标系</li>
<li>物理系，计算机系，数学系对向量的不同认识</li>
<li>向量可以是任何东西，只要保证两个向量相加以及数字与向量想成是有意义的即可。</li>
<li>可以将向量看作一种运动。从运动的角度定义向量加法和数乘运算。标量对向量而言，作用就是缩放。</li>
</ol>
<h3 id="2p-向量的线性组合张成的空间和基">2p 向量的线性组合，张成的空间和基</h3>
<ol>
<li>
<p>作为标量的向量坐标</p>
</li>
<li>
<p><strong>将向量的每个坐标看作一个标量，考虑它们如何拉伸或压缩一个向量</strong></p>
</li>
<li>
<p>引入单位向量作为坐标系的基，基向量是坐标缩放的对象</p>
</li>
<li>
<p>定义向量的线性组合：两个数乘向量的和被称为这两个向量的线性组合</p>
</li>
<li>
<p><strong>定义向量张成的空间(span)：所有可以表示为给定向量线性组合的向量的集合成为给定向量张成的空间</strong></p>
</li>
<li>
<p>定义线性相关和线性无关：N个向量可以张成的空间为N维空间，则这N个向量是线性无关的，否则是线性相关的。</p>
</li>
<li>
<p>定义空间的一组基：张成该空间的一个线性无关向量的集合。</p>
</li>
</ol>
<h3 id="3p-矩阵与空间线性变换">3p 矩阵与空间线性变换</h3>
<ol>
<li>“变换”实际上就是函数，它接受输入内容并输出对应结果，而在线性变换中输入的是向量，输出的也是一个向量，<strong>这中间的这个函数就是变换矩阵。</strong></li>
<li>线性变换的几何约束：线性变换必须满足两点要求，首先变换前后直线依旧是直线，其次 <strong>原点保持不变</strong> 。值得注意的是不仅仅要考虑水平与竖直的直线变换前后是否依旧是直线，还要考虑对角线的不是水平的线。线性变换应该是一种 <strong>保持网格平行且等距分布</strong> 的变换。</li>
<li>记录两个基向量i帽和j帽变换后的位置，其他向量都会随之而动；只要记录了变换后的i帽和j帽，我们就可以推断出任意向量在变换之后的位置，完全不必观察变换本身是什么样。</li>
<li><strong>矩阵：矩阵只是一个记号，它含有描述一个线性变换的信息。向量的列可以理解为变换后对应原基向量的一组基。</strong></li>
</ol>
<h3 id="4p-矩阵乘法与线性复合变换">4p 矩阵乘法与线性复合变换</h3>
<ol>
<li>两个矩阵相乘有着几何意义，也就是两个线性变换相继作用。乘积需要从右向左读，首先应用右侧矩阵所描述的变换，然后再应用左侧矩阵所描述的变换，它起源于函数的记号，每次将两个函数复合时，你总是要从右向左读。</li>
</ol>
<h3 id="5p-三维空间中的线性变换">5p 三维空间中的线性变换</h3>
<ol>
<li>三维空间的概念可以由二维推广得到。</li>
<li>三维线性变换由基向量的去向完全决定，只考虑跟踪这些基向量的话会更容易观察这些线性变换。</li>
</ol>
<h3 id="6p-行列式">6p 行列式</h3>
<ol>
<li>矩阵的行列式可以衡量矩阵对应的线性变换对空间的缩放程度。</li>
<li>对二维空间来说，线性变换改变面积的比例，被称为这个变换的行列式。</li>
<li>只需要检验一个矩阵的行列式是否为0，我们就能了解这个矩阵所代表的变换是否将空间压缩到更小的维度上。</li>
<li>完整概念下的行列式是允许出现负值的，这和定向的概念有关，当空间定向改变的情况发生时，行列式为负，但是行列式的绝对值依然表示区域面积的缩放比例。行列式在三维空间中的意义仍然是变换前后的缩放比例，但在三维空间中表现为体积的缩放。</li>
</ol>
<h3 id="7p-逆矩阵列空间零空间">7p 逆矩阵，列空间，零空间</h3>
<ol>
<li>总的来说， $A^{-1}$ 是满足以下性质的唯一变换，首先应用 $A$ 代表的变换，再应用 $A^{-1}$ 代表的变换，你会回到原始状态。两个变换相继作用在代数上体现为矩阵乘法。 $A^{-1}A$ 等于一个“什么都不做”的矩阵。</li>
<li>如果变换后的向量落在某个二维平面上，所以说 <strong>“秩”代表着变换后空间的维数</strong> ，意味着基向量仍旧能张成整个二维空间。</li>
<li>不管是一条直线、一个平面还是三维空间等，所有可能的变换结果的集合，被称为矩阵的“列空间”。换句话说，列空间就是矩阵的列所张成的空间。<strong>所以更精确的秩的定义是列空间的维数。</strong></li>
<li><strong>对一个满秩变换来说，唯一能在变换后落在原点的就是零向量自身，如果一个三维线性变换将空间压缩到一条直线上，那么就有一整个平面上的向量在变换后落在原点，变换后落在原点的向量的集合，被称为矩阵的“零空间”或“核”。</strong></li>
<li>每个线性方程组都有一个线性变换与之联系。矩阵 $A$ 代表一种线性变换。
，所以求解 $Ax=v$ 意味着我们去寻找一个向量 $x$，使得它在变换后与 $v$ 重合。</li>
<li>每个方程组都有一个线性变换与之联系，当逆变换存在时，你就能用这个逆变换求解方程组，否则，列空间的概念让我们清楚什么时候存在解，零空间的概念有助于我们理解所有可能的解的集合是什么样的。</li>
</ol>
<h3 id="8p-非方阵">8p 非方阵</h3>
<ol>
<li>一个 $3×2$ 矩阵，这个矩阵的列空间，是三维空间中一个过原点的二维平面，但是这个矩阵仍然是满秩的，因为列空间的维数与输入空间的维数相等。它的几何意义是将二维空间映射到三维空间上，矩阵有两列表明输入空间有两个基向量，有三行表明每一个基向量在变换后都用三个独立的坐标来描述。可以理解为将二维坐标系扩充为三维。</li>
</ol>
<h3 id="9p-点积与对偶性">9p 点积与对偶性</h3>
<ol>
<li>多维空间到一维空间（数轴）的线性变换，有不少函数能够接收二维向量并输出一个数。</li>
<li>两个向量点乘，就是将其中一个向量转化为线性变换。</li>
<li>向量仿佛是一个<strong>特定变换的概念性记号</strong>。对一般人类来说，想象空间中的向量比想象这个空间移动到数轴上更加容易。</li>
</ol>
<h3 id="10p-叉积">10p 叉积</h3>
<ol>
<li>假如你有两个向量 $\vec v$ 和 $\vec w$ ，考虑它们所张成的平行四边形， $\vec v$ 和 $\vec w$ 的叉积，就是这个平行四边形的面积。我们还要考虑定向问题，大致来讲，如果 $\vec  v$ 在 $\vec w$ 的右侧，那么$\vec v$ 叉乘 $\vec w$ 为正，并且值等于平行四边形的面积。但是如果 $\vec v$ 在 $\vec w$ 的左侧那么 $\vec v$ 叉乘 $\vec w$ 为负，即平行四边形面积的相反数。注意，这就是说顺序会对叉积有影响。</li>
<li>真正的叉积是通过两个三维向量生成一个新的三维向量。这个向量的长度就是平行四边形的面积，而这个向量的方向与平行四边形（所在的面）垂直。</li>
<li>对于给定的向量 $\vec v$ 和 $\vec w$ ,其对应着唯一一个叉积向量 $\vec x$ 。对于任意的向量 $\vec u$ 而言，$\vec u,\vec v,\vec w$ 三个向量组成的六面体的体积（行列式值）等于$\vec x$ 与 $\vec u$ 点积的结果。这也就是为什么可以使用行列式来记忆叉积。而使用 $\vec i,\vec j,\vec k$ 的单位向量的作用仅仅是根据 $\vec u$ 向量的坐标值将 $\vec u $ 向量化。</li>
</ol>
<h3 id="11p-基变换">11p 基变换</h3>
<ol>
<li>空间的原点重合，但是基向量不同。所有基向量在其自身的坐标系中都是单位向量。</li>
<li>现在给定两个坐标系，一个是我们的坐标系，另外一个是詹妮佛的坐标系。在不同坐标系之间进行转化的时候可以使用矩阵向量乘法。<strong>转移矩阵</strong> 用我们的语言表达詹妮佛的基向量，称为基变换。反之，转移矩阵的逆，表示用詹妮佛的基底表示我们的基底，可以实现从詹妮佛的矩阵向我们矩阵的变换。</li>
<li>一个矩阵的列为詹妮弗的基向量，这个矩阵可以看作一个线性变换，它将我们的基向量i帽和j帽，也就是我们眼中的 $(1, 0)$ 和 $(0, 1)$ ，变换为用詹妮弗的基向量描述的我们的 $(1, 0)$ 和 $(0, 1)$ 。</li>
<li>理解 $A^{-1}MA$ 的意义。 $M$ 是在我们的空间描述某一特定的线性变换。$A$ 是从詹妮佛坐标系向我们坐标系进行基变换的转移矩阵，$A^{-1}$ 是从我们坐标系向詹妮佛坐标系进行基变换的转移矩阵。最终 $A^{-1}MA$ 就是用詹妮佛坐标系描述的同样意义的线性变换。 $A^{-1}MA\vec x = \vec b$ 中对于詹妮佛空间的向量 $\vec x$ 而言，首先左乘基变换矩阵，那么$\vec x$ 就会变成用我们空间描述的向量；接着左乘线性变换矩阵，即在我们的空间进行线性变换 $M$ ,并且变换后的结果向量依然用我们的空间描述；最后左乘基变换矩阵的逆阵，结果向量就成为了使用詹妮佛空间描述的向量。</li>
<li>表达式中 $A^{-1}MA$ 暗示着一种数学上的转移作用。两侧的矩阵完成了视角上的转换。</li>
</ol>
<h3 id="12p-特征向量和特征值">12p 特征向量和特征值</h3>
<ol>
<li>一个向量张成的空间是当前向量所在的直线。</li>
<li>对于某个特定的线性变换，在变换前后，大部分向量都在变换中离开了其张成的空间，但是某些特殊向量的确落在它们张成的空间里，这意味着矩阵对它们的作用仅仅是拉伸或者压缩而已，如同一个标量一样。这些特殊向量就被称为变换的“特征向量”，每个特征向量都有一个所属的值，被称为“特征值”，即衡量特征向量在变换中拉伸或压缩比例的因子。</li>
<li>处理 $A\vec x = \lambda \vec x$ 这个式子，在满足这个式子的时候，其中$\vec x$ 是 $A$ 的特征向量，$\lambda$ 是A的特征向量。</li>
<li>如果我们的基向量刚好是特征向量，那么对于这个线性变换来说，其对应的矩阵为对角矩阵（所有的基向量都是特征向量）。</li>
<li>对角矩阵有很多良好的性质。其中一个重要的方面是，矩阵与自己多次相乘的结果更容易计算，因为对角矩阵仅仅让基向量与某个特征值相乘。<strong>上一节的基变换，描述的是如何在另一个坐标系中表达当前坐标系所描述的变换。</strong> $A^{-1}MA$ 取出你想用作新基的向量的坐标，在这里指的是两个特征向量，然后将坐标作为一个矩阵的列，这个矩阵就是基变换矩阵（ $M$ ），在右侧写下基变换矩阵（$A$），在左侧写下基变换矩阵的逆（$A^{-1}$），当你将原始的变换夹在两个矩阵中间时，所得的矩阵代表的是同一个变换，不过是从新基向量所构成的坐标系的角度来看的。</li>
<li>一组基向量（同样是特征向量）构成的集合被称为一组“特征基”。如果你要计算这个矩阵的n次幂，一种更容易的做法是先变换到特征基，在那个坐标系中计算n次幂，然后转换回标准坐标系。</li>
</ol>
<h3 id="13p-抽象向量空间">13p 抽象向量空间</h3>
<ol>
<li>数学中有很多类似向量的事物。只要所处理对象，具有合理的数乘和加和概念，不管是空间中的箭头、一组数还是函数集合，线性代数中所有关于向量、线性变换和其他的概念都应该适用于它。这些类似向量的事物，它们构成的集合被称为向量空间。</li>
<li>在数学的表达中，我们倾向于得到用普适的概念，而普适的代价就是抽象。</li>
</ol>
<h3 id="14p-番外之伴随矩阵的几何意义">14p 番外之伴随矩阵的几何意义</h3>
<ol>
<li>
<p>伴随矩阵 $A^{-1}$ 是求逆矩阵时 $A^{-1}$ 的一个过程量。为什么要费劲周折地求逆矩阵 $A^{-1}$ 呢，为了解方程。 $A\vec x = \vec b \Rightarrow \vec x = \vec bA^{-1}$ 从上面公式可以看出，当经过 $A^{-1}$ 和 $A$ 的复合变换之后，新的向量空间与原来形状相似，但是拉伸为原来的 $|A|$ 倍, $A^{*}A = AA^{*} = |A|E$ 。</p>
</li>
<li>
<p>伴随矩阵起的作用应该是将A对应的变换效果正规化，将所有维度变成同等层次。由上面的公式可以知道，这种正规化建立在对每个维度都扩展到原来的$|A|$ 倍（因为矩阵乘以一个数是针对矩阵中的每一个向量）。</p>
</li>
<li>
<p>如果A中存在一个维度被压缩（即 $r(A) = n-1$，则 $|A|=0$ ,那么这种正规化将会把所有维度压缩为0，因为只有之前被 $A$ 压缩的维度无法继续被 $A^{*}$ 压缩，因此 $r(A^{*}) = 1$ 。</p>
</li>
<li>
<p>如果A中存在多于一个维度被压缩（即 $r(A) &lt; n-1$，则 $|A|=0$ ,那么这种正规化将会把所有维度压缩为0，因此 $r(A^{*}) = 0$ 。</p>
</li>
</ol>
<h3 id="15p-番外之理解二次型">15p 番外之理解二次型</h3>
<ol>
<li>一般的，将含有 $N$ 个变量的的二次齐次函数成为二次型，</li>
</ol>
<p>$$
q_A(x_1,\ldots,x_n) = \sum_{i=1}^{n}\sum_{j=1}^{n}a_{ij}{x_i}{x_j} = \mathbf x^\mathrm{T} A \mathbf x
$$</p>
<p>称为二次型。二次型可以用矩阵表示，其中$\matrix A$ 是对称矩阵。</p>
<ol start="2">
<li>
<p>二次型讨论的主要问题是：寻求可逆的线性变换
$$
\begin {cases}
x_1 = c_{11}y_1+c_{12}y_{2}+\ldots+c_{1n}y_{n},\newline
x_2 = c_{21}y_1+c_{22}y_{2}+\ldots+c_{2n}y_{n},\newline
\space\space\space\space \ldots\ldots\ldots\ldots\newline
x_n = c_{n1}y_1+c_{n2}y_{2}+\ldots+c_{nn}y_{n}\newline
\end {cases}
$$
使二次型只含有平方项 $$\lambda_1 \vec x_1^2 + \lambda_2 \vec x_2^2 + \ldots + \lambda_n \vec x_n^2$$ 。</p>
</li>
<li>
<p>把可逆变换记作 $\mathbf x = \matrix C\mathbf y$ ,因此可以得到
$$
f = \mathbf x^\mathrm{T} A \mathbf x = (\matrix C\mathbf y)^{T}\mathbf A \mathbf (\matrix C\mathbf y) = \mathbf y^{T}(\matrix C\mathbf A \mathbf \matrix C)\mathbf y
$$</p>
</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>计算机网络中的经典问题</title>
            <link>https://oxygenbytes.github.io/posts/2020/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/</link>
            <pubDate>Thu, 06 Aug 2020 19:25:42 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2020/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/</guid>
            <description>传输层：TCP和UDP  什么是三次握手？ 什么是四次挥手？ TCP如何实现流量控制？ TCP的拥塞控制是怎么实现的？ TCP与UDP的区别 TCP如何保证传输的可靠性   应用层：HTTP和HTTPS  HTTP和HTTPS有什么区别？ GET与POST的区别？ Session与Cookie的区别？ 从输入网址到获得页面的过程 (越详细越好)？ HTTP请求有哪些常见状态码？ 什么是RIP (距离矢量路由协议)?   计算机网络体系结构 网络层协议  IP地址的分类？ 什么叫划分子网？ 什么是ARP协议？ 什么是NAT (网络地址转换)？     什么是三次握手 (three-way handshake)？  第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态； 第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态； 第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。  TCP建立连接可以两次握手吗？为什么? 不可以。有两个原因： 首先，可能会出现已失效的连接请求报文段又传到了服务器端。
 client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。</description>
            <content type="html"><![CDATA[<!-- raw HTML omitted -->
<ul>
<li>传输层：TCP和UDP
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-three-way-handshake">什么是三次握手？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">什么是四次挥手？</a></li>
<li><a href="#TCP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP如何实现流量控制？</a></li>
<li><a href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">TCP的拥塞控制是怎么实现的？</a></li>
<li><a href="#TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB">TCP与UDP的区别</a></li>
<li><a href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7">TCP如何保证传输的可靠性</a></li>
</ul>
</li>
<li>应用层：HTTP和HTTPS
<ul>
<li><a href="#HTTP%E5%92%8CHTTPS%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">HTTP和HTTPS有什么区别？</a></li>
<li><a href="#GET%E4%B8%8EPOST%E7%9A%84%E5%8C%BA%E5%88%AB">GET与POST的区别？</a></li>
<li><a href="#Session%E4%B8%8ECookie%E7%9A%84%E5%8C%BA%E5%88%AB">Session与Cookie的区别？</a></li>
<li><a href="#%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B-%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD">从输入网址到获得页面的过程 (越详细越好)？</a></li>
<li><a href="#HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81">HTTP请求有哪些常见状态码？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFRIP-Routing-Information-Protocol-%E8%B7%9D%E7%A6%BB%E7%9F%A2%E9%87%8F%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE-%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88">什么是RIP (距离矢量路由协议)?</a></li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">计算机网络体系结构</a></li>
<li>网络层协议
<ul>
<li><a href="#IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB">IP地址的分类？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E5%8F%AB%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91">什么叫划分子网？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFARP%E5%8D%8F%E8%AE%AE-Address-Resolution-Protocol">什么是ARP协议？</a></li>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFNAT-Network-Address-Translation-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">什么是NAT (网络地址转换)？</a></li>
</ul>
</li>
</ul>
<!-- raw HTML omitted -->
<hr>
<h3 id="什么是三次握手-three-way-handshake">什么是三次握手 (three-way handshake)？</h3>
<ul>
<li>第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；</li>
<li>第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态；</li>
<li>第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。</li>
</ul>
<h4 id="tcp建立连接可以两次握手吗为什么">TCP建立连接可以两次握手吗？为什么?</h4>
<p>不可以。有两个原因：
首先，可能会出现<strong>已失效的连接请求报文段又传到了服务器端</strong>。</p>
<blockquote>
<p>client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。</p>
</blockquote>
<p>其次，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。</p>
<h4 id="可以采用四次握手吗为什么">可以采用四次握手吗？为什么？</h4>
<p>可以。但是会降低传输的效率。
四次握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。</p>
<h4 id="第三次握手中如果客户端的ack未送达服务器会怎样">第三次握手中，如果客户端的ACK未送达服务器，会怎样？</h4>
<p>Server端：<br>
由于Server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接进入CLOSED状态），Client收到后会重新传ACK给Server。
Client端，两种情况：</p>
<ol>
<li>在Server进行超时重发的过程中，如果Client向服务器发送数据，数据头部的ACK是为1的，所以服务器收到数据之后会读取 ACK number，进入 establish 状态</li>
<li>在Server进入CLOSED状态之后，如果Client向服务器发送数据，服务器会以RST包应答。</li>
</ol>
<h4 id="如果已经建立了连接但客户端出现了故障怎么办">如果已经建立了连接，但客户端出现了故障怎么办？</h4>
<p>服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h4 id="初始序列号是什么">初始序列号是什么？</h4>
<p>TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002&hellip;三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。</p>
<h3 id="什么是四次挥手">什么是四次挥手？</h3>
<ul>
<li>第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；</li>
<li>第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。</li>
<li>第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；</li>
<li>第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。</li>
</ul>
<p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。</p>
<h4 id="如果第二次挥手时服务器的ack没有送达客户端会怎样">如果第二次挥手时服务器的ACK没有送达客户端，会怎样？</h4>
<p>客户端没有收到ACK确认，会重新发送FIN请求。</p>
<h4 id="客户端time_wait状态的意义是什么">客户端TIME_WAIT状态的意义是什么？</h4>
<p>第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。</p>
<p>MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p>
<h3 id="tcp如何实现流量控制">TCP如何实现流量控制？</h3>
<p>使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。</p>
<p>发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。</p>
<h4 id="什么是零窗口接收窗口为0时会怎样">什么是零窗口（接收窗口为0时会怎样）？</h4>
<p>如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。</p>
<h3 id="tcp的拥塞控制是怎么实现的">TCP的拥塞控制是怎么实现的？</h3>
<p>拥塞控制主要由四个算法组成：<strong>慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）</strong></p>
<ol>
<li>
<p>慢启动：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍</p>
</li>
<li>
<p>拥塞避免：当拥塞窗口的大小达到慢开始门限(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS.</p>
</li>
</ol>
<blockquote>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。<strong>（这是不使用快重传的情况）</strong></p>
</blockquote>
<ol start="3">
<li>
<p>快重传：快重传要求接收方在收到一个失序的报文段后就立即发出<strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p>
</li>
<li>
<p>快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。<br>
也有的快重传是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3*MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些。</p>
</li>
</ol>
<h3 id="tcp与udp的区别">TCP与UDP的区别</h3>
<ol>
<li>
<p>TCP是面向连接的，UDP是无连接的；
UDP发送数据之前不需要建立连接</p>
</li>
<li>
<p>TCP是可靠的，UDP不可靠；</p>
</li>
</ol>
<p>UDP接收方收到报文后，不需要给出任何确认</p>
<ol start="3">
<li>
<p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</p>
</li>
<li>
<p>TCP是面向字节流的，UDP是面向报文的；
面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</p>
</li>
<li>
<p>TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；</p>
</li>
<li>
<p>TCP首部开销（20字节）比UDP首部开销（8字节）要大</p>
</li>
<li>
<p>UDP 的主机不需要维持复杂的连接状态表</p>
</li>
</ol>
<h4 id="什么时候选择tcp什么时候选udp">什么时候选择TCP，什么时候选UDP？</h4>
<p>对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失</p>
<h4 id="http可以使用udp吗">HTTP可以使用UDP吗？</h4>
<p>HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠</p>
<h4 id="面向连接和无连接的区别">面向连接和无连接的区别</h4>
<p>无连接的网络服务（数据报服务）&ndash; 面向连接的网络服务（虚电路服务）</p>
<p>虚电路服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证；</p>
<p>数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃；</p>
<h3 id="tcp如何保证传输的可靠性">TCP如何保证传输的可靠性</h3>
<ol>
<li>数据包校验</li>
<li>对失序数据包重新排序（TCP报文具有序列号）</li>
<li>丢弃重复数据</li>
<li>应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；</li>
<li>超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；</li>
<li>流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出</li>
</ol>
<h3 id="http和https有什么区别">HTTP和HTTPS有什么区别？</h3>
<ol>
<li>端口不同：HTTP使用的是80端口，HTTPS使用443端口；</li>
<li>HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；</li>
<li>HTTPS由于加密解密会带来更大的CPU和内存开销；</li>
<li>HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买</li>
</ol>
<h4 id="https的连接过程">Https的连接过程？</h4>
<ol>
<li>客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）；</li>
<li>服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，<strong>加密公钥</strong>（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）；</li>
<li>客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；</li>
<li>如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个<strong>随机密钥</strong>（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行<strong>摘要</strong>计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；</li>
<li>服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器；</li>
<li>浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密</li>
</ol>
<p>总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。</p>
<h4 id="输入-wwwbaiducom怎么变成-httpswwwbaiducom-的怎么确定用http还是https">输入 <a href="http://www.baidu.com">www.baidu.com</a>，怎么变成 <a href="https://www.baidu.com">https://www.baidu.com</a> 的，怎么确定用HTTP还是HTTPS？</h4>
<p>一种是原始的302跳转，服务器把所有的HTTp流量跳转到HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。
解决方法是引入HSTS机制，用户浏览器在访问站点的时候强制使用HTTPS。</p>
<h4 id="什么是对称加密非对称加密区别是什么">什么是对称加密、非对称加密？区别是什么？</h4>
<ul>
<li>对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4</li>
<li>非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA</li>
<li>区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）</li>
</ul>
<h4 id="数字签名报文摘要的原理">数字签名、报文摘要的原理</h4>
<ul>
<li>发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文。</li>
<li>摘要算法:MD5、SHA</li>
</ul>
<h3 id="get与post的区别">GET与POST的区别？</h3>
<ol>
<li>GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；</li>
<li>GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源；</li>
<li>请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；</li>
<li>安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；</li>
<li>GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；</li>
<li>GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制</li>
</ol>
<h3 id="session与cookie的区别">Session与Cookie的区别？</h3>
<p>Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案</p>
<p>Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Sessionid查看状态。保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。</p>
<h3 id="从输入网址到获得页面的过程-越详细越好">从输入网址到获得页面的过程 (越详细越好)？</h3>
<ol>
<li>浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li>
<li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li>
<li>TCP/IP链接建立起来后，浏览器向服务器发送HTTP请求；</li>
<li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li>
<li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li>
<li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li>
</ol>
<h3 id="http请求有哪些常见状态码">HTTP请求有哪些常见状态码？</h3>
<ol>
<li>2xx状态码：操作成功。200 OK</li>
<li>3xx状态码：重定向。301 永久重定向；302暂时重定向</li>
<li>4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；</li>
<li>5xx状态码：服务端错误。500服务器内部错误；501服务不可用</li>
</ol>
<h3 id="什么是rip-routing-information-protocol-距离矢量路由协议-算法是什么">什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？</h3>
<p>每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。</p>
<p>（PS：RIP是应用层协议：<a href="https://www.zhihu.com/question/19645407">https://www.zhihu.com/question/19645407</a>）</p>
<ul>
<li>实现简单，开销小</li>
<li>随着网络规模扩大开销也会增大；</li>
<li>最大距离为15，限制了网络的规模；</li>
<li>当网络出现故障时，要经过较长的时间才能将此信息传递到所有路由器</li>
</ul>
<h3 id="计算机网络体系结构">计算机网络体系结构</h3>
<ul>
<li>Physical, Data Link, Network, Transport, Application</li>
<li>应用层：常见协议：
<ul>
<li>FTP(21端口)：文件传输协议</li>
<li>SSH(22端口)：远程登陆</li>
<li>TELNET(23端口)：远程登录</li>
<li>SMTP(25端口)：发送邮件</li>
<li>POP3(110端口)：接收邮件</li>
<li>HTTP(80端口)：超文本传输协议</li>
<li>DNS(53端口)：运行在UDP上，域名解析服务</li>
</ul>
</li>
<li>传输层：TCP/UDP</li>
<li>网络层：IP、ARP、NAT、RIP&hellip;</li>
</ul>
<p>路由器、交换机位于哪一层？</p>
<ul>
<li>路由器网络层，根据IP地址进行寻址；</li>
<li>交换机数据链路层，根据MAC地址进行寻址</li>
</ul>
<h3 id="ip地址的分类">IP地址的分类？</h3>
<p>路由器仅根据网络号net-id来转发分组，当分组到达目的网络的路由器之后，再按照主机号host-id将分组交付给主机；同一网络上的所有主机的网络号相同。</p>
<h3 id="什么叫划分子网">什么叫划分子网？</h3>
<p>从主机号host-id借用若干个比特作为子网号subnet-id；子网掩码：网络号和子网号都为1，主机号为0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。</p>
<h3 id="什么是arp协议-address-resolution-protocol">什么是ARP协议 (Address Resolution Protocol)？</h3>
<p><strong>ARP协议完成了IP地址与物理地址的映射</strong>。每一个主机都设有一个 ARP 高速缓存，里面有<strong>所在的局域网</strong>上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就向<strong>所在的局域网</strong>发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。</p>
<p>如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</p>
<h3 id="什么是nat-network-address-translation-网络地址转换">什么是NAT (Network Address Translation, 网络地址转换)？</h3>
<p>用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。</p>
]]></content>
        </item>
        
        <item>
            <title>深搜&amp;&amp;广搜</title>
            <link>https://oxygenbytes.github.io/posts/2020/07/%E6%B7%B1%E6%90%9C%E5%B9%BF%E6%90%9C/</link>
            <pubDate>Mon, 27 Jul 2020 23:06:27 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2020/07/%E6%B7%B1%E6%90%9C%E5%B9%BF%E6%90%9C/</guid>
            <description>深搜和广搜是最重要的几种算法之一，理解深搜和广搜的关键在于理解 递归 ， 状态机 ， 容器适配器--堆&amp;amp;&amp;amp;栈 和 集合分类 四个概念。
在搜索中，节点的状态有很多种(节点的状态此时主要根据操作来定义)，比如：未被访问的节点，被访问但是后续仍要用于寻找相邻节点的点，被访问并且后续不会被用到的点。其中，第二类点仍有使用的必要，因此将之放入特定容器，也就是队列或者栈。
深度优先搜索 深度优先搜索是一种用于遍历或搜索图或者树的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。
// 深度优先搜索 vector&amp;lt;int&amp;gt; G[MAX]; bool visit[MAX]; stack&amp;lt;int&amp;gt; stack; void DFS(int u){ visit[u] = 1; for(int i = 0;i &amp;lt; G[u].size();i++){ // 邻接关系  int v = G[u][i]; if(!visit[v]){ DFS(v); } } } void Dfs(int u){ visit[u] = 1; stack.push(u); while(!stack.empty()){ int u = stack.top(); stack.pop(); for(int i = 0;i &amp;lt; G[u].size();i++){ // 邻接关系  int v = G[u][i]; if(!</description>
            <content type="html"><![CDATA[<p>深搜和广搜是最重要的几种算法之一，理解深搜和广搜的关键在于理解 <code>递归</code> ， <code>状态机</code> ， <code>容器适配器--堆&amp;&amp;栈</code> 和 <code>集合分类</code> 四个概念。</p>
<!-- raw HTML omitted -->
<p><strong>在搜索中，节点的状态有很多种(节点的状态此时主要根据操作来定义)，比如：未被访问的节点，被访问但是后续仍要用于寻找相邻节点的点，被访问并且后续不会被用到的点。其中，第二类点仍有使用的必要，因此将之放入特定容器，也就是队列或者栈。</strong></p>
<h3 id="深度优先搜索">深度优先搜索</h3>
<p>深度优先搜索是一种用于遍历或搜索图或者树的算法。沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所在边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止。属于盲目搜索。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// 深度优先搜索
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> G[MAX];
<span style="color:#66d9ef">bool</span> visit[MAX];
stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> stack;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">int</span> u){
    visit[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> G[u].size();i<span style="color:#f92672">++</span>){ <span style="color:#75715e">// 邻接关系
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> G[u][i];
        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>visit[v]){
            DFS(v);
        }
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Dfs</span>(<span style="color:#66d9ef">int</span> u){
    visit[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    stack.push(u);
    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>stack.empty()){
        <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> stack.top();
        stack.pop();
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> G[u].size();i<span style="color:#f92672">++</span>){ <span style="color:#75715e">// 邻接关系
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> G[u][i];
            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>visit[v]){
                visit[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                stack.push(v);
            }
        }
    }
    
}

</code></pre></div><p>深度搜索的逻辑是这样的：将被访问但是后续仍要用于寻找相邻节点的点存入栈容器，这样的话，<strong>最先被访问的节点</strong>将是<strong>最后用于寻找相邻节点</strong>的点。也就实现了所谓的回溯。</p>
<p>| A  B  C  D  E   F  G  H  I</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-&gt; 访问顺序</p>
<p>| A  B  C  D  E   F  G  H  I</p>
<p>&lt;&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;- 寻找邻接点的顺序</p>
<h3 id="广度优先搜索">广度优先搜索</h3>
<p>广度优先搜索算法（英语：Breadth-First-Search，缩写为BFS），又译作宽度优先搜索，或横向优先搜索，是一种图形搜索算法。简单的说，BFS是从根节点开始，沿着树的宽度遍历树的节点。如果所有节点均被访问，则算法中止。广度优先搜索的实现一般采用open-closed表。属于盲目搜索。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// 深度优先搜索
</span><span style="color:#75715e"></span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> G[MAX];
<span style="color:#66d9ef">bool</span> visit[MAX];
stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> stack;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">DFS</span>(<span style="color:#66d9ef">int</span> u){
    visit[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> G[u].size();i<span style="color:#f92672">++</span>){ <span style="color:#75715e">// 邻接关系
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> G[u][i];
        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>visit[v]){
            DFS(v);
        }
    }
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Dfs</span>(<span style="color:#66d9ef">int</span> u){
    visit[u] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    stack.push(u);
    <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>stack.empty()){
        <span style="color:#66d9ef">int</span> u <span style="color:#f92672">=</span> stack.top();
        stack.pop();
        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> G[u].size();i<span style="color:#f92672">++</span>){ <span style="color:#75715e">// 邻接关系
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> G[u][i];
            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>visit[v]){
                visit[v] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
                stack.push(v);
            }
        }
    }
}
</code></pre></div><p>广度搜索的逻辑是这样的：将被访问但是后续仍要用于寻找相邻节点的点存入队列容器，这样的话，<strong>最先被访问的节点</strong>将是<strong>最先用于寻找相邻节点</strong>的点。</p>
<p>A  B  C  D  E   F  G  H  I</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;-&gt; 访问顺序</p>
<p>A  B  C  D  E   F  G  H  I</p>
<p>&mdash;&mdash;&mdash;&mdash;&mdash;&mdash;&ndash;&gt; 寻找邻接点的顺序</p>
]]></content>
        </item>
        
        <item>
            <title>C&#43;&#43;内存模型</title>
            <link>https://oxygenbytes.github.io/posts/2019/06/c-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
            <pubDate>Thu, 27 Jun 2019 09:06:27 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2019/06/c-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
            <description>内存模型所要表达的内容主要是这么描述： 一个内存操作的效果，在其他线程中的可见性问题。
C++ 内存模型 C分为四个区：堆，栈，静态全局变量区，常量区
C++内存分为5个区域（堆栈全常代）：
 堆 heap ： 由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露” 栈 stack ： 是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。 存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。 全局/静态存储区 （.bss段和.data段） ： 全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。 常量存储区 （.rodata段） ： 存放常量，不允许修改（通过非正当手段也可以修改） 代码区 （.text段） ： 存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）  根据c/c++对象生命周期不同，c/c++的内存模型有三种不同的内存区域，即
 自由存储区，动态区、静态区。 自由存储区：局部非静态变量的存储区域，即平常所说的栈 动态区： 用operator new ，malloc分配的内存，即平常所说的堆 静态区：全局变量 静态变量 字符串常量存在位置  而代码虽然占内存，但不属于c/c++内存模型的一部分
各个段的关系 一个正在运行着的C编译程序占用的内存分为代码区、初始化数据区、未初始化数据区、堆区 和栈区5个部分。
（1）代码区（text segment）。代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需 要借助栈来实现。
代码区的指令中包括操作码和要操作的对象（或对象地址引用）。如果是立即数（即具体的数值，如5），将直接包含在代码中；如果是局部数据，将在栈区 分配空间，然后引用该数据地址；如果是BSS区和数据区，在代码中同样将引用该数据地址。
（2）全局初始化数据区/静态数据区（Data Segment）。只初始化一次。
（3）未初始化数据区（BSS）。在运行时改变其值。
（4）栈区（stack）。由编译器自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。每当一个函数被调用，该函 数返回地址和一些关于调用的信息，比如某些寄存器的内容，被存储到栈区。然后这个被调用的函数再为它的自动变量和临时变量在栈区上分配空间，这就是C实现 函数递归调用的方法。每执行一次递归函数调用，一个新的栈框架就会被使用，这样这个新实例栈里的变量就不会和该函数的另一个实例栈里面的变量混淆。
（5）堆区（heap）。用于动态内存分配。堆在内存中位于bss区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时有可能由OS 回收。
之所以分成这么多个区域，主要基于以下考虑：
一个进程在运行过程中，代码是根据流程依次执行的，只需要访问一次，当然跳转和递归有可能使代码执行多次，而数据一般都需要访问多次，因此单独开辟 空间以方便访问和节约空间。 临时数据及需要再次使用的代码在运行时放入栈区中，生命周期短。 全局数据和静态数据有可能在整个程序执行过程中都需要访问，因此单独存储管理。 堆区由用户自由分配，以便管理。
下面通过一段简单的代码来查看C程序执行时的内存分配情况。相关数据在运行时的位置如注释所述。
//main.cpp int a = 0; //a在全局已初始化数据区 char *p1; //p1在BSS区（未初始化全局变量） main() { int b; //b在栈区 char s[] = &amp;#34;abc&amp;#34;; //s为数组变量，存储在栈区， //&amp;#34;abc&amp;#34;为字符串常量，存储在已初始化数据区 char *p1，*p2; //p1、p2在栈区 char *p3 = &amp;#34;123456&amp;#34;; //123456\0在已初始化数据区，p3在栈区 static int c =0； //C为全局（静态）数据，存在于已初始化数据区 //另外，静态数据会自动初始化 p1 = (char *)malloc(10);//分配得来的10个字节的区域在堆区 p2 = (char *)malloc(20);//分配得来的20个字节的区域在堆区 free(p1); free(p2); } C++内存配置器 标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。</description>
            <content type="html"><![CDATA[<p>内存模型所要表达的内容主要是这么描述： 一个内存操作的效果，在其他线程中的可见性问题。</p>
<h1 id="c-内存模型">C++ 内存模型</h1>
<p>C分为四个区：堆，栈，静态全局变量区，常量区</p>
<p>C++内存分为5个区域（堆栈全常代）：</p>
<ol>
<li>堆 heap ：
由new分配的内存块，其释放编译器不去管，由我们程序自己控制（一个new对应一个delete）。如果程序员没有释放掉，在程序结束时OS会自动回收。涉及的问题：“缓冲区溢出”、“内存泄露”</li>
<li>栈 stack ：
是那些编译器在需要时分配，在不需要时自动清除的存储区。存放局部变量、函数参数。
存放在栈中的数据只在当前函数及下一层函数中有效，一旦函数返回了，这些数据也就自动释放了。</li>
<li>全局/静态存储区 （.bss段和.data段） ：
全局和静态变量被分配到同一块内存中。在C语言中，未初始化的放在.bss段中，初始化的放在.data段中；在C++里则不区分了。</li>
<li>常量存储区 （.rodata段） ：
存放常量，不允许修改（通过非正当手段也可以修改）</li>
<li>代码区 （.text段） ：
存放代码（如函数），不允许修改（类似常量存储区），但可以执行（不同于常量存储区）</li>
</ol>
<p>根据c/c++对象生命周期不同，c/c++的内存模型有三种不同的内存区域，即</p>
<ol>
<li>自由存储区，动态区、静态区。</li>
<li>自由存储区：局部非静态变量的存储区域，即平常所说的栈</li>
<li>动态区： 用operator new ，malloc分配的内存，即平常所说的堆</li>
<li>静态区：全局变量 静态变量 字符串常量存在位置</li>
</ol>
<p>而代码虽然占内存，但不属于c/c++内存模型的一部分</p>
<h2 id="各个段的关系">各个段的关系</h2>
<p>一个正在运行着的C编译程序占用的内存分为代码区、初始化数据区、未初始化数据区、堆区 和栈区5个部分。</p>
<p>（1）代码区（text segment）。代码区指令根据程序设计流程依次执行，对于顺序指令，则只会执行一次（每个进程），如果反复，则需要使用跳转指令，如果进行递归，则需 要借助栈来实现。</p>
<p>代码区的指令中包括操作码和要操作的对象（或对象地址引用）。如果是立即数（即具体的数值，如5），将直接包含在代码中；如果是局部数据，将在栈区 分配空间，然后引用该数据地址；如果是BSS区和数据区，在代码中同样将引用该数据地址。</p>
<p>（2）全局初始化数据区/静态数据区（Data Segment）。只初始化一次。</p>
<p>（3）未初始化数据区（BSS）。在运行时改变其值。</p>
<p>（4）栈区（stack）。由编译器自动分配释放，存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈。每当一个函数被调用，该函 数返回地址和一些关于调用的信息，比如某些寄存器的内容，被存储到栈区。然后这个被调用的函数再为它的自动变量和临时变量在栈区上分配空间，这就是C实现 函数递归调用的方法。每执行一次递归函数调用，一个新的栈框架就会被使用，这样这个新实例栈里的变量就不会和该函数的另一个实例栈里面的变量混淆。</p>
<p>（5）堆区（heap）。用于动态内存分配。堆在内存中位于bss区和栈区之间。一般由程序员分配和释放，若程序员不释放，程序结束时有可能由OS 回收。</p>
<p><strong>之所以分成这么多个区域，主要基于以下考虑：</strong></p>
<p><strong>一个进程在运行过程中，代码是根据流程依次执行的，只需要访问一次，当然跳转和递归有可能使代码执行多次，而数据一般都需要访问多次，因此单独开辟 空间以方便访问和节约空间。</strong>
<strong>临时数据及需要再次使用的代码在运行时放入栈区中，生命周期短。</strong>
<strong>全局数据和静态数据有可能在整个程序执行过程中都需要访问，因此单独存储管理。</strong>
<strong>堆区由用户自由分配，以便管理。</strong></p>
<p>下面通过一段简单的代码来查看C程序执行时的内存分配情况。相关数据在运行时的位置如注释所述。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">//main.cpp
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;        <span style="color:#75715e">//a在全局已初始化数据区
</span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p1;        <span style="color:#75715e">//p1在BSS区（未初始化全局变量）
</span><span style="color:#75715e"></span>main()
{
<span style="color:#66d9ef">int</span> b;        <span style="color:#75715e">//b在栈区
</span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> s[] <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;abc&#34;</span>;  <span style="color:#75715e">//s为数组变量，存储在栈区，
</span><span style="color:#75715e">//&#34;abc&#34;为字符串常量，存储在已初始化数据区
</span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p1<span style="color:#960050;background-color:#1e0010">，</span><span style="color:#f92672">*</span>p2;    <span style="color:#75715e">//p1、p2在栈区
</span><span style="color:#75715e"></span><span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>p3 <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;123456&#34;</span>;  <span style="color:#75715e">//123456\0在已初始化数据区，p3在栈区
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span><span style="color:#ae81ff">0</span><span style="color:#960050;background-color:#1e0010">；</span>    <span style="color:#75715e">//C为全局（静态）数据，存在于已初始化数据区
</span><span style="color:#75715e">//另外，静态数据会自动初始化
</span><span style="color:#75715e"></span>p1 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)malloc(<span style="color:#ae81ff">10</span>);<span style="color:#75715e">//分配得来的10个字节的区域在堆区
</span><span style="color:#75715e"></span>p2 <span style="color:#f92672">=</span> (<span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>)malloc(<span style="color:#ae81ff">20</span>);<span style="color:#75715e">//分配得来的20个字节的区域在堆区
</span><span style="color:#75715e"></span>free(p1);
free(p2);
}
</code></pre></div><h2 id="c内存配置器">C++内存配置器</h2>
<p>标准库中包含一个名为allocator的类，允许我们将分配和初始化分离。使用allocator通常会提供更好的性能和更灵活的内存管理能力。</p>
<blockquote>
<p>new有一些灵活性上的局限，其中一方面表现在它将内存分配和对象构造组合在了一起。类似的，delete将对象析构和内存释放组合在了一起。我们分配单个对象时，通常希望将内存分配和对象初始化组合在一起。因为在这种情况下，我们几乎肯定知道对象应有什么值。当分配一大块内存时，我们通常计划在这块内存上按需构造对象。在此情况下，我们希望将内存分配和对象构造分离。这意味着我们可以分配大块内存，但只在真正需要时才真正执行对象的创建操作(同时付出一定开销)。一般情况下，将内存分配和对象构造组合在一起可能会导致不必要的浪费。</p>
<p>标准库allocator类定义在头文件memory中，它帮助我们将内存分配和对象构造分离开来。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。类似vector，allocator是一个模板。为了定义一个allocator对象，我们必须指明这个allocator可以分配的对象类型。当一个allocator对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置。</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;memory&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">//先熟悉一下提供的allocator用法
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">int</span> argc, <span style="color:#66d9ef">char</span> <span style="color:#66d9ef">const</span> <span style="color:#f92672">*</span>argv[])
{
    allocator<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> a;
    <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>ptr<span style="color:#f92672">=</span>a.allocate(<span style="color:#ae81ff">5</span>);
    a.construct(ptr,<span style="color:#ae81ff">3</span>);
    a.construct(ptr<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>);
    a.construct(ptr<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>);
    a.construct(ptr<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>,<span style="color:#f92672">-</span><span style="color:#ae81ff">3</span>);
    a.construct(ptr<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">3</span>);
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">5</span>;i<span style="color:#f92672">++</span>)
    {
        cout<span style="color:#f92672">&lt;&lt;*</span>(ptr<span style="color:#f92672">+</span>i)<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34; &#34;</span>;
        a.destroy(ptr<span style="color:#f92672">+</span>i);
    }
    a.deallocate(ptr,<span style="color:#ae81ff">5</span>);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="内存屏障">内存屏障</h2>
<p>内存屏障
CPU乱序执行在单线程环境下是一种很好的优化手段，但是在多线程环境下，就会出现数据不一致的问题，因此就可以通过内存屏障这个机制来处理这个问题。</p>
<p>1.写内存屏障(Store Memory Barrier)：在指令后插入Store Barrier，能让写入缓存中最新数据更新写入主内存中，让其他线程可见。强制写入主内存，这种显示调用，不会让CPU去进行指令重排序
2.读内存屏障(Load Memory Barrier)：在指令后插入Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存中加载数据。也是不会让CPU去进行指令重排。</p>
]]></content>
        </item>
        
        <item>
            <title>C&#43;&#43;基础知识</title>
            <link>https://oxygenbytes.github.io/posts/2019/06/c-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link>
            <pubDate>Thu, 27 Jun 2019 09:06:27 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2019/06/c-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid>
            <description>const常引用（const + &amp;amp;）避免函数参数的双向传递 在c++可以使用引用传递作为函数的形参传入函数，相较于值传递的方式，引用传递能够节省函数使用时的内存分配，不需要像值传递一样拷贝实参。对于普通的数据类型可能看出引用的优势，但是如果函数的传入参数是一个十分复杂的结构体或者类，那么引用传递可以节省很大的内存开销。
然而，由于引用传递是双向的，当在函数中对于形参的数据进行改变后，实参的值也会进行相应的改变，如下所示：
#include &amp;lt;iostream&amp;gt;using namespace std; struct Point { int x; int y; Point(int a, int b) { x=a; y=b; } }; void fun(Point&amp;amp; point); int main() { Point point(1,1); fun(point); point.x++; point.y++; cout &amp;lt;&amp;lt; &amp;#34;======main======&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;点的坐标为(&amp;#34; &amp;lt;&amp;lt; point.x &amp;lt;&amp;lt; &amp;#34;.&amp;#34; &amp;lt;&amp;lt; point.y &amp;lt;&amp;lt; &amp;#34;)&amp;#34; &amp;lt;&amp;lt; endl; return 0; } void fun(Point&amp;amp; point) { point.x++; point.y++; cout &amp;lt;&amp;lt; &amp;#34;======fun======&amp;#34; &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; &amp;#34;点的坐标为(&amp;#34; &amp;lt;&amp;lt; point.</description>
            <content type="html"><![CDATA[<h3 id="const常引用const--避免函数参数的双向传递">const常引用（const + &amp;）避免函数参数的双向传递</h3>
<p>在c++可以使用引用传递作为函数的形参传入函数，相较于值传递的方式，引用传递能够节省函数使用时的内存分配，不需要像值传递一样拷贝实参。对于普通的数据类型可能看出引用的优势，但是如果函数的传入参数是一个十分复杂的结构体或者类，那么引用传递可以节省很大的内存开销。</p>
<p>然而，由于引用传递是双向的，当在函数中对于形参的数据进行改变后，实参的值也会进行相应的改变，如下所示：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span>
{
    <span style="color:#66d9ef">int</span> x;
    <span style="color:#66d9ef">int</span> y;
    
    Point(<span style="color:#66d9ef">int</span> a, <span style="color:#66d9ef">int</span> b)
    {
	x<span style="color:#f92672">=</span>a;
	y<span style="color:#f92672">=</span>b;
    }
};

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span>(Point<span style="color:#f92672">&amp;</span> point);

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    Point point(<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>);
    fun(point);
    point.x<span style="color:#f92672">++</span>;
    point.y<span style="color:#f92672">++</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;======main======&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;点的坐标为(&#34;</span> <span style="color:#f92672">&lt;&lt;</span> point.x <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> point.y <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}


<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">fun</span>(Point<span style="color:#f92672">&amp;</span> point)
{
    point.x<span style="color:#f92672">++</span>;
    point.y<span style="color:#f92672">++</span>;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;======fun======&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;点的坐标为(&#34;</span> <span style="color:#f92672">&lt;&lt;</span> point.x <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;,&#34;</span> <span style="color:#f92672">&lt;&lt;</span> point.y <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;)&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}
<span style="color:#75715e">/*
</span><span style="color:#75715e">------fun-------
</span><span style="color:#75715e">点的坐标为（2,2）
</span><span style="color:#75715e">------main------
</span><span style="color:#75715e">点的坐标为(2,3)
</span></code></pre></div><p>如果我们既不想改变传入参数的值，也不想因为值传递产生太大的开销，那么可以尝试一下使用常引用。可见，使用了常引用之后，传入参数的值就是一个常量了，无法对其内部变量进行修改，保证了传入参数的数据安全性。</p>
<p>这里引用的作用主要是为了避免值传递，值传递通常会有很大的开销。</p>
<h3 id="c语言三个结束符有什么不同-eof-0-n">C语言三个结束符有什么不同？ EOF ‘\0’ &lsquo;\n&rsquo;</h3>
<h4 id="网友a">网友A:</h4>
<p>EOF（End of file）是C/C++里面的宏定义，具体定义式是#define EOF -1，表示的是文件的结束标志，值等于-1，一般用在文件读取的函数里面，比如fscanf fgetc fgets等，一旦读取到文件最后就返回EOF标志并结束函数调用
&lsquo;\0&rsquo;是转义字符，值等于0，主要用在C风格字符串的末尾，表示字符串结束标志。通常用在和字符串相关的函数里面，如strcmp strcpy等会用到它
&lsquo;\n&rsquo;表示换行符，通常用作一些读取函数的读取结束标志，比如scanf,getchar(),gets()等，一旦遇到&rsquo;\n&rsquo;就结束读取并返回</p>
<h4 id="网友b">网友B:</h4>
<p>EOF 是一个宏定义,一般是-1,用在读文件的时候.因为如果读到字符,这个字符的值一定是正的,所以用负值表示结束
\0 是ascii码为0,一般表示用在字符串结尾表示空值.一个char a[100]数组,当你用这个数组进行字符串操作时,会把\0当做结尾.如果没有设置\0标志,这个字符串很可能出现问题
\n 好像ascii码是10吧,就是回车的意思,a是1个字符,c也是1个字符,同样的,回车也是1个字符,只不过表现得不那么正常而已</p>
<h3 id="extern-c">extern &ldquo;C&rdquo;</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#ifndef __INCvxWorksh  </span><span style="color:#75715e">/*防止该头文件被重复引用*/</span><span style="color:#75715e">
</span><span style="color:#75715e">#define __INCvxWorksh
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#ifdef __cplusplus    </span><span style="color:#75715e">//__cplusplus是cpp中自定义的一个宏
</span><span style="color:#75715e"></span><span style="color:#66d9ef">extern</span> <span style="color:#e6db74">&#34;C&#34;</span> {          <span style="color:#75715e">//告诉编译器，这部分代码按C语言的格式进行编译，而不是C++的
</span><span style="color:#75715e"></span><span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">/**** some declaration or so *****/</span>  

<span style="color:#75715e">#ifdef __cplusplus
</span><span style="color:#75715e"></span>}
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#endif </span><span style="color:#75715e">/* __INCvxWorksh */</span><span style="color:#75715e">
</span></code></pre></div><p><strong>2、被extern &ldquo;C&quot;修饰的变量和函数是按照C语言方式编译和链接的</strong>
首先看看C++中对类似C的函数是怎样编译的。
作为一种面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：
void foo( int x, int y );
该函数被C编译器编译后在符号库中的名字为_foo，而C++编译器则会产生像_foo_int_int之类的名字（不同的编译器可能生成的名字不同，但是都采用了相同的机制，生成的新名字称为“mangled name”）。
** _foo_int_int这样的名字包含了函数名、函数参数数量及类型信息，C++就是靠这种机制来实现函数重载的。** 例如，在C++中，函数void foo( int x, int y )与void foo( int x, float y )编译生成的符号是不相同的，后者为_foo_int_float。
同样地，C++中的变量除支持局部变量外，还支持类成员变量和全局变量。用户所编写程序的类成员变量可能与全局变量同名，我们以&rdquo;.&ldquo;来区分。而本质上，编译器在进行编译时，与函数的处理相似，也为类中的变量取了一个独一无二的名字，这个名字与用户程序中同名的全局变量名字不同。</p>
<h3 id="whilescanfdneof-用法">while(scanf(&quot;%d&rdquo;,&amp;n)!=EOF) 用法</h3>
<p>EOF(end of file)就是文件的结束，通常来判断文件的操作是否结束的标志。</p>
<p>EOF不是特殊字符，而是定义在头文件&lt;stdio.h&gt;的常量，一般等于-1；</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;stdio.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
   <span style="color:#66d9ef">char</span> str[<span style="color:#ae81ff">100</span>][<span style="color:#ae81ff">100</span>];
   <span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>,j;
	<span style="color:#66d9ef">while</span>(scanf(<span style="color:#e6db74">&#34;%s&#34;</span>, str[i]) <span style="color:#f92672">!=</span> EOF)
        <span style="color:#75715e">//在黑框中手动输入时，系统并不知道什么时候到达了所谓的“文件末尾“
</span><span style="color:#75715e"></span>        <span style="color:#75715e">//因此需要用&lt; Ctrl + Z &gt;组合键，然后按&lt; Enter &gt;键的方式来告诉系统已经到了 EOF，这样系统才会结束 while
</span><span style="color:#75715e"></span>	i<span style="color:#f92672">++</span>;                           <span style="color:#75715e">//while((str[i]=getchar())!=&#39;\n&#39;)
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span>(j<span style="color:#f92672">=</span>i<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;j<span style="color:#f92672">&gt;=</span><span style="color:#ae81ff">0</span>;j<span style="color:#f92672">--</span>){
		printf(<span style="color:#e6db74">&#34;%s&#34;</span>,str[j]);
		<span style="color:#66d9ef">if</span>(j<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>)
			printf(<span style="color:#e6db74">&#34; &#34;</span>);
	} 
 
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>除了文件结束，做题遇见最多的是标准输入，但是标准输入与文件不一样，无法事先知道输入的长度，必须手动输入一个字符，表示到达EOF：</p>
<p>Linux中，在新的一行的开头，按下Ctrl-D，就代表EOF（如果在一行的中间按下Ctrl-D，则表示输出“标准输入”的缓存区，所以这时必须按两次Ctrl-D）；</p>
<p>Windows中，Ctrl-Z表示EOF。 </p>
<h3 id="结构体可以用作-map-的键吗">结构体可以用作 <code>map</code> 的键吗？</h3>
<p>答： 可以，结构体是可以作为 <code>map</code> 的键的，但需要满足一定的条件。首先 <code>map</code> 的底层结构是 <code>红黑树</code> ，属于 <code>平衡二叉查找树</code> 。<strong>对于map来说， key必须是有序的， 也就是说， key与key之间必须能比较， 所以需要重载  <code>&lt;</code> 号</strong> 。所以当结构体作为 <code>map</code> 的键时，必须要重载 <code>&lt;</code> 运算符。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;map&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
 
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Info</span>
{
    string name;
    <span style="color:#66d9ef">int</span> score;
 	<span style="color:#75715e">// 重载 &lt; 运算符
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">const</span> Info <span style="color:#f92672">&amp;</span>x) <span style="color:#66d9ef">const</span>
    {
        <span style="color:#66d9ef">return</span> score <span style="color:#f92672">&lt;</span> x.score;
    }
};
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    Info a, b;
 
    a.name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;eric&#34;</span>;
    a.score <span style="color:#f92672">=</span> <span style="color:#ae81ff">90</span>;
 
    b.name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;cat&#34;</span>;
    b.score <span style="color:#f92672">=</span> <span style="color:#ae81ff">85</span>;
 
 
    map<span style="color:#f92672">&lt;</span>Info, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> m;
    m[a] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
    m[b] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
 
    map<span style="color:#f92672">&lt;</span>Info, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it;
    <span style="color:#66d9ef">for</span>(it <span style="color:#f92672">=</span> m.begin(); it <span style="color:#f92672">!=</span> m.end(); it<span style="color:#f92672">++</span>)
    {
        cout <span style="color:#f92672">&lt;&lt;</span> it<span style="color:#f92672">-&gt;</span>first.name <span style="color:#f92672">&lt;&lt;</span> endl;
    }
 
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;

</code></pre></div><h3 id="c中虚函数表存储在什么位置">C++中虚函数表存储在什么位置？</h3>
<p>C++中<strong>虚函数表位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。</strong></p>
<h3 id="c中能不能在-main-前执行代码">C++中能不能在 <code>main</code> 前执行代码？</h3>
<p>答：可以。</p>
<ol>
<li>全局类变量的构造都在main之前。可以通过全局变量来在 <code>main</code> 前面执行代码。</li>
<li><code>static</code> 标识符标记的全局变量在程序初始化阶段，先于 <code>main</code> 执行。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//全局static变量的初始化在程序初始阶段，先于main函数的执行，所以可以利用这一点。在leetcode里经常见到利用一点，在main之前关闭cin与stdin的同步来“加快”速度的黑科技：
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> _ <span style="color:#f92672">=</span> []{
    cin.sync_with_stdio(false);
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}();
<span style="color:#75715e">//_attribute((constructor))是gcc扩展，标记这个函数应当在main函数之前执行。同样有一个__attribute((destructor))，标记函数应当在程序结束之前（main结束之后，或者调用了exit后）执行;
</span></code></pre></div><p>其实想一想 <code>main</code> 无非就是个入口点，只不过是更改入口点而已。</p>
<h3 id="typedef-关键字wikihttpszhwikipediaorgwikitypedef">typedef 关键字<a href="https://zh.wikipedia.org/wiki/Typedef">wiki</a></h3>
<blockquote>
<p>在C和C++编程语言中，typedef是一个关键字。它用来对一个数据类型取一个别名，目的是为了使源代码更易于阅读和理解。它通常用于简化声明复杂的类型组成的结构 ，但它也常常在各种长度的整数数据类型中看到，例如size_t和time_t。</p>
</blockquote>
<p>typedef的语法是 :</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> typedeclaration;
</code></pre></div><h4 id="和结构体一起使用">和结构体一起使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Node Node;
<span style="color:#66d9ef">struct</span> Node {
    <span style="color:#66d9ef">int</span> data;
    Node <span style="color:#f92672">*</span>nextptr;
};
</code></pre></div><h4 id="和指针一起使用">和指针一起使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>intptr;

intptr cliff, allen;        <span style="color:#75715e">// both cliff and allen are int* type
</span><span style="color:#75715e"></span>
intptr cliff2, <span style="color:#f92672">*</span>allen2;     <span style="color:#75715e">// cliff2 is int* type, but allen2 is int** type
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">// same as: intptr cliff2;
</span><span style="color:#75715e"></span>                            <span style="color:#75715e">//          intptr *allen2;
</span></code></pre></div><h4 id="和结构体指针一起使用">和结构体指针一起使用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> Node Node;
<span style="color:#66d9ef">struct</span> Node {
    <span style="color:#66d9ef">int</span> data;
    Node <span style="color:#f92672">*</span>nextptr;
};
</code></pre></div><h4 id="和函数指针一起使用">和函数指针一起使用</h4>
<p>先来看这段没有使用typedef的代码：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">do_math</span>(<span style="color:#66d9ef">float</span> arg1, <span style="color:#66d9ef">int</span> arg2) {
    <span style="color:#66d9ef">return</span> arg2;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">call_a_func</span>(<span style="color:#66d9ef">int</span> (<span style="color:#f92672">*</span>call_this)(<span style="color:#66d9ef">float</span>, <span style="color:#66d9ef">int</span>)) {
    <span style="color:#66d9ef">int</span> output <span style="color:#f92672">=</span> call_this(<span style="color:#ae81ff">5.5</span>, <span style="color:#ae81ff">7</span>);
    <span style="color:#66d9ef">return</span> output;
}

<span style="color:#66d9ef">int</span> final_result <span style="color:#f92672">=</span> call_a_func(<span style="color:#f92672">&amp;</span>do_math);
</code></pre></div><p>注意：这里的call_this是指向参数类型为(float, int) ,返回值是int类型的函数指针，另外注意函数指针的用法，</p>
<p>使用typedef后这段代码可以改写为：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>MathFunc)(<span style="color:#66d9ef">float</span>, <span style="color:#66d9ef">int</span>);

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">do_math</span>(<span style="color:#66d9ef">float</span> arg1, <span style="color:#66d9ef">int</span> arg2) {
    <span style="color:#66d9ef">return</span> arg2;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">call_a_func</span>(MathFunc call_this) {
    <span style="color:#66d9ef">int</span> output <span style="color:#f92672">=</span> call_this(<span style="color:#ae81ff">5.5</span>, <span style="color:#ae81ff">7</span>);
    <span style="color:#66d9ef">return</span> output;
}

<span style="color:#66d9ef">int</span> final_result <span style="color:#f92672">=</span> call_a_func(<span style="color:#f92672">&amp;</span>do_math);
</code></pre></div><p><strong>前加一个typedef关键字，这样就定义一个名为MathFunc的函数指针类型，而不是一个MathFunc变量。</strong></p>
<h3 id="指针">指针</h3>
<h4 id="什么是指针">什么是指针？</h4>
<p>我们指知道：C语言中的数组是指 一类 类型，数组具体区分为  int 类型数组，double类型数组,char数组 等等。同样指针 这个概念也泛指 一类 数据类型，int指针类型，double指针类型，char指针类型等等。</p>
<p>通常，我们用int类型保存一些整型的数据，如 int num = 97 ， 我们也会用char来存储字符： char ch = &lsquo;a&rsquo;。</p>
<p>我们也必须知道：任何程序数据载入内存后，在内存都有他们的地址，这就是指针。而为了保存一个数据在内存中的地址，我们就需要指针变量。</p>
<p>因此：<strong>指针是程序数据在内存中的地址，而指针变量是用来保存这些地址的变量。</strong></p>
<p>指针本身也是一种数据类型</p>
<h4 id="为什么需要指针">为什么需要指针？</h4>
<p>指针解决了一些编程中基本的问题。</p>
<p>第一，指针的使用使得不同区域的代码可以轻易的共享内存数据。当然你也可以通过数据的复制达到相同的效果，但是这样往往效率不太好，因为诸如结构体等大型数据，占用的字节数多，复制很消耗性能。但使用指针就可以很好的避免这个问题，因为任何类型的指针占用的字节数都是一样的（根据平台不同，有4字节或者8字节或者其他可能）。</p>
<p>第二，指针使得一些复杂的链接性的数据结构的构建成为可能，比如链表，链式二叉树等等。</p>
<p>第三，有些操作必须使用指针。如操作申请的堆内存。还有：C语言中的一切函数调用中，值传递都是“按值传递(pass by value)”的，如果我们要在函数中修改被传递过来的对象，就必须通过这个对象的指针来完成。</p>
<h3 id="什么是指针变量">什么是指针变量？</h3>
<p><strong>指针变量是用来存放指针(地址)的变量。</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">int</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">76</span>;
<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>pointer; <span style="color:#75715e">//此处int是指针变量的基类型，基类型就是指针变量指向的变量的类型
</span><span style="color:#75715e"></span>pointer <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>c;

<span style="color:#75715e">//将变量c的地址赋值给指针变量pointer
</span><span style="color:#75715e">//赋值后，称指针变量pointer指向了变量c
</span></code></pre></div><p>指针运算符 *</p>
<p>取址运算符&amp;</p>
<p><strong>指针变量也是变量，是变量就有地址</strong></p>
<h3 id="关于空指针">关于空指针</h3>
<p><strong>void*类型指针</strong></p>
<p>由于void是空类型，因此void<em>类型的指针只保存了指针的值，而丢失了类型信息，我们不知道他指向的数据是什么类型的，只指定这个数据在内存中的起始地址，如果想要完整的提取指向的数据，程序员就必须对这个指针做出正确的类型转换，然后再解指针。因为，编译器不允许直接对void</em>类型的指针做解指针操作。</p>
<h2 id="函数指针的几个疑惑">函数指针的几个疑惑</h2>
<h3 id="问题c语言中-函数名也称为函数的指针那函数名是否也占内存空间">问题：c语言中， 函数名也称为函数的指针，那函数名是否也占内存空间？</h3>
<blockquote>
<p>首先你上面的话是错误的，函数名是一段指令的入口地址，它是地址常量，不占用内存空间，只是在编译阶段存在于编译器的符号表中，例如函数的入口地址是0x123456，在翻译成<a href="https://www.baidu.com/s?wd=%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao">机器指令</a>以后，函数名是不存在的其在本质上对应汇编上的jump指令，在执行函数的时候，跳转到0x123456，这个函数名的本质就是这个地址。</p>
</blockquote>
<p>c语言中其他变量的原理也都是类似的</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">typedef</span> <span style="color:#a6e22e">int</span> (<span style="color:#f92672">*</span>funcptr)(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>);
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">add</span>(<span style="color:#66d9ef">int</span> a,<span style="color:#66d9ef">int</span> b){
    <span style="color:#66d9ef">return</span> a<span style="color:#f92672">+</span>b;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">test</span>(funcptr ptr,<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y){
    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;this is a test&#34;</span>;
    <span style="color:#66d9ef">return</span> ptr(x, y);
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    cout<span style="color:#f92672">&lt;&lt;</span>test(add,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>)<span style="color:#f92672">&lt;&lt;</span>endl;
    cout<span style="color:#f92672">&lt;&lt;</span>test(<span style="color:#f92672">&amp;</span>add,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>)<span style="color:#f92672">&lt;&lt;</span>endl;
    cout<span style="color:#f92672">&lt;&lt;&amp;</span>main;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>1）其实，MyFun的函数名与FunP函数指针都是一样的，即都是函数指针。MyFun函数名是一个函数指针常量，而FunP是一个函数数指针变量，这是它们的关系。</p>
<p>2）但函数名调用如果都得如(*MyFun)(10)这样，那书写与读起来都是不方便和不习惯的。所以C语言的设计者们才会设计成又可允许MyFun(10)这种形式地调用（这样方便多了并与数学中的函数形式一样，不是吗？）。</p>
<p>3）为统一起见，FunP函数指针变量也可以FunP(10)的形式来调用。</p>
<p>4）赋值时，即可FunP = &amp;MyFun形式，也可FunP = MyFun。</p>
<h3 id="c的左值与右值">C++的左值与右值</h3>
<h4 id="基本概念">基本概念</h4>
<p>左值与右值的概念在很多地方比较模糊，但其对我们对C++的理解很重要。比如我们看github上的源码的时候会看到std::move等用法，在查找其含义之后得知它功能是将左值转成右值引用，若是我们不理解左值与右值，还是无法知道它到底有什么用。</p>
<p>我们还会经常在编译错误和警告信息中看到左值右值概念的出现。</p>
<h4 id="左值与右值的简单定义">左值与右值的简单定义</h4>
<p>lvalue(locator value), 即左值，代表一个在内存中占有确定位置的对象，换句话说就是有一个地址。</p>
<p>rvalue：一个表达式要么是lvalue，要么是rvalue。所以，不是lvalue的表达式就是rvalue。</p>
<p>左值是指表达式结束后依然存在的持久对象，右值是指表达式结束时就不再存在的<strong>临时对象</strong>。一个区分左值与右值的便捷方法是：看能不能对表达式取地址，如果能，则为左值，否则为右值。</p>
<h4 id="c-11中用表示左值引用用表示右值引用">C++ 11中用&amp;表示左值引用，用&amp;&amp;表示右值引用</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// Big Block
</span><span style="color:#75715e">// https://www.nowcoder.com/discuss/418915
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;string&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
    {
        std<span style="color:#f92672">::</span>string s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1234&#34;</span>;
        cout <span style="color:#f92672">&lt;&lt;</span> s <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// &#34;1234&#34;
</span><span style="color:#75715e"></span>    }
    {
        std<span style="color:#f92672">::</span>string s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1234&#34;</span>;
        std<span style="color:#f92672">::</span>move(s);
        cout <span style="color:#f92672">&lt;&lt;</span> s <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// &#34;1234&#34;
</span><span style="color:#75715e"></span>    }
    {
        std<span style="color:#f92672">::</span>string s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1234&#34;</span>;
        <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> s1 <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(s);
        cout <span style="color:#f92672">&lt;&lt;</span> s <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">&lt;&lt;</span> s1 <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// &#34;1234 1234&#34;
</span><span style="color:#75715e"></span>    }
    {
        std<span style="color:#f92672">::</span>string s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1234&#34;</span>;
        <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;&amp;</span> s1 <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(s);
        cout <span style="color:#f92672">&lt;&lt;</span> s <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">&lt;&lt;</span> s1 <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// &#34;1234 1234&#34;
</span><span style="color:#75715e"></span>    }
 
    {
        std<span style="color:#f92672">::</span>string s <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;1234&#34;</span>;
        <span style="color:#66d9ef">auto</span> s1 <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>move(s);
        cout <span style="color:#f92672">&lt;&lt;</span> s <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39; &#39;</span> <span style="color:#f92672">&lt;&lt;</span> s1 <span style="color:#f92672">&lt;&lt;</span> endl;  <span style="color:#75715e">// &#34; 1234&#34;
</span><span style="color:#75715e"></span> 
    }
 
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="c迭代器">C++迭代器</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;vector&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>using namespace std;

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> v1;
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>;i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">100</span>;i<span style="color:#f92672">++</span>){
        <span style="color:#66d9ef">if</span>(i<span style="color:#f92672">%</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>)
            v1.push_back(i);
    }
    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it;
    <span style="color:#66d9ef">for</span>(vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>iterator it<span style="color:#f92672">=</span>v1.begin(); it <span style="color:#f92672">!=</span> v1.end();it<span style="color:#f92672">++</span>){
        <span style="color:#f92672">*</span>it <span style="color:#f92672">+=</span> <span style="color:#ae81ff">2</span>;
        cout<span style="color:#f92672">&lt;&lt;*</span>it<span style="color:#f92672">&lt;&lt;</span>endl;
        
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

</code></pre></div><p>注意迭代器的用法</p>
<p>::不要丢掉，否则语法错误；迭代器的本质是指针，指针在使用之前一定要赋值</p>
<h3 id="小知识">小知识</h3>
<ol>
<li>c语言print()函数的参数
<ol>
<li>%d        &mdash;&mdash;&ndash;dicimal(base 10)</li>
<li>%x         &mdash;&mdash;&ndash;hexadecimat(base 16)</li>
<li>%o         &mdash;&mdash;&ndash;octal(base 8)</li>
</ol>
</li>
</ol>
]]></content>
        </item>
        
        <item>
            <title>C&#43;&#43;输入输出</title>
            <link>https://oxygenbytes.github.io/posts/2019/06/c-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</link>
            <pubDate>Thu, 27 Jun 2019 09:06:27 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2019/06/c-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</guid>
            <description>使用cin来读取数据 ​cin 基本用法
​cin遇到缓冲区中的[enter],[space],[tab]会结束当前输入，并舍弃[enter],[space],[tab]，继续下一项输入，当有连续[space],[enter,[tab]会全部舍弃。
使用getchar()来输入字符 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int main(){ char c; cout&amp;lt;&amp;lt;&amp;#34;enter a sentence:&amp;#34;&amp;lt;&amp;lt;endl; while(c=getchar()) cout&amp;lt;&amp;lt;c; return 0; } getchar不跳过任何字符，包括终止字符Ctrl + D，严格按照函数个数读入字符
使用cin.get()输入字符 #include &amp;lt;bits/stdc++.h&amp;gt;using namespace std; int main(){ char c; cout&amp;lt;&amp;lt;&amp;#34;enter a sentence:&amp;#34;&amp;lt;&amp;lt;endl; while((c=cin.get()) != EOF) cout&amp;lt;&amp;lt;c; return 0; } cin.get()会读取除了终止字符Ctrl + Z ，Ctrl + D外的任何字符
使用cin.get()读取字符串 cin.get(ch,10,&amp;#39;\n&amp;#39;); // 读取10-1个字符（包括空格），赋值给特定的字符数组 // 如果在读取10-1个字符之前，遇到制定的终止字符&amp;#39;\n&amp;#39;,则提前停止读取 // 读取成功返回非0值（真），失败返回0值（假） 使用cin.getline()函数读入整行字符串 getline()和get()的区别
  getline遇到终止字符标志时结束，缓冲区文件指针移到终止字符之后
  get遇到终止字符后停止读取，缓冲区文件指针不移动
cin.get()	&amp;mdash;&amp;gt; we are family;</description>
            <content type="html"><![CDATA[<h2 id="使用cin来读取数据">使用cin来读取数据</h2>
<p>​cin 基本用法</p>
<p>​cin遇到缓冲区中的[enter],[space],[tab]会结束当前输入，并舍弃[enter],[space],[tab]，继续下一项输入，当有连续[space],[enter,[tab]会全部舍弃。</p>
<h2 id="使用getchar来输入字符">使用getchar()来输入字符</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">char</span> c;
    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;enter a sentence:&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;
    <span style="color:#66d9ef">while</span>(c<span style="color:#f92672">=</span>getchar())
        cout<span style="color:#f92672">&lt;&lt;</span>c;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>getchar不跳过任何字符，包括终止字符Ctrl + D，严格按照函数个数读入字符</p>
<h2 id="使用cinget输入字符">使用cin.get()输入字符</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">char</span> c;
    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;enter a sentence:&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;
    <span style="color:#66d9ef">while</span>((c<span style="color:#f92672">=</span>cin.get()) <span style="color:#f92672">!=</span> EOF)
        cout<span style="color:#f92672">&lt;&lt;</span>c;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>cin.get()会读取除了终止字符Ctrl + Z ，Ctrl + D外的任何字符</p>
<h3 id="使用cinget读取字符串">使用cin.get()读取字符串</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">cin.get(ch,<span style="color:#ae81ff">10</span>,<span style="color:#e6db74">&#39;\n&#39;</span>);
<span style="color:#75715e">// 读取10-1个字符（包括空格），赋值给特定的字符数组
</span><span style="color:#75715e">// 如果在读取10-1个字符之前，遇到制定的终止字符&#39;\n&#39;,则提前停止读取
</span><span style="color:#75715e">// 读取成功返回非0值（真），失败返回0值（假）
</span></code></pre></div><h2 id="使用cingetline函数读入整行字符串">使用cin.getline()函数读入整行字符串</h2>
<p>getline()和get()的区别</p>
<ul>
<li>
<p>getline遇到终止字符标志时结束，缓冲区文件指针移到终止字符之后</p>
</li>
<li>
<p>get遇到终止字符后停止读取，缓冲区文件指针不移动</p>
<p>cin.get()	   &mdash;&gt;  we are <strong>f</strong>amily;</p>
<p>cin.getline()   &mdash;&gt;   we are f<strong>a</strong>ily;</p>
</li>
</ul>
<h3 id="一个需要特别关注的程序">一个需要特别关注的程序</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#66d9ef">char</span> s[<span style="color:#ae81ff">10</span>][<span style="color:#ae81ff">10</span>];
    <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    cin<span style="color:#f92672">&gt;&gt;</span>n;
    <span style="color:#75715e">//cin.get(); 程序正常！
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> n;i<span style="color:#f92672">++</span>){
        cin.getline(a[i],<span style="color:#ae81ff">10</span>);
    }
    <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;i <span style="color:#f92672">&lt;</span> n;i<span style="color:#f92672">++</span>){
        cout<span style="color:#f92672">&lt;&lt;</span>a[i]<span style="color:#f92672">&lt;&lt;</span>endl;
    }
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
<span style="color:#ae81ff">3</span>
sunday
monday
tuesday

sunday
monday <span style="color:#75715e">//少了一行，因为n读入后的换行被cin.getline()读取了
</span></code></pre></div>]]></content>
        </item>
        
        <item>
            <title>侯捷C&#43;&#43;程序设计</title>
            <link>https://oxygenbytes.github.io/posts/2019/06/%E4%BE%AF%E6%8D%B7c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</link>
            <pubDate>Thu, 27 Jun 2019 09:06:27 +0800</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2019/06/%E4%BE%AF%E6%8D%B7c-%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</guid>
            <description>课程链接
基本语法知识   &amp;lt;iostream&amp;gt; 尖括号是使用标准头文件
&amp;ldquo;matrix.h&amp;rdquo; 调用自给定头文件
  构造函数可以重载(overload)
  对于没有用到指针的类，一般不用写析构函数
  构造函数可以放在private里，这就是设计模式中的单例模式(singleton)
  class Singleton { private: Singleton(); public: static Singleton&amp;amp; instance() { static Singleton INSTANCE; return INSTANCE; } }; 常量成员函数  将const关键字放在函数声明之后,意在强调该函数不可以改变其参数，只有成员函数才可以。
class Complex{ double re; double im; double real() const {return re}; double imag() return {return im}; }; { Complex c1(2,1); cout&amp;lt;&amp;lt;c1.real()&amp;lt;&amp;lt;endl; //right  const Complex c2(2,1); cout&amp;lt;&amp;lt;c2.imag()&amp;lt;&amp;lt;endl; //wrong } C++引用其底层就是指针，但是这里做了封装     引用既可以作为函数参数，用以避免参数的复制，也可以用于对参数进行改变</description>
            <content type="html"><![CDATA[<p><a href="https://www.youtube.com/playlist?list=PL_qkCOD3sKurKd4YsdLpSp2BAKvgW6FaH">课程链接</a></p>
<h2 id="基本语法知识">基本语法知识</h2>
<ol>
<li>
<p>&lt;iostream&gt; 尖括号是使用标准头文件</p>
<p>&ldquo;matrix.h&rdquo; 调用自给定头文件</p>
</li>
<li>
<p>构造函数可以重载(overload)</p>
</li>
<li>
<p>对于没有用到指针的类，一般不用写析构函数</p>
</li>
<li>
<p>构造函数可以放在private里，这就是设计模式中的单例模式(singleton)</p>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Singleton</span>
{
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
   Singleton();

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
   <span style="color:#66d9ef">static</span> Singleton<span style="color:#f92672">&amp;</span> instance()
   {
      <span style="color:#66d9ef">static</span> Singleton INSTANCE;
      <span style="color:#66d9ef">return</span> INSTANCE;
   }
};
</code></pre></div><ol start="5">
<li>常量成员函数</li>
</ol>
<p>将const关键字放在函数声明之后,意在强调该函数不可以改变其参数，只有成员函数才可以。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Complex</span>{
    <span style="color:#66d9ef">double</span> re;
    <span style="color:#66d9ef">double</span> im;
    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">real</span>() <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> re};   
    <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">imag</span>() <span style="color:#66d9ef">return</span> {<span style="color:#66d9ef">return</span> im};
};
{
    Complex <span style="color:#a6e22e">c1</span>(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>);
    cout<span style="color:#f92672">&lt;&lt;</span>c1.real()<span style="color:#f92672">&lt;&lt;</span>endl; <span style="color:#75715e">//right
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">const</span> Complex <span style="color:#a6e22e">c2</span>(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>);
    cout<span style="color:#f92672">&lt;&lt;</span>c2.imag()<span style="color:#f92672">&lt;&lt;</span>endl; <span style="color:#75715e">//wrong
</span><span style="color:#75715e"></span>}
</code></pre></div><ol start="6">
<li>C++引用其底层就是指针，但是这里做了封装</li>
</ol>
<blockquote>
<ol>
<li>
<p>引用既可以作为函数参数，用以避免参数的复制，也可以用于对参数进行改变</p>
</li>
<li>
<p>如果不想更改参数值，但是又想避免复制带来的开销，可以使用常引用， 即const ListNode&amp;</p>
</li>
<li>
<p>C++引用除了可以作为函数参数，还可以用作返回值，其目的与用作参数一致</p>
</li>
<li>
<p>return by reference 不能使用的情况：返回值是函数局部变量，函数结束时候该变量被释放</p>
</li>
</ol>
</blockquote>
<ol start="7">
<li>friend关键字</li>
</ol>
<blockquote>
<p>friend函数可以自由的取得对应类的private数据</p>
<p>相同class的各个objects互为friends</p>
</blockquote>
<ol start="8">
<li>c++防御式声明</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#ifndef __COMPLEX__
</span><span style="color:#75715e">#define __COMPLEX__
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#endif
</span></code></pre></div><ol start="9">
<li>inline关键字</li>
</ol>
<blockquote>
<p>在C/C++中，內联（inline）指的是在使用函数的地方不进行函数调用，而是将函数的实现代码插入到此处。 这样能够以增加代码大小为代价，省下函数调用过程产生的开销，加快程序执行速度。 內联属于编译器的一个优化措施，而inline关键字就是用来告诉编译器，希望对指定的函数做內联优化。</p>
<p>所谓“希望”，意思就是这仅仅是程序员对编译器的优化建议，并不能强制编译器必须将指定的函数內联。 因此，如果一定要将一个函数內联，用inline关键字是不行的，需要使用编译器扩展或配合编译器优化选项。</p>
</blockquote>
<ol start="10">
<li>返回引用</li>
</ol>
<blockquote>
<p>当返回一个引用时，要注意被引用的对象不能超出作用域。所以返回一个对局部变量的引用是不合法的，但是，可以返回一个对静态变量的引用。</p>
<p>函数返回引用的时候，可以利用全局变量（作为函数返回），或者在函数的形参表中有引用或者指针（作为函数返回），这两者有一个共同点，就是返回执行完毕以后，变量依然存在，那么返回的引用才有意义。</p>
<p>当不希望返回的对象被修改的时候，可以添加const。</p>
<p>a reference is a pointer which will auto dereference. 引用是自带解引用的指针(reference=*ptr)</p>
<p>引用使用时无需<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E8%A7%A3%E5%BC%95%E7%94%A8">解引用</a>(*)，指针需要解引用；</p>
<p>​    “sizeof 引用”得到的是所指向的变量(对象)的大小，而“sizeof 指针”得到的是指针本身(所指向的变量或对象的地址)的大小；</p>
<p>​    引用不能为空，指针可以为空；</p>
<p>​    指针和引用的自增(++)运算意义不一样；引用自增被引用对象的值，指针自增内存地址。</p>
</blockquote>
<ol start="11">
<li>友元函数</li>
</ol>
<blockquote>
<p>类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。</p>
<p>友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。</p>
<p>如果要声明函数为一个类的友元，需要在类定义中该函数原型前使用关键字 <strong>friend</strong></p>
</blockquote>
<ol start="12">
<li>strlen的实现原理和计数方法</li>
</ol>
<p>strlen所作的是一个计数器的工作，它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，直到碰到第一个字符串结束符'\0&rsquo;为止，然后返回计数器值(长度不包含'\0')。</p>
<ol start="13">
<li>c++深拷贝和浅拷贝</li>
</ol>
<blockquote>
<p>C++中类的拷贝有两种：深拷贝，浅拷贝：当出现类的等号赋值时，即会调用拷贝函数
两个的区别
1  在未定义显示拷贝构造函数的情况下，系统会调用默认的拷贝函数——即浅拷贝，它能够完成成员的一一复制。当数据成员中没有指针时，浅拷贝是可行的；但当数据成员中有指针时，如果采用简单的浅拷贝，则两类中的两个指针将指向同一个地址，当对象快结束时，会调用两次析构函数，而导致指针悬挂现象，所以，此时，必须采用深拷贝。
2 深拷贝与浅拷贝的区别就在于深拷贝会在堆内存中另外申请空间来储存数据，从而也就解决了指针悬挂的问题。简而言之，当数据成员中有指针时，必须要用深拷贝。</p>
</blockquote>
<ol start="14">
<li>重载&laquo;符号</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">String</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> get_c_str() <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> m_data};
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">char</span><span style="color:#f92672">*</span> m_data;
}
ostream<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;&lt;</span> (ostream<span style="color:#f92672">&amp;</span> os, <span style="color:#66d9ef">const</span> String<span style="color:#f92672">&amp;</span> str){
    <span style="color:#75715e">// 对于运算符重载的两个参数，第一个在运算符前，第二个在运算符后
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 对于此函数而言，os &lt;&lt; str;
</span><span style="color:#75715e"></span>    os <span style="color:#f92672">&lt;&lt;</span> str.get_c_str();
    <span style="color:#66d9ef">return</span> os; <span style="color:#75715e">// 这里返回os可以保证连续使用运算符 cout&lt;&lt;a&lt;&lt;b
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 先执行cout&lt;&lt;a ==&gt; cout,然后执行cout&lt;&lt;b
</span><span style="color:#75715e"></span>}
{
    String s1{<span style="color:#e6db74">&#34;hello &#34;</span>};
    cout <span style="color:#f92672">&lt;&lt;</span> s1; <span style="color:#75715e">// cout是一个ostream对象
</span><span style="color:#75715e"></span>}
</code></pre></div><ol start="15">
<li>堆，栈，内存管理</li>
</ol>
<p>stack：当你调用函数，函数本身就会形成一个stack用来放置参数，返回地址，局部变量等。</p>
<p>heap: （system heap） 由操作系统分配的一块全局内存空间。程序可以动态分配后从中获得若干区块。</p>
<p>a. 局部变量，对象放置在stack中，当作用域结束其内存就会自动释放。</p>
<p>b. 静态变量/全局变量，保存在静态区中，使用<code>static</code> 关键字或写在任何作用域之外，作用域结束之后仍存在，直到程序结束。</p>
<p>c. 通过<code>new</code> 申请的的变量，对象会被保存在堆中，只有当使用 <code>delete</code> 函数之后其内存才会被释放。</p>
<ol start="16">
<li>
<p><code>new</code> 关键字的实现原理：先分配内存（底层通过malloc实现），然后调用对象的构造函数。<code>delete</code> 关键字的实现原理：先调用对象的析构函数，然后释放内存（底层通过free实现）。</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=7VojokbA4aM&amp;list=PL_qkCOD3sKupGq_6w-vI4u7MQcjbQEOuD&amp;index=9&amp;t=0s">动态分配所得的内存块（VC）</a></p>
<p><a href="https://yq.aliyun.com/articles/681152?spm=a2c4e.11153940.0.0.7f67a8bavAOgqS">动态分配的内存块</a></p>
</li>
<li>
<p>static关键字</p>
</li>
</ol>
<p>作用</p>
<ol>
<li>修饰普通变量，修改变量的存储区域和生命周期，使变量存储在静态区，在 main 函数运行前就分配了空间，如果有初始值就用初始值初始化它，如果没有初始值系统用默认值初始化它。</li>
<li>修饰普通函数，表明函数的作用范围，仅在定义该函数的文件内才能使用。在多人开发项目时，为了防止与他人命名空间里的函数重名，可以将函数定位为 static。</li>
<li>修饰成员变量，修饰成员变量使所有的对象只保存一个该变量，而且不需要生成对象就可以访问该成员。</li>
<li>修饰成员函数，修饰成员函数使得不需要生成对象就可以访问该函数，但是在 static 函数内不能访问非静态成员。</li>
</ol>
<p><code>static member functions</code> 只能处理 <code>static member data</code></p>
<ol start="19">
<li>类模板</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> 
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">complex</span>{ <span style="color:#75715e">// 类模板，作为一系列类的模板
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
	complex(T r <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>,T i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>) <span style="color:#f92672">:</span> re(r), im(i) { }
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
	T re,im;
};
complex<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> <span style="color:#75715e">//模板类 ，将类模板具体化得到的类叫做模板类
</span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> min(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> a, <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> b){
    <span style="color:#66d9ef">return</span> b <span style="color:#f92672">&lt;</span> a <span style="color:#f92672">?</span> b : a;
}
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Stone</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">&lt;</span> (<span style="color:#66d9ef">const</span> stone<span style="color:#f92672">&amp;</span> rhs) <span style="color:#66d9ef">const</span> {<span style="color:#66d9ef">return</span> _weight <span style="color:#f92672">&lt;</span> rhs._weight;}
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> _weight;
};
stone <span style="color:#a6e22e">r1</span>(<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>),r2(<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">3</span>),r3;
r3 <span style="color:#f92672">=</span> min(r1,r2); <span style="color:#75715e">// 函数模板无需特殊写明，编译会自动进行类型推导
</span><span style="color:#75715e"></span>
</code></pre></div><ol start="20">
<li>命名空间</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">namespace</span> std <span style="color:#75715e">// 命名空间声明
</span><span style="color:#75715e"></span>{

}
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std; <span style="color:#75715e">// 使用方式
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> main{
    cout<span style="color:#f92672">&lt;&lt;</span>a;
    std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span>a;
}
</code></pre></div><ol start="21">
<li>
<p>面向对象设计&ndash;三大特性</p>
<p>a. 封装 (has-a)</p>
<p>b. 继承 (is-a)</p>
<p>c. 多态(virtual function)</p>
</li>
</ol>
<h3 id="面向对象设计原则">面向对象设计原则</h3>
<p><strong>面向对象设计原则（1）</strong></p>
<p>依赖倒置原则（DIP）</p>
<ul>
<li>高层模块（稳定）不应该依赖于低层模块（变化），二者都应该依赖于抽象（稳定）。</li>
<li>抽象（稳定）不应该依赖于变化），实现细节应该依赖于抽象（稳定）。</li>
</ul>
<p><strong>面向对象设计原则（2）</strong></p>
<p>开放封闭原则（OCP）</p>
<ul>
<li>对扩展开放，对更改封闭。</li>
<li>类模块应该是可扩展的，但是不可修改。</li>
</ul>
<p><strong>面向对象设计原则（3）</strong></p>
<p>单一职责原则（SRP）</p>
<ul>
<li>一个类应该仅有一个引起它变化的原因。</li>
<li>变化的方向隐含着类的责任。</li>
</ul>
<p><strong>面向对象设计原则（4）</strong></p>
<p>Liskov 替换原则（LSP）</p>
<ul>
<li>子类必须能够替换它们的基类（IS-A）。</li>
<li>继承表达类型抽象。</li>
</ul>
<p><strong>面向对象设计原则（5）</strong></p>
<p>接口隔离原则（ISP）</p>
<ul>
<li>不应该强迫客户程序依赖它们不用的方法。</li>
<li>接口应该小而完备。</li>
</ul>
<p><strong>面向对象设计原则（6）</strong></p>
<p>优先使用对象组合，而不是类继承</p>
<ul>
<li>类继承通常为“白箱复用”，对象组合通常为“黑箱复用”</li>
<li>继承在某种程度上破坏了封装性，子类父类耦合度高。</li>
<li>而对象组合则只要求被组合的对象具有良好定义的接口，度低。</li>
</ul>
<p><strong>面向对象设计原则（7）</strong></p>
<p>封装变化点</p>
<ul>
<li>
<p>使用封装来创建对象之间的分界层，让设计者可以在分界的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合。</p>
<p><strong>面向对象设计原则（8）</strong></p>
</li>
</ul>
<p>针对接口编程，而不是针对实现编程</p>
<ul>
<li>不将变量类型声明为某个特定的具体类，而是声明为某个接口。</li>
<li>客户程序无需获知对象的具体类型，只需要知道对象所具有的接口。</li>
</ul>
<p>减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”的类型设计方案。</p>
<h3 id="转换函数">转换函数</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;bits/stdc++.h&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">// Conversion function
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fraction</span> <span style="color:#75715e">// 分数类
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Fraction(<span style="color:#66d9ef">int</span> num,<span style="color:#66d9ef">int</span> den <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">:</span> son(num),mum(den) {}
    <span style="color:#75715e">// 将Fraction类转化为double
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">double</span>() <span style="color:#66d9ef">const</span>{ <span style="color:#75715e">// 转换函数，无需返回类型
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">return</span> (<span style="color:#66d9ef">double</span>) (son <span style="color:#f92672">/</span> mum);
    } 
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> son;
    <span style="color:#66d9ef">int</span> mum;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    Fraction f(<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">2</span>);
    cout<span style="color:#f92672">&lt;&lt;</span>(<span style="color:#66d9ef">double</span>)f<span style="color:#f92672">&lt;&lt;</span>endl;
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="non-explicit-one-argument-ctor">Non-explicit-one-argument ctor</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fraction</span> <span style="color:#75715e">// 分数类
</span><span style="color:#75715e"></span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    Fraction(<span style="color:#66d9ef">int</span> num,<span style="color:#66d9ef">int</span> den <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">:</span> son(num),mum(den) {}
  
	Fraction <span style="color:#66d9ef">operator</span><span style="color:#f92672">+</span> (<span style="color:#66d9ef">const</span> Fraction<span style="color:#f92672">&amp;</span> f) { 
        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Fracton</span>(...);
    } 
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> son;
    <span style="color:#66d9ef">int</span> mum;
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    Fraction f(<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>);
    Fraction d2<span style="color:#f92672">=</span>f<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>;
    <span style="color:#75715e">// 调用non-explicit ctor将4转换为Fraction，并调用operator+
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="explict关键字">explict关键字</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Fraction</span>
{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#75715e">// 当使用explict的时候，说明只有在构造函数被显式调用的时候，才会进行自动转换
</span><span style="color:#75715e"></span>    explict Fraction(<span style="color:#66d9ef">int</span> num,<span style="color:#66d9ef">int</span> den <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">:</span> son(num),mum(den) {}
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> son;
    <span style="color:#66d9ef">int</span> num;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    Fraction f(<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">5</span>);
    Fraction d2<span style="color:#f92672">=</span>f<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>;
}
</code></pre></div><h3 id="c智能指针pointer-like-classes">C++智能指针(pointer-like classes)</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#75715e">// 智能指针是一个类模板
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">shared_ptr</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    T<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>() <span style="color:#66d9ef">const</span> <span style="color:#75715e">// 重载*操作符
</span><span style="color:#75715e"></span>    { <span style="color:#66d9ef">return</span> <span style="color:#f92672">*</span>px;}
    T<span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">-&gt;</span>() <span style="color:#66d9ef">const</span> <span style="color:#75715e">// 重载-&gt;操作符
</span><span style="color:#75715e"></span>    { <span style="color:#66d9ef">return</span> px;} <span style="color:#75715e">// -&gt; 具有连续传递性，见下
</span><span style="color:#75715e"></span>    
    shared_ptr(T<span style="color:#f92672">*</span> p) <span style="color:#f92672">:</span> px(p) {}
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    T<span style="color:#f92672">*</span> px;
    <span style="color:#66d9ef">long</span><span style="color:#f92672">*</span> pn;
};

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Foo</span>{
    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">method</span>(<span style="color:#66d9ef">void</span>) {}
};

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    shared_ptr<span style="color:#f92672">&lt;</span>Foo<span style="color:#f92672">&gt;</span> sp{<span style="color:#66d9ef">new</span> Foo};
    Foo f(<span style="color:#f92672">*</span>sp);
    sp<span style="color:#f92672">-&gt;</span>method; <span style="color:#75715e">// [sp-&gt;]method == [px]-&gt;method 
</span><span style="color:#75715e"></span>}
</code></pre></div><p>迭代器也是一种特殊的智能指针，同时迭代器还要比一般的智能指针重载 <code>++</code> , <code>--</code> 等运算符，同时对 <code>*</code> , <code>-&gt;</code> 运算符要进行特殊的重载。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// cpp list容器的迭代器 -- 双向链表
</span><span style="color:#75715e"></span>reference <span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>() <span style="color:#66d9ef">const</span>
{ <span style="color:#66d9ef">return</span> (<span style="color:#f92672">*</span>node).data;} <span style="color:#75715e">// 指针*直接返回数据
</span><span style="color:#75715e"></span>pointer <span style="color:#66d9ef">operator</span><span style="color:#f92672">-&gt;</span>() <span style="color:#66d9ef">const</span>
{ <span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span>(<span style="color:#66d9ef">operator</span><span style="color:#f92672">*</span>());}
</code></pre></div><h3 id="function-like-classes">function like classes</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 仿函数
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">identity</span> <span style="color:#960050;background-color:#1e0010">：</span><span style="color:#66d9ef">public</span> unary_function<span style="color:#f92672">&lt;</span>T,T<span style="color:#f92672">&gt;</span>{
    <span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> <span style="color:#66d9ef">operator</span>() (<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> x) <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> x;}
};
<span style="color:#75715e">// 仿函数的基类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Arg</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Result</span><span style="color:#f92672">&gt;</span> <span style="color:#75715e">// 单操作数基类
</span><span style="color:#75715e"></span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">unary_function</span> {
   <span style="color:#66d9ef">typedef</span> Arg argument_type;
   <span style="color:#66d9ef">typedef</span> Result result_type;
};
</code></pre></div><p>函数对象要重载<code>()</code> 操作符。</p>
<h3 id="namespace-经验谈">namespace 经验谈</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">namespace</span> testspace{
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">test_member_template</span>(){}
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
	testspace<span style="color:#f92672">::</span>test_member_template();
}
</code></pre></div><h3 id="成员模板">成员模板</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T1</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T2</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">pair</span> {
    T1 first;
    T2 second;
    <span style="color:#75715e">// 以下为成员模板
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U1</span>,<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">U2</span><span style="color:#f92672">&gt;</span>
    pair(<span style="color:#66d9ef">const</span> pair<span style="color:#f92672">&lt;</span>U1,U2<span style="color:#f92672">&gt;&amp;</span> p){
        <span style="color:#75715e">// U1,U2要满足的条件
</span><span style="color:#75715e"></span>        first(p.first),second(p.second);
    }
};

pair<span style="color:#f92672">&lt;</span>Base1,Base2<span style="color:#f92672">&gt;</span> p2(pair<span style="color:#f92672">&lt;</span>Derived1,Derived2<span style="color:#f92672">&gt;</span>());
</code></pre></div><h3 id="模板特化">模板特化</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 泛化
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Key</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">hash</span> {};

<span style="color:#75715e">// 特化1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">hash</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">char</span><span style="color:#f92672">&gt;</span> {
	<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>	size_t <span style="color:#a6e22e">operator</span>() (<span style="color:#66d9ef">char</span> x) <span style="color:#66d9ef">const</span> { <span style="color:#66d9ef">return</span> x;}
}

<span style="color:#75715e">// 特化2
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">hash</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> {
	<span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>	size_t <span style="color:#a6e22e">operator</span>() (<span style="color:#66d9ef">int</span> x) <span style="color:#66d9ef">const</span> (<span style="color:#66d9ef">return</span> x;)
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    cout<span style="color:#f92672">&lt;&lt;</span> hash<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>()<span style="color:#75715e">/*调用特化2 operator()*/</span>(<span style="color:#ae81ff">100</span>)<span style="color:#75715e">/* init parm*/</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}
</code></pre></div><h3 id="模板偏特化">模板偏特化</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T,<span style="color:#66d9ef">typename</span> Alloc<span style="color:#f92672">=</span>...<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">vector</span>
{
    <span style="color:#75715e">//...
</span><span style="color:#75715e"></span>};
<span style="color:#75715e">//将T绑定到bool
</span><span style="color:#75715e"></span><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> Alloc<span style="color:#f92672">=</span>...<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">vector</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span>, Alloc<span style="color:#f92672">&gt;</span>
{
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="模板模板参数">模板模板参数</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T,
		<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
			<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Container</span>
        <span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">XCls</span>
{
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    Container<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> c;
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#75715e">// ...
</span><span style="color:#75715e"></span>};

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">using</span> Lst <span style="color:#f92672">=</span> list<span style="color:#f92672">&lt;</span>T, allocator<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>;

<span style="color:#75715e">/* WRONG */</span> XCls<span style="color:#f92672">&lt;</span>string,list<span style="color:#f92672">&gt;</span> mylist1; <span style="color:#75715e">// list未绑定
</span><span style="color:#75715e"></span><span style="color:#75715e">/* RIGHT */</span> XCls<span style="color:#f92672">&lt;</span>string,Lst<span style="color:#f92672">&gt;</span> mylist2; <span style="color:#75715e">// Lst仍然是一个类模板
</span></code></pre></div><p>下面这个不是模板模板参数</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>,<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Seqence</span> <span style="color:#f92672">=</span> deque<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;&gt;</span>
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">stack</span> {
    <span style="color:#66d9ef">friend</span> <span style="color:#66d9ef">bool</span> <span style="color:#66d9ef">operator</span><span style="color:#f92672">==</span> <span style="color:#f92672">&lt;&gt;</span> (<span style="color:#66d9ef">const</span> stack<span style="color:#f92672">&amp;</span>,<span style="color:#66d9ef">const</span> statck<span style="color:#f92672">&amp;</span>);
<span style="color:#66d9ef">protected</span><span style="color:#f92672">:</span>
    Sequence c;
};

stack<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,list<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> s2; <span style="color:#75715e">// list的类型已经绑定
</span></code></pre></div><h3 id="vptr--vtbl">vptr &amp;&amp; vtbl</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> vfunc1();
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">vfunc2</span>();
<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">int</span> m_data1,m_data2;
};


<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> A{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">void</span> vfunc1(); <span style="color:#75715e">// override
</span><span style="color:#75715e"></span>};
</code></pre></div><p>当某个类具有虚函数的时候，那么其生成的类就会有一个指针，会指向一个虚函数表，这个指针就是vptr。虚函数表就是vtbl。</p>
<h3 id="c动态绑定">C++动态绑定</h3>
<p>静态绑定的形式</p>
<ol>
<li><code>call xxx</code> ，其中xxx是地址。</li>
</ol>
<p>动态绑定的条件</p>
<ol>
<li>通过指针调用。包括this指针。</li>
<li>有向上转型的动作。</li>
<li>调用虚函数。</li>
</ol>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// B继承A
</span><span style="color:#75715e"></span>A<span style="color:#f92672">*</span> pa <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> B;
pa<span style="color:#f92672">-&gt;</span>vfunc1(); <span style="color:#75715e">//vfunc1是虚函数
</span></code></pre></div><h3 id="new--delete操作符重载">new &amp;&amp; delete操作符重载</h3>
<p>全局性重载，影响层面极广</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">myAlloc</span>(size_t size){
	<span style="color:#66d9ef">return</span> malloc(size);
}
<span style="color:#75715e">// 全局性重载1，影响层面极广
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#a6e22e">myfree</span>(<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> ptr){
	<span style="color:#66d9ef">return</span> free(ptr);
}

<span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#a6e22e">new</span>(size_t size){
	cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;my global new()&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;
	<span style="color:#66d9ef">return</span> myAlloc(size);
}
</code></pre></div><p>重载成员函数中的<code>new,delete,new[],delete[]</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Foo</span>{
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>[] (size_t);
    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">delete</span>[](<span style="color:#66d9ef">void</span><span style="color:#f92672">*</span>, size_t);
};

<span style="color:#66d9ef">try</span>{
    <span style="color:#75715e">// 下面的1处
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">void</span><span style="color:#f92672">*</span> mem <span style="color:#f92672">=</span> <span style="color:#66d9ef">operator</span> <span style="color:#66d9ef">new</span>(<span style="color:#66d9ef">sizeof</span>(Foo)<span style="color:#f92672">*</span>N<span style="color:#f92672">+</span><span style="color:#ae81ff">4</span>);
    p <span style="color:#f92672">=</span> <span style="color:#66d9ef">static_cast</span><span style="color:#f92672">&lt;</span>Foo<span style="color:#f92672">*&gt;</span>(mem);
    p<span style="color:#f92672">-&gt;</span>Foo<span style="color:#f92672">::</span>Foo(); <span style="color:#75715e">// N次
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(){
    <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>    Foo<span style="color:#f92672">*</span> p <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Foo[N];
}
</code></pre></div><h3 id="c虚函数">C++虚函数</h3>
<p>基类的析构函数一定要写成虚函数，这样当进行多态调用的时候，才会执行基类的虚函数。</p>
<h3 id="容器适配器">容器适配器</h3>
<p>C++ 提供了三种容器适配器(contain adapter):
stack, queue, priority_queue。</p>
<ol>
<li>stack和queue基于deque实现</li>
<li>priority_queue基于vector实现</li>
</ol>
<p>容器适配器的作用大概类似于电源适配器，将标准电压转化成各种需要的电压。</p>
<p>你完全可以在deque上按照stack的方式工作，但是deque太强大了，它提供了远超stack的操作所需的各种接口
但凡你有一个失误，创建的栈就毁了。</p>
<h1 id="如何理解c多态">如何理解C++多态？</h1>
<h3 id="多态的意义">多态的意义：</h3>
<p>多态是面向对象的三大特性之一。</p>
<p>面向对象的三大特性分别是：封装，继承，多态。</p>
<h3 id="多态的条件">多态的条件：</h3>
<ol>
<li>继承</li>
<li>重写父类方法</li>
</ol>
<h3 id="多态的本质">多态的本质：</h3>
<p>多态：不同的子类调用相同的父类方法，产生不同的结果。函数有多个状态，即为多态。</p>
<p>面向对象程序设计的一个重要特性是多态性，复习理解下C++ 是如何支持多态的。
接下来会涉及基类、派生类、虚函数、纯虚函数、抽象类的概念。</p>
<p>C++ 的类继承中，被继承者被称为基类（base class），继承者被称为派生类（derived class）。指向派生类的指针类型与指向基类的指针类型是兼容的（反之不成立！）。这个简单的特性是C++ 多态性的基础。
(注意：可以用基类类型指针指向派生类类型的实例，反之不然）</p>
<p>1，虚函数
我们面对一个问题：使用基类类型指针去引用派生类的成员时，这些成员必须也在基类中定义过。然而，一个基类的多个不同的派生类，对“同一个”成员函数的实现很可能是不一样的，因此，我们无法直接在基类中实现该成员函数。例如，对于基类“多边形”，派生类“正方形” 和 “三角形“对于成员函数”求面积“的实现是不同的。</p>
]]></content>
        </item>
        
        <item>
            <title>剪绳子问题</title>
            <link>https://oxygenbytes.github.io/posts/2019/04/%E5%89%AA%E7%BB%B3%E5%AD%90%E9%97%AE%E9%A2%98/</link>
            <pubDate>Fri, 05 Apr 2019 00:00:00 +0000</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/2019/04/%E5%89%AA%E7%BB%B3%E5%AD%90%E9%97%AE%E9%A2%98/</guid>
            <description>题目描述  给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&amp;gt;1并且m&amp;gt;1），每段绳子的长度记为k[0],k[1],&amp;hellip;,k[m]。请问k[0]xk[1]x&amp;hellip;xk[m]可能的最大乘积是多少？
 例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。
  题目分析 要让最大乘积最大，则当n &amp;gt; 5时，使用尽可能多的3。
贪心算法  数学分析  $$ \begin{matrix} if\space x\%3 &amp;amp;numOf2 &amp;amp;numOf3\newline \space\space 0 &amp;amp; 0 &amp;amp; x/3\newline \space\space 1 &amp;amp; 2 &amp;amp; x/3-1\newline \space\space 2 &amp;amp; 1&amp;amp; x/3\newline \end{matrix} $$
实现代码 public int cutRope2(int target) { if (target &amp;lt; 2) return 0; if (target == 2) return 1; if (target == 3) return 2; int numOf3 = target / 3; int numOf2 = 0; if (target % 3 == 1) { numOf3--; numOf2 = 2; } if(target % 3 == 2){ numOf2 = 1; } // int numOf2 = (target - numOf3*3) / 2;  return (int) (Math.</description>
            <content type="html"><![CDATA[<h3 id="题目描述">题目描述</h3>
<blockquote>
<p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],&hellip;,k[m]。请问k[0]xk[1]x&hellip;xk[m]可能的最大乘积是多少？</p>
<blockquote>
<p>例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
</blockquote>
</blockquote>
<h3 id="题目分析">题目分析</h3>
<p>要让最大乘积最大，则当n &gt; 5时，使用尽可能多的3。</p>
<h3 id="贪心算法">贪心算法</h3>
<ul>
<li>数学分析</li>
</ul>
<p>$$
\begin{matrix}
if\space x\%3 &amp;numOf2 &amp;numOf3\newline
\space\space 0 &amp; 0 &amp; x/3\newline
\space\space 1 &amp; 2 &amp; x/3-1\newline
\space\space 2 &amp; 1&amp; x/3\newline
\end{matrix}
$$</p>
<h4 id="实现代码">实现代码</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cutRope2</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>target <span style="color:#f92672">&lt;</span> 2<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>target <span style="color:#f92672">==</span> 2<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> 1<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>target <span style="color:#f92672">==</span> 3<span style="color:#f92672">)</span>
        <span style="color:#66d9ef">return</span> 2<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">int</span> numOf3 <span style="color:#f92672">=</span> target <span style="color:#f92672">/</span> 3<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">int</span> numOf2 <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>target <span style="color:#f92672">%</span> 3 <span style="color:#f92672">==</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        numOf3<span style="color:#f92672">--;</span>
        numOf2 <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>target <span style="color:#f92672">%</span> 3 <span style="color:#f92672">==</span> 2<span style="color:#f92672">){</span>
        numOf2 <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
    <span style="color:#75715e">//  int numOf2 = (target -  numOf3*3) / 2;
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">return</span> <span style="color:#f92672">(</span><span style="color:#66d9ef">int</span><span style="color:#f92672">)</span> <span style="color:#f92672">(</span>Math<span style="color:#f92672">.</span><span style="color:#a6e22e">pow</span><span style="color:#f92672">(</span>2<span style="color:#f92672">,</span> numOf2<span style="color:#f92672">)</span> <span style="color:#f92672">*</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">pow</span><span style="color:#f92672">(</span>3<span style="color:#f92672">,</span> numOf3<span style="color:#f92672">));</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="递推算法">递推算法</h3>
<h4 id="数学分析">数学分析</h4>
<p>$$
f(n)=
\begin{cases}
f(n-3), &amp; \text{if $n$ &gt; 6}\newline
[1,2,4,6],&amp; \text{if n = 2,3,4,5}
\end{cases}
$$</p>
<h4 id="实现代码-1">实现代码</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cutRope</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> 60<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">int</span><span style="color:#f92672">[]</span> dp <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">[</span>n<span style="color:#f92672">+</span>1<span style="color:#f92672">];</span>
        dp<span style="color:#f92672">[</span>2<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 1<span style="color:#f92672">;</span>dp<span style="color:#f92672">[</span>3<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 2<span style="color:#f92672">;</span>
        dp<span style="color:#f92672">[</span>4<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 4<span style="color:#f92672">;</span>dp<span style="color:#f92672">[</span>5<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 6<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">for</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> 6<span style="color:#f92672">;</span>i <span style="color:#f92672">&lt;=</span> 60<span style="color:#f92672">;</span>i<span style="color:#f92672">++){</span>
            dp<span style="color:#f92672">[</span>i<span style="color:#f92672">]</span> <span style="color:#f92672">=</span> 3 <span style="color:#f92672">*</span> dp<span style="color:#f92672">[</span>i<span style="color:#f92672">-</span>3<span style="color:#f92672">];</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> dp<span style="color:#f92672">[</span>target<span style="color:#f92672">];</span>
<span style="color:#f92672">}</span>
</code></pre></div><h3 id="递归算法">递归算法</h3>
<h4 id="数学分析-1">数学分析</h4>
<p>$$
f(n)=
\begin{cases}
f(n-3), &amp; \text{if $n$ &gt; 6}\newline
[1,2,4,6],&amp; \text{if n = 2,3,4,5}
\end{cases}
$$</p>
<h4 id="实现代码-2">实现代码</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> <span style="color:#f92672">{</span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cutRope</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> target<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>target <span style="color:#f92672">==</span> 2<span style="color:#f92672">)</span>
                <span style="color:#66d9ef">return</span> 1<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>target <span style="color:#f92672">==</span> 3<span style="color:#f92672">)</span>
                <span style="color:#66d9ef">return</span> 2<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>target <span style="color:#f92672">==</span> 4<span style="color:#f92672">)</span>
                <span style="color:#66d9ef">return</span> 4<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span><span style="color:#f92672">(</span>target <span style="color:#f92672">==</span> 5<span style="color:#f92672">)</span>
                <span style="color:#66d9ef">return</span> 6<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">return</span> cutRope<span style="color:#f92672">(</span>target <span style="color:#f92672">-</span> 3<span style="color:#f92672">)</span> <span style="color:#f92672">*</span> 3<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
<span style="color:#f92672">}</span>
</code></pre></div>]]></content>
        </item>
        
        <item>
            <title>校招经验总结</title>
            <link>https://oxygenbytes.github.io/posts/1/01/%E6%A0%A1%E6%8B%9B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</link>
            <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
            
            <guid>https://oxygenbytes.github.io/posts/1/01/%E6%A0%A1%E6%8B%9B%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/</guid>
            <description>昨天大学室友打算跑路，不想在北京干了，聚了一下，中间聊了下找工作的事情。巧合的是晚上有个大学认识的同学也来问。心血来潮总结一下。仅仅针对互联网技术相关岗位。
1. 选一个岗位 岗位可以分为技术岗和非技术岗，技术岗基本可以分为前端，后端，客户端，测试，数据，算法。考虑岗位，兴趣第一，发展第二， 薪资第三。非技术岗很多，产品经历，运营等等很多，可以搜索一下。
2. 选定一门语言 对于技术岗来说，是需要掌握一门编程语言的，前端毫无疑问就是Js， 后端的话可以在Java，C++， Go选择一门，其他岗位各有要求，可以看看岗位JD。 除了掌握一门语言外，建议主力静态语言的学一门动态语言，主力动态语言的学一门静态语言，扩展自己对编程语言的眼界。
3. 学习语言的语法，标准库，语言特性。 以Go语言为例，需要学习其并发，协程，GC等知识。
4. 存储 想做后端，数据，需要学习存储知识。从层级来分，建议从下到上学习文件系统，磁盘数据库MySQL， 内存缓存Redis，还可以看看消息队列Kafka等。
5. 学习计算机基础 网络，操作系统，数据结构，组成原理，编译原理等计算机原理是非常重要的。
6. 刷题 刷算法题，大量，熟练，题海中保持冷静思考
7. 面经 面经是面试的重点，建议从面经出发，完善知识体系。
8. 好好写简历 简历是面试的提纲， 重点突出，少搞花活。
9. 保持良好的心态 找工作是很看运气的，保持良好的心态，不断更新自己的知识体系，坚持到最后一秒不要放弃</description>
            <content type="html"><![CDATA[<p>昨天大学室友打算跑路，不想在北京干了，聚了一下，中间聊了下找工作的事情。巧合的是晚上有个大学认识的同学也来问。心血来潮总结一下。仅仅针对互联网技术相关岗位。</p>
<h2 id="1-选一个岗位">1. 选一个岗位</h2>
<p>岗位可以分为技术岗和非技术岗，技术岗基本可以分为前端，后端，客户端，测试，数据，算法。考虑岗位，兴趣第一，发展第二， 薪资第三。非技术岗很多，产品经历，运营等等很多，可以搜索一下。</p>
<h2 id="2-选定一门语言">2. 选定一门语言</h2>
<p>对于技术岗来说，是需要掌握一门编程语言的，前端毫无疑问就是Js， 后端的话可以在Java，C++， Go选择一门，其他岗位各有要求，可以看看岗位JD。
除了掌握一门语言外，建议主力静态语言的学一门动态语言，主力动态语言的学一门静态语言，扩展自己对编程语言的眼界。</p>
<h2 id="3-学习语言的语法标准库语言特性">3. 学习语言的语法，标准库，语言特性。</h2>
<p>以Go语言为例，需要学习其并发，协程，GC等知识。</p>
<h2 id="4-存储">4. 存储</h2>
<p>想做后端，数据，需要学习存储知识。从层级来分，建议从下到上学习文件系统，磁盘数据库MySQL， 内存缓存Redis，还可以看看消息队列Kafka等。</p>
<h2 id="5-学习计算机基础">5. 学习计算机基础</h2>
<p>网络，操作系统，数据结构，组成原理，编译原理等计算机原理是非常重要的。</p>
<h2 id="6-刷题">6. 刷题</h2>
<p>刷算法题，大量，熟练，题海中保持冷静思考</p>
<h2 id="7-面经">7. 面经</h2>
<p>面经是面试的重点，建议从面经出发，完善知识体系。</p>
<h2 id="8-好好写简历">8. 好好写简历</h2>
<p>简历是面试的提纲， 重点突出，少搞花活。</p>
<h2 id="9-保持良好的心态">9. 保持良好的心态</h2>
<p>找工作是很看运气的，保持良好的心态，不断更新自己的知识体系，坚持到最后一秒不要放弃</p>
]]></content>
        </item>
        
    </channel>
</rss>
