<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SwordOffer on Zxq&#39;s Blog</title>
    <link>https://oxygenbytes.github.io/tags/swordoffer/</link>
    <description>Recent content in SwordOffer on Zxq&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <copyright>&lt;a href=&#34;https://oxygenbytes.github.io/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;cd /home/zxq/&lt;/a&gt;</copyright>
    <lastBuildDate>Thu, 18 Feb 2021 11:49:40 +0800</lastBuildDate><atom:link href="https://oxygenbytes.github.io/tags/swordoffer/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[剑指 Offer 68 - II]二叉树的最近公共祖先</title>
      <link>https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-68-ii%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Thu, 18 Feb 2021 11:49:40 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-68-ii%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>//给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 // // 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（ //一个节点也可以是它自己的祖先）。” // // 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] // // // // // // 示例 1: // // 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 //输出: 3 //解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 // // // 示例 2: // // 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 //输出: 5 //解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 // // // // // 说明: // // // 所有节点的值都是唯一的。 // p、q 为不同节点且均存在于给定的二叉树中。 // // // 注意：本题与主站 236 题相同：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>[剑指 Offer 68 - I]二叉搜索树的最近公共祖先</title>
      <link>https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-68-i%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Thu, 18 Feb 2021 11:49:18 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-68-i%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>//给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 // // 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（ //一个节点也可以是它自己的祖先）。” // // 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] // // // // // // 示例 1: // // 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 //输出: 6 //解释: 节点 2 和节点 8 的最近公共祖先是 6。 // // // 示例 2: // // 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 //输出: 2 //解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 // // // // 说明: // // // 所有节点的值都是唯一的。 // p、q 为不同节点且均存在于给定的二叉搜索树中。 // // // 注意：本题与主站 235 题相同：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>[剑指 Offer 67]把字符串转换成整数</title>
      <link>https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-67%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</link>
      <pubDate>Thu, 18 Feb 2021 11:49:02 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-67%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</guid>
      <description>//写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。 // // // // 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。 // // 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连 //续的数字字符组合起来，形成整数。 // // 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。 // // 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。 // // 在任何情况下，若函数不能进行有效的转换时，请返回 0。 // // 说明： // // 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−231, 231 − 1]。如果数值超过这个范围，请返回 INT_MAX (231 // − 1) 或 INT_MIN (−231) 。 // // 示例 1: // // 输入: &amp;#34;42&amp;#34; //输出: 42 // // // 示例 2: // // 输入: &amp;#34; -42&amp;#34; //输出: -42 //解释: 第一个非空白字符为 &amp;#39;-&amp;#39;, 它是一个负号。 // 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。 // // // 示例 3: // // 输入: &amp;#34;4193 with words&amp;#34; //输出: 4193 //解释: 转换截止于数字 &amp;#39;3&amp;#39; ，因为它的下一个字符不为数字。 // // // 示例 4: // // 输入: &amp;#34;words and 987&amp;#34; //输出: 0 //解释: 第一个非空字符是 &amp;#39;w&amp;#39;, 但它不是数字或正、负号。 // 因此无法执行有效的转换。 // // 示例 5: // // 输入: &amp;#34;-91283472332&amp;#34; //输出: -2147483648 //解释: 数字 &amp;#34;-91283472332&amp;#34; 超过 32 位有符号整数范围。 // 因此返回 INT_MIN (−231) 。 // // // // // 注意：本题与主站 8 题相同：https://leetcode-cn.</description>
    </item>
    
    <item>
      <title>[剑指 Offer 66]构建乘积数组</title>
      <link>https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-66%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</link>
      <pubDate>Thu, 18 Feb 2021 11:48:44 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-66%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</guid>
      <description>//给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积, 即 B[ //i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。不能使用除法。 // // // // 示例: // // //输入: [1,2,3,4,5] //输出: [120,60,40,30,24] // // // // 提示： // // // 所有元素乘积之和不会溢出 32 位整数 // a.length &amp;lt;= 100000 // // 👍 79 👎 0  /* * 剑指 Offer 66 构建乘积数组 * 2021-02-18 11:48:44 * @author oxygenbytes */ #include &amp;#34;leetcode.h&amp;#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: vector&amp;lt;int&amp;gt; constructArr(vector&amp;lt;int&amp;gt;&amp;amp; a) { if(a.</description>
    </item>
    
    <item>
      <title>[剑指 Offer 64]求1&#43;2&#43;…&#43;n</title>
      <link>https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-64%E6%B1%821&#43;2&#43;&#43;n/</link>
      <pubDate>Thu, 18 Feb 2021 11:48:19 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-64%E6%B1%821&#43;2&#43;&#43;n/</guid>
      <description>//求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 // // // // 示例 1： // // 输入: n = 3 //输出: 6 // // // 示例 2： // // 输入: n = 9 //输出: 45 // // // // // 限制： // // // 1 &amp;lt;= n &amp;lt;= 10000 // // 👍 267 👎 0  /* * 剑指 Offer 64 求1+2+…+n * 2021-02-18 11:48:19 * @author oxygenbytes */ #include &amp;#34;leetcode.h&amp;#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int sumNums(int n) { if(n == 1) return 1; else return sumNums((n-1)) + n; } }; //leetcode submit region end(Prohibit modification and deletion)  </description>
    </item>
    
    <item>
      <title>[剑指 Offer 65]不用加减乘除做加法</title>
      <link>https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-65%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</link>
      <pubDate>Thu, 18 Feb 2021 11:48:18 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/swordoffer/%E5%89%91%E6%8C%87-offer-65%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</guid>
      <description>//写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。 // // // // 示例: // // 输入: a = 1, b = 1 //输出: 2 // // // // 提示： // // // a, b 均可能是负数或 0 // 结果不会溢出 32 位整数 // // 👍 117 👎 0  /* * 剑指 Offer 65 不用加减乘除做加法 * 2021-02-18 11:48:18 * @author oxygenbytes */ #include &amp;#34;leetcode.h&amp;#34; //leetcode submit region begin(Prohibit modification and deletion) class Solution { public: int add(int a, int b) { int result = 0; int carry = 0; // + is not allowed to use  // a + b == result + carry , so if b == 0, a is the ans;  while(b){ result = a ^ b; // [ref]:https://www.</description>
    </item>
    
  </channel>
</rss>
