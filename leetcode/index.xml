<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Leetcodes on Zxq&#39;s Site</title>
    <link>https://oxygenbytes.github.io/leetcode/</link>
    <description>Recent content in Leetcodes on Zxq&#39;s Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-en</language>
    <lastBuildDate>Mon, 14 Jun 2021 14:13:48 +0800</lastBuildDate><atom:link href="https://oxygenbytes.github.io/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[63]不同路径 II</title>
      <link>https://oxygenbytes.github.io/leetcode/dp/63%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-ii-/</link>
      <pubDate>Mon, 14 Jun 2021 14:13:48 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/dp/63%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-ii-/</guid>
      <description>//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 // // 机器人每次只能向下或者向右移动一步。机器人试图达到网格的</description>
    </item>
    
    <item>
      <title>[96]不同的二叉搜索树</title>
      <link>https://oxygenbytes.github.io/leetcode/dp/96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-/</link>
      <pubDate>Mon, 14 Jun 2021 14:03:03 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/dp/96%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-/</guid>
      <description>//给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 // // // // 示例 1： // // //</description>
    </item>
    
    <item>
      <title>[200]岛屿数量</title>
      <link>https://oxygenbytes.github.io/leetcode/dfs/200%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-/</link>
      <pubDate>Mon, 14 Jun 2021 13:07:54 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/dfs/200%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F-/</guid>
      <description>//给你一个由 &amp;#39;1&amp;#39;（陆地）和 &amp;#39;0&amp;#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 // // 岛屿总是被水包围，</description>
    </item>
    
    <item>
      <title>[735]行星碰撞</title>
      <link>https://oxygenbytes.github.io/leetcode/stack/735%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E-/</link>
      <pubDate>Sun, 13 Jun 2021 18:37:15 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/stack/735%E8%A1%8C%E6%98%9F%E7%A2%B0%E6%92%9E-/</guid>
      <description>//给定一个整数数组 asteroids，表示在同一行的行星。 // // 对于数组中的每一个元素，其绝对值表示行星的大小，正负表示行星的移动方向（正表</description>
    </item>
    
    <item>
      <title>[739]每日温度</title>
      <link>https://oxygenbytes.github.io/leetcode/stack/739%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-/</link>
      <pubDate>Sun, 13 Jun 2021 18:08:44 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/stack/739%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6-/</guid>
      <description>//请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置</description>
    </item>
    
    <item>
      <title>[33]搜索旋转排序数组</title>
      <link>https://oxygenbytes.github.io/leetcode/binarysearch/33-ii%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-/</link>
      <pubDate>Sat, 12 Jun 2021 19:49:19 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/binarysearch/33-ii%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84-/</guid>
      <description>//整数数组 nums 按升序排列，数组中的值 互不相同 。 // // 在传递给函数之前，nums 在预先未知的某个下标 k（0 &amp;lt;= k &amp;lt; nums.length）上进行了</description>
    </item>
    
    <item>
      <title>[153]寻找旋转排序数组中的最小值</title>
      <link>https://oxygenbytes.github.io/leetcode/binarysearch/153-ii%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-/</link>
      <pubDate>Sat, 12 Jun 2021 19:39:39 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/binarysearch/153-ii%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC-/</guid>
      <description>//已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变 //化后可能得到： // // 若旋转 4 次，则可</description>
    </item>
    
    <item>
      <title>[34]在排序数组中查找元素的第一个和最后一个位置</title>
      <link>https://oxygenbytes.github.io/leetcode/binarysearch/34-ii%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-/</link>
      <pubDate>Sat, 12 Jun 2021 19:26:39 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/binarysearch/34-ii%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-/</guid>
      <description>//给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 // // 如果数组中不存在目标值</description>
    </item>
    
    <item>
      <title>[35]搜索插入位置</title>
      <link>https://oxygenbytes.github.io/leetcode/binarysearch/35-ii%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-/</link>
      <pubDate>Sat, 12 Jun 2021 19:20:09 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/binarysearch/35-ii%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-/</guid>
      <description>//给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 // // 你可以假设数</description>
    </item>
    
    <item>
      <title>[69]x 的平方根</title>
      <link>https://oxygenbytes.github.io/leetcode/binarysearch/69-iix-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-/</link>
      <pubDate>Sat, 12 Jun 2021 19:07:35 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/binarysearch/69-iix-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9-/</guid>
      <description>//实现 int sqrt(int x) 函数。 // // 计算并返回 x 的平方根，其中 x 是非负整数。 // // 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 // // 示例 1: //</description>
    </item>
    
    <item>
      <title>[80]删除有序数组中的重复项 II</title>
      <link>https://oxygenbytes.github.io/leetcode/stack/80%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-ii-/</link>
      <pubDate>Sat, 12 Jun 2021 14:44:00 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/stack/80%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-ii-/</guid>
      <description>//给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 最多出现两次 ，返回删除后数组的新长度。 // // 不要使用额外的数组空间，你必须在 原地</description>
    </item>
    
    <item>
      <title>[283]移动零</title>
      <link>https://oxygenbytes.github.io/leetcode/doublepointers/283-ii%E7%A7%BB%E5%8A%A8%E9%9B%B6-/</link>
      <pubDate>Sat, 12 Jun 2021 14:43:50 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/doublepointers/283-ii%E7%A7%BB%E5%8A%A8%E9%9B%B6-/</guid>
      <description>//给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 // // 示例: // // 输入: [0,1,0,3,12] //输出: [1,3,12,0,0] // // 说明: // //</description>
    </item>
    
    <item>
      <title>[42]接雨水</title>
      <link>https://oxygenbytes.github.io/leetcode/doublepointers/42-ii%E6%8E%A5%E9%9B%A8%E6%B0%B4-/</link>
      <pubDate>Sat, 12 Jun 2021 14:43:45 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/doublepointers/42-ii%E6%8E%A5%E9%9B%A8%E6%B0%B4-/</guid>
      <description>//给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 // // // // 示例 1： // // // // //输入：height</description>
    </item>
    
    <item>
      <title>[11]盛最多水的容器</title>
      <link>https://oxygenbytes.github.io/leetcode/doublepointers/11-ii%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-/</link>
      <pubDate>Sat, 12 Jun 2021 14:43:40 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/doublepointers/11-ii%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8-/</guid>
      <description>//给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, //ai) 和 (i, 0) 。找出其</description>
    </item>
    
    <item>
      <title>[26]删除有序数组中的重复项</title>
      <link>https://oxygenbytes.github.io/leetcode/doublepointers/26-ii%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-/</link>
      <pubDate>Sat, 12 Jun 2021 14:34:45 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/doublepointers/26-ii%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-/</guid>
      <description>//给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。 // // 不要使用额外的数组空间，你必须在 原地 修</description>
    </item>
    
    <item>
      <title>[344]反转字符串</title>
      <link>https://oxygenbytes.github.io/leetcode/doublepointers/344%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-/</link>
      <pubDate>Sat, 12 Jun 2021 14:31:58 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/doublepointers/344%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-/</guid>
      <description>//编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 // // 不要给另外的数组分配额外的空间，你必须原地修改输入数</description>
    </item>
    
    <item>
      <title>[84]柱状图中最大的矩形</title>
      <link>https://oxygenbytes.github.io/leetcode/stack/84%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-/</link>
      <pubDate>Fri, 11 Jun 2021 21:17:57 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/stack/84%E6%9F%B1%E7%8A%B6%E5%9B%BE%E4%B8%AD%E6%9C%80%E5%A4%A7%E7%9A%84%E7%9F%A9%E5%BD%A2-/</guid>
      <description>//给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 // // 求在该柱状图中，能够勾勒出来的矩形的最大面积。 // // //</description>
    </item>
    
    <item>
      <title>[114]二叉树展开为链表</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/114%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8-/</link>
      <pubDate>Fri, 11 Jun 2021 21:08:58 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/114%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8-/</guid>
      <description>//给你二叉树的根结点 root ，请你将它展开为一个单链表： // // // 展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null</description>
    </item>
    
    <item>
      <title>[139]单词拆分</title>
      <link>https://oxygenbytes.github.io/leetcode/139-ii%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-/</link>
      <pubDate>Fri, 11 Jun 2021 20:47:22 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/139-ii%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86-/</guid>
      <description>//给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 // // 说明： // // // 拆</description>
    </item>
    
    <item>
      <title>[75]颜色分类</title>
      <link>https://oxygenbytes.github.io/leetcode/75%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-/</link>
      <pubDate>Fri, 11 Jun 2021 20:37:01 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/75%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB-/</guid>
      <description>//给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。 // // 此题中</description>
    </item>
    
    <item>
      <title>[470]用 Rand7() 实现 Rand10()</title>
      <link>https://oxygenbytes.github.io/leetcode/470-ii%E7%94%A8-rand7-%E5%AE%9E%E7%8E%B0-rand10-/</link>
      <pubDate>Fri, 11 Jun 2021 20:19:42 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/470-ii%E7%94%A8-rand7-%E5%AE%9E%E7%8E%B0-rand10-/</guid>
      <description>//已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。 // // 不要使用系统的 Math.random() 方法。 // // // // // // // 示例 1:</description>
    </item>
    
    <item>
      <title>[459]重复的子字符串</title>
      <link>https://oxygenbytes.github.io/leetcode/459%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2-/</link>
      <pubDate>Fri, 11 Jun 2021 19:57:37 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/459%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2-/</guid>
      <description>//给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 // // 示例 1: // //</description>
    </item>
    
    <item>
      <title>[28]实现 strStr()</title>
      <link>https://oxygenbytes.github.io/leetcode/28%E5%AE%9E%E7%8E%B0-strstr-/</link>
      <pubDate>Fri, 11 Jun 2021 17:48:58 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/28%E5%AE%9E%E7%8E%B0-strstr-/</guid>
      <description>//实现 strStr() 函数。 // // 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串出现的第一个位置（下标从 0 开始）。如 //果不存在，则返回 -1 。 // // // // 说</description>
    </item>
    
    <item>
      <title>[10]正则表达式匹配</title>
      <link>https://oxygenbytes.github.io/leetcode/10%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-/</link>
      <pubDate>Fri, 11 Jun 2021 17:07:58 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/10%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D-/</guid>
      <description>//给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &amp;#39;.&amp;#39; 和 &amp;#39;*&amp;#39; 的正则表达式匹配。 // // // &amp;#39;.&amp;#39; 匹配任意单个字符 // &amp;#39;*&amp;#39; 匹配零个或多个前面的那一个元素 //</description>
    </item>
    
    <item>
      <title>[279]完全平方数</title>
      <link>https://oxygenbytes.github.io/leetcode/279-ii%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-/</link>
      <pubDate>Fri, 11 Jun 2021 16:14:31 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/279-ii%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0-/</guid>
      <description>//给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 // // 给你一个整数 n ，返</description>
    </item>
    
    <item>
      <title>[376]摆动序列</title>
      <link>https://oxygenbytes.github.io/leetcode/376%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</link>
      <pubDate>Fri, 19 Mar 2021 13:36:27 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/376%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</guid>
      <description>//如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是</description>
    </item>
    
    <item>
      <title>[45]跳跃游戏 II</title>
      <link>https://oxygenbytes.github.io/leetcode/45%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii/</link>
      <pubDate>Thu, 18 Mar 2021 13:54:50 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/45%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F-ii/</guid>
      <description>//给定一个非负整数数组，你最初位于数组的第一个位置。 // // 数组中的每个元素代表你在该位置可以跳跃的最大长度。 // // 你的目标是使用最少的跳跃次数</description>
    </item>
    
    <item>
      <title>[55]跳跃游戏</title>
      <link>https://oxygenbytes.github.io/leetcode/55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</link>
      <pubDate>Thu, 18 Mar 2021 13:49:38 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/55%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F/</guid>
      <description>//给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 // // 数组中的每个元素代表你在该位置可以跳跃的最大长度。 // // 判断你是否能够到达最后一个</description>
    </item>
    
    <item>
      <title>[455]分发饼干</title>
      <link>https://oxygenbytes.github.io/leetcode/455%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</link>
      <pubDate>Thu, 18 Mar 2021 13:45:28 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/455%E5%88%86%E5%8F%91%E9%A5%BC%E5%B9%B2/</guid>
      <description>//假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 // // 对每个孩子 i，都有一个胃口值 g[i]，这是能让</description>
    </item>
    
    <item>
      <title>[392]判断子序列</title>
      <link>https://oxygenbytes.github.io/leetcode/392%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Thu, 18 Mar 2021 13:36:21 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/392%E5%88%A4%E6%96%AD%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>//给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 // // 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新</description>
    </item>
    
    <item>
      <title>[860]柠檬水找零</title>
      <link>https://oxygenbytes.github.io/leetcode/860%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</link>
      <pubDate>Thu, 18 Mar 2021 13:26:43 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/860%E6%9F%A0%E6%AA%AC%E6%B0%B4%E6%89%BE%E9%9B%B6/</guid>
      <description>//在柠檬水摊上，每一杯柠檬水的售价为 5 美元。 // // 顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。 // // 每位顾客只买一杯柠檬水，然后</description>
    </item>
    
    <item>
      <title>[130]被围绕的区域</title>
      <link>https://oxygenbytes.github.io/leetcode/130%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</link>
      <pubDate>Tue, 16 Mar 2021 18:49:31 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/130%E8%A2%AB%E5%9B%B4%E7%BB%95%E7%9A%84%E5%8C%BA%E5%9F%9F/</guid>
      <description>//给你一个 m x n 的矩阵 board ，由若干字符 &amp;#39;X&amp;#39; 和 &amp;#39;O&amp;#39; ，找到所有被 &amp;#39;X&amp;#39; 围绕的区域，并将这些区域里所有的 &amp;#39;O&amp;#39; 用 &amp;#39;X&amp;#39; 填充 //。 // // // // // 示例 1： // // //输入：b</description>
    </item>
    
    <item>
      <title>[733]图像渲染</title>
      <link>https://oxygenbytes.github.io/leetcode/733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Tue, 16 Mar 2021 18:36:49 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/733%E5%9B%BE%E5%83%8F%E6%B8%B2%E6%9F%93/</guid>
      <description>//有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。 // // 给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列</description>
    </item>
    
    <item>
      <title>[279]完全平方数</title>
      <link>https://oxygenbytes.github.io/leetcode/279%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</link>
      <pubDate>Fri, 12 Mar 2021 15:54:53 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/279%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0/</guid>
      <description>//给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。 // // 给你一个整数 n ，返</description>
    </item>
    
    <item>
      <title>[111]二叉树的最小深度</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/111-ii%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Fri, 12 Mar 2021 15:30:40 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/111-ii%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</guid>
      <description>//给定一个二叉树，找出其最小深度。 // // 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 // // 说明：叶子节点是指没有子节点的节点。 // //</description>
    </item>
    
    <item>
      <title>[371]两整数之和</title>
      <link>https://oxygenbytes.github.io/leetcode/371%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Fri, 12 Mar 2021 15:09:49 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/371%E4%B8%A4%E6%95%B4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>//不使用运算符 + 和 - ，计算两整数 a 、b 之和。 // // 示例 1: // // 输入: a = 1, b = 2 //输出: 3 // // // 示例 2: // // 输入: a = -2, b = 3 //输出: 1 // Related</description>
    </item>
    
    <item>
      <title>[260]只出现一次的数字 III</title>
      <link>https://oxygenbytes.github.io/leetcode/260%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-iii/</link>
      <pubDate>Fri, 12 Mar 2021 15:01:34 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/260%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-iii/</guid>
      <description>//给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。你可以按 任意顺序 返回答案。 //</description>
    </item>
    
    <item>
      <title>[137]只出现一次的数字 II</title>
      <link>https://oxygenbytes.github.io/leetcode/137%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-ii/</link>
      <pubDate>Fri, 12 Mar 2021 14:52:10 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/137%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97-ii/</guid>
      <description>//给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。 // // 说明： // // 你的算法应该具有线</description>
    </item>
    
    <item>
      <title>[476]数字的补数</title>
      <link>https://oxygenbytes.github.io/leetcode/476%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/</link>
      <pubDate>Fri, 12 Mar 2021 14:47:01 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/476%E6%95%B0%E5%AD%97%E7%9A%84%E8%A1%A5%E6%95%B0/</guid>
      <description>//给你一个 正 整数 num ，输出它的补数。补数是对该数的二进制表示取反。 // // // // // // // 示例 1： // // //输入：num = 5 //输出：2 //解释：5 的二</description>
    </item>
    
    <item>
      <title>[136]只出现一次的数字</title>
      <link>https://oxygenbytes.github.io/leetcode/136%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</link>
      <pubDate>Fri, 12 Mar 2021 14:41:42 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/136%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E6%95%B0%E5%AD%97/</guid>
      <description>//给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 // // 说明： // // 你的算法应该具有线性</description>
    </item>
    
    <item>
      <title>[762]二进制表示中质数个计算置位</title>
      <link>https://oxygenbytes.github.io/leetcode/762%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E8%B4%A8%E6%95%B0%E4%B8%AA%E8%AE%A1%E7%AE%97%E7%BD%AE%E4%BD%8D/</link>
      <pubDate>Fri, 12 Mar 2021 14:37:03 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/762%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E8%B4%A8%E6%95%B0%E4%B8%AA%E8%AE%A1%E7%AE%97%E7%BD%AE%E4%BD%8D/</guid>
      <description>//给定两个整数 L 和 R ，找到闭区间 [L, R] 范围内，计算置位位数为质数的整数个数。 // // （注意，计算置位代表二进制表示中1的个数。例如 21 的二进制表示</description>
    </item>
    
    <item>
      <title>[231]2的幂</title>
      <link>https://oxygenbytes.github.io/leetcode/2312%E7%9A%84%E5%B9%82/</link>
      <pubDate>Fri, 12 Mar 2021 14:05:09 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/2312%E7%9A%84%E5%B9%82/</guid>
      <description>//给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 // // 示例 1: // // 输入: 1 //输出: true //解释: 20 = 1 // // 示例 2: // // 输入: 16 //输出: true</description>
    </item>
    
    <item>
      <title>[9]回文数</title>
      <link>https://oxygenbytes.github.io/leetcode/9%E5%9B%9E%E6%96%87%E6%95%B0/</link>
      <pubDate>Mon, 08 Mar 2021 18:38:42 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/9%E5%9B%9E%E6%96%87%E6%95%B0/</guid>
      <description>//给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 // // 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，12</description>
    </item>
    
    <item>
      <title>[128]最长连续序列</title>
      <link>https://oxygenbytes.github.io/leetcode/128%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</link>
      <pubDate>Mon, 08 Mar 2021 16:44:02 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/128%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97/</guid>
      <description>//给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 // // // // 进阶：你可以设计并实现时间复杂度为 O(n) 的</description>
    </item>
    
    <item>
      <title>[32]最长有效括号</title>
      <link>https://oxygenbytes.github.io/leetcode/32%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Sun, 07 Mar 2021 20:40:55 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/32%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7/</guid>
      <description>//给你一个只包含 &amp;#39;(&amp;#39; 和 &amp;#39;)&amp;#39; 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 // // // // // // 示例 1： // // //输入：s = &amp;#34;(()&amp;#34; //输出：2 //解释</description>
    </item>
    
    <item>
      <title>[198]打家劫舍</title>
      <link>https://oxygenbytes.github.io/leetcode/198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</link>
      <pubDate>Sun, 07 Mar 2021 20:36:42 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/198%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D/</guid>
      <description>//你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间</description>
    </item>
    
    <item>
      <title>[240]搜索二维矩阵 II</title>
      <link>https://oxygenbytes.github.io/leetcode/240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-ii/</link>
      <pubDate>Sun, 07 Mar 2021 20:25:20 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/240%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5-ii/</guid>
      <description>//编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性： // // // 每行的元素从左到右升序排列。 // 每列的元素从上到下升序排列</description>
    </item>
    
    <item>
      <title>[162]寻找峰值</title>
      <link>https://oxygenbytes.github.io/leetcode/162%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</link>
      <pubDate>Sun, 07 Mar 2021 19:36:51 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/162%E5%AF%BB%E6%89%BE%E5%B3%B0%E5%80%BC/</guid>
      <description>//峰值元素是指其值大于左右相邻值的元素。 // // 给你一个输入数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任</description>
    </item>
    
    <item>
      <title>[31]下一个排列</title>
      <link>https://oxygenbytes.github.io/leetcode/31%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</link>
      <pubDate>Sun, 07 Mar 2021 10:34:32 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/31%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/</guid>
      <description>//实现获取 下一个排列 的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。 // // 如果不存在下一个更大的排列，则将数字重新排列成最</description>
    </item>
    
    <item>
      <title>[122]买卖股票的最佳时机 II</title>
      <link>https://oxygenbytes.github.io/leetcode/122%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii/</link>
      <pubDate>Sat, 06 Mar 2021 20:51:12 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/122%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-ii/</guid>
      <description>//给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 // // 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买</description>
    </item>
    
    <item>
      <title>[39]组合总和</title>
      <link>https://oxygenbytes.github.io/leetcode/39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</link>
      <pubDate>Sat, 06 Mar 2021 19:59:10 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/39%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C/</guid>
      <description>//给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。 // // candidates 中的数字可以无限制重复被选取。 // // 说明： // // // 所有数</description>
    </item>
    
    <item>
      <title>[4]寻找两个正序数组的中位数</title>
      <link>https://oxygenbytes.github.io/leetcode/4%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</link>
      <pubDate>Sat, 06 Mar 2021 11:42:51 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/4%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</guid>
      <description>//给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 // // // // 示例 1： // // //输入：num</description>
    </item>
    
    <item>
      <title>[48]旋转图像</title>
      <link>https://oxygenbytes.github.io/leetcode/48%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</link>
      <pubDate>Sat, 06 Mar 2021 11:35:24 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/48%E6%97%8B%E8%BD%AC%E5%9B%BE%E5%83%8F/</guid>
      <description>//给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。 // // 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要</description>
    </item>
    
    <item>
      <title>[151]翻转字符串里的单词</title>
      <link>https://oxygenbytes.github.io/leetcode/151-ii%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</link>
      <pubDate>Sat, 06 Mar 2021 11:18:50 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/151-ii%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</guid>
      <description>//给定一个字符串，逐个翻转字符串中的每个单词。 // // 说明： // // // 无空格字符构成一个 单词 。 // 输入字符串可以在前面或者后面包含多余的空格，但是反</description>
    </item>
    
    <item>
      <title>[300]最长递增子序列</title>
      <link>https://oxygenbytes.github.io/leetcode/300-ii%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Thu, 04 Mar 2021 19:43:09 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/300-ii%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>//给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 // // 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺</description>
    </item>
    
    <item>
      <title>[145]二叉树的后序遍历</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 04 Mar 2021 19:32:32 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/145%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>//给定一个二叉树，返回它的 后序 遍历。 // // 示例: // // 输入: [1,null,2,3] // 1 // \ // 2 // / // 3 // //输出: [3,2,1] // // 进阶: 递归算法很简单，你可以通过迭代算法完</description>
    </item>
    
    <item>
      <title>[139]单词拆分</title>
      <link>https://oxygenbytes.github.io/leetcode/139%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</link>
      <pubDate>Thu, 04 Mar 2021 19:11:28 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/139%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86/</guid>
      <description>//给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 // // 说明： // // // 拆</description>
    </item>
    
    <item>
      <title>[814]二叉树剪枝</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/814%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/</link>
      <pubDate>Thu, 04 Mar 2021 19:05:13 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/814%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%AA%E6%9E%9D/</guid>
      <description>//给定二叉树根结点 root ，此外树的每个结点的值要么是 0，要么是 1。 // // 返回移除了所有不包含 1 的子树的原二叉树。 // // ( 节点 X 的子树为 X 本身，以及</description>
    </item>
    
    <item>
      <title>[143]重排链表</title>
      <link>https://oxygenbytes.github.io/leetcode/list/143%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 04 Mar 2021 16:04:59 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/143%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8/</guid>
      <description>//给定一个单链表 L：L0→L1→…→Ln-1→Ln ， //将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→… // // 你不能只是单</description>
    </item>
    
    <item>
      <title>[56]合并区间</title>
      <link>https://oxygenbytes.github.io/leetcode/56%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</link>
      <pubDate>Thu, 04 Mar 2021 15:53:46 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/56%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</guid>
      <description>//以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返 //回一个不重叠的区间数组，该数组需恰好覆盖输入中的所</description>
    </item>
    
    <item>
      <title>[300]最长递增子序列</title>
      <link>https://oxygenbytes.github.io/leetcode/300%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Thu, 04 Mar 2021 14:25:33 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/300%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>//给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 // // 子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺</description>
    </item>
    
    <item>
      <title>[958]二叉树的完全性检验</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/958%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%8C%E5%85%A8%E6%80%A7%E6%A3%80%E9%AA%8C/</link>
      <pubDate>Thu, 04 Mar 2021 14:11:13 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/958%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%8C%E5%85%A8%E6%80%A7%E6%A3%80%E9%AA%8C/</guid>
      <description>//给定一个二叉树，确定它是否是一个完全二叉树。 // // 百度百科中对完全二叉树的定义如下： // // 若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h</description>
    </item>
    
    <item>
      <title>[142]环形链表 II</title>
      <link>https://oxygenbytes.github.io/leetcode/list/142-ii%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii/</link>
      <pubDate>Thu, 04 Mar 2021 13:46:32 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/142-ii%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii/</guid>
      <description>//给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 // // 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链</description>
    </item>
    
    <item>
      <title>[124]二叉树中的最大路径和</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/124%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</link>
      <pubDate>Thu, 04 Mar 2021 13:43:32 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/124%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C/</guid>
      <description>//路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个</description>
    </item>
    
    <item>
      <title>[234]回文链表</title>
      <link>https://oxygenbytes.github.io/leetcode/list/234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Thu, 04 Mar 2021 12:48:36 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/234%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8/</guid>
      <description>//请判断一个链表是否为回文链表。 // // 示例 1: // // 输入: 1-&amp;gt;2 //输出: false // // 示例 2: // // 输入: 1-&amp;gt;2-&amp;gt;2-&amp;gt;1 //输出: true // // // 进阶： //你能否用 O(n) 时间复杂度和</description>
    </item>
    
    <item>
      <title>[200]岛屿数量</title>
      <link>https://oxygenbytes.github.io/leetcode/200%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</link>
      <pubDate>Thu, 04 Mar 2021 12:40:11 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/200%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</guid>
      <description>//给你一个由 &amp;#39;1&amp;#39;（陆地）和 &amp;#39;0&amp;#39;（水）组成的的二维网格，请你计算网格中岛屿的数量。 // // 岛屿总是被水包围，</description>
    </item>
    
    <item>
      <title>[41]缺失的第一个正数</title>
      <link>https://oxygenbytes.github.io/leetcode/41%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</link>
      <pubDate>Thu, 04 Mar 2021 12:17:27 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/41%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</guid>
      <description>//给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 // // // // 进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方</description>
    </item>
    
    <item>
      <title>[113]路径总和 II</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-ii/</link>
      <pubDate>Thu, 04 Mar 2021 12:04:31 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/113%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-ii/</guid>
      <description>//给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 // // 叶子节点 是指没有子节点的节点。 // // //</description>
    </item>
    
    <item>
      <title>[26]删除排序数组中的重复项</title>
      <link>https://oxygenbytes.github.io/leetcode/list/26%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</link>
      <pubDate>Wed, 03 Mar 2021 15:19:19 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/26%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9/</guid>
      <description>//给定一个排序数组，你需要在 原地 删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 // // 不要使用额外的数组空间，你必须在 原</description>
    </item>
    
    <item>
      <title>[88]合并两个有序数组</title>
      <link>https://oxygenbytes.github.io/leetcode/88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 03 Mar 2021 15:04:34 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/88%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>//给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。 // // 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间</description>
    </item>
    
    <item>
      <title>[167]两数之和 II - 输入有序数组</title>
      <link>https://oxygenbytes.github.io/leetcode/167%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-ii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 03 Mar 2021 14:29:36 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/167%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-ii-%E8%BE%93%E5%85%A5%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>//给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。 // // 函数应该以长度为 2 的整数数组的形式返回这两个数的</description>
    </item>
    
    <item>
      <title>[11]盛最多水的容器</title>
      <link>https://oxygenbytes.github.io/leetcode/11%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 02 Mar 2021 09:07:12 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/11%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</guid>
      <description>//给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, //ai) 和 (i, 0) 。找出其</description>
    </item>
    
    <item>
      <title>[42]接雨水</title>
      <link>https://oxygenbytes.github.io/leetcode/42%E6%8E%A5%E9%9B%A8%E6%B0%B4/</link>
      <pubDate>Tue, 02 Mar 2021 09:06:31 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/42%E6%8E%A5%E9%9B%A8%E6%B0%B4/</guid>
      <description>//给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 // // // // 示例 1： // // // // //输入：height</description>
    </item>
    
    <item>
      <title>[54]螺旋矩阵</title>
      <link>https://oxygenbytes.github.io/leetcode/54%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Mon, 01 Mar 2021 14:33:36 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/54%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</guid>
      <description>//给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素。 // // // // 示例 1： // // //输入：matrix = [[1,2,3],[4,5,6],[7,8,9]] //输出：[1,2,</description>
    </item>
    
    <item>
      <title>[199]二叉树的右视图</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/199%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</link>
      <pubDate>Mon, 01 Mar 2021 14:17:44 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/199%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE/</guid>
      <description>//给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 // // 示例: // // 输入: [1,2,3,null,5,null,4] //输出: [1, 3, 4] //解释</description>
    </item>
    
    <item>
      <title>[470]用 Rand7() 实现 Rand10()</title>
      <link>https://oxygenbytes.github.io/leetcode/470%E7%94%A8-rand7-%E5%AE%9E%E7%8E%B0-rand10/</link>
      <pubDate>Mon, 01 Mar 2021 14:00:36 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/470%E7%94%A8-rand7-%E5%AE%9E%E7%8E%B0-rand10/</guid>
      <description>//已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。 // // 不要使用系统的 Math.random() 方法。 // // // // // // // 示例 1:</description>
    </item>
    
    <item>
      <title>[442]数组中重复的数据</title>
      <link>https://oxygenbytes.github.io/leetcode/442%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 01 Mar 2021 13:20:20 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/442%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E6%8D%AE/</guid>
      <description>//给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。 // // 找到所有出现两次的元素。 // // 你可以不用到</description>
    </item>
    
    <item>
      <title>[93]复原 IP 地址</title>
      <link>https://oxygenbytes.github.io/leetcode/93%E5%A4%8D%E5%8E%9F-ip-%E5%9C%B0%E5%9D%80/</link>
      <pubDate>Mon, 01 Mar 2021 11:39:13 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/93%E5%A4%8D%E5%8E%9F-ip-%E5%9C%B0%E5%9D%80/</guid>
      <description>//给定一个只包含数字的字符串，用以表示一个 IP 地址，返回所有可能从 s 获得的 有效 IP 地址 。你可以按任何顺序返回答案。 // // 有效 IP 地址 正好由四个整数</description>
    </item>
    
    <item>
      <title>[24]两两交换链表中的节点</title>
      <link>https://oxygenbytes.github.io/leetcode/list/24-ii%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Mon, 01 Mar 2021 10:53:56 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/24-ii%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>//给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 // // 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 // // // // 示例</description>
    </item>
    
    <item>
      <title>[146]LRU 缓存机制</title>
      <link>https://oxygenbytes.github.io/leetcode/146lru-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Mon, 01 Mar 2021 10:50:42 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/146lru-%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</guid>
      <description>//运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制 。 // // // // 实现 LRUCache 类： // // // LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存 // int get(int key) 如果</description>
    </item>
    
    <item>
      <title>[78]子集</title>
      <link>https://oxygenbytes.github.io/leetcode/78-ii%E5%AD%90%E9%9B%86/</link>
      <pubDate>Sun, 28 Feb 2021 14:12:35 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/78-ii%E5%AD%90%E9%9B%86/</guid>
      <description>//给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 // // 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 // // //</description>
    </item>
    
    <item>
      <title>[47]全排列 II</title>
      <link>https://oxygenbytes.github.io/leetcode/47%E5%85%A8%E6%8E%92%E5%88%97-ii/</link>
      <pubDate>Sun, 28 Feb 2021 13:16:50 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/47%E5%85%A8%E6%8E%92%E5%88%97-ii/</guid>
      <description>//给定一个可包含重复数字的序列 nums ，按任意顺序 返回所有不重复的全排列。 // // // // 示例 1： // // //输入：nums = [1,1,2] //输出： //[[1,1,2], // [1,2,1], // [2,1,1]] // // // 示</description>
    </item>
    
    <item>
      <title>[147]对链表进行插入排序</title>
      <link>https://oxygenbytes.github.io/leetcode/list/147%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 28 Feb 2021 12:59:22 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/147%E5%AF%B9%E9%93%BE%E8%A1%A8%E8%BF%9B%E8%A1%8C%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>//对链表进行插入排序。 // // //插入排序的动画演示如上。从第一个元素开始，该链表可以被认为已经部分排序（用黑色表示）。 //每次迭代时，从输入</description>
    </item>
    
    <item>
      <title>[79]单词搜索</title>
      <link>https://oxygenbytes.github.io/leetcode/79%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</link>
      <pubDate>Sun, 28 Feb 2021 11:18:06 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/79%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/</guid>
      <description>//给定一个二维网格和一个单词，找出该单词是否存在于网格中。 // // 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些</description>
    </item>
    
    <item>
      <title>[151]翻转字符串里的单词</title>
      <link>https://oxygenbytes.github.io/leetcode/151%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</link>
      <pubDate>Sat, 27 Feb 2021 15:59:32 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/151%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%87%8C%E7%9A%84%E5%8D%95%E8%AF%8D/</guid>
      <description>//给定一个字符串，逐个翻转字符串中的每个单词。 // // 说明： // // // 无空格字符构成一个 单词 。 // 输入字符串可以在前面或者后面包含多余的空格，但是反</description>
    </item>
    
    <item>
      <title>[49]字母异位词分组</title>
      <link>https://oxygenbytes.github.io/leetcode/49%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</link>
      <pubDate>Sat, 27 Feb 2021 15:40:55 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/49%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</guid>
      <description>//给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 // // 示例: // // 输入: [&amp;#34;eat&amp;#34;, &amp;#34;tea&amp;#34;, &amp;#34;tan&amp;#34;, &amp;#34;ate&amp;#34;, &amp;#34;nat&amp;#34;, &amp;#34;bat&amp;#34;] //输出: //[ // [&amp;#34;ate&amp;#34;,&amp;#34;eat&amp;#34;,&amp;#34;tea&amp;#34;], //</description>
    </item>
    
    <item>
      <title>[38]外观数列</title>
      <link>https://oxygenbytes.github.io/leetcode/38%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</link>
      <pubDate>Sat, 27 Feb 2021 15:19:34 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/38%E5%A4%96%E8%A7%82%E6%95%B0%E5%88%97/</guid>
      <description>//给定一个正整数 n ，输出外观数列的第 n 项。 // // 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。 // // 你可以将其视</description>
    </item>
    
    <item>
      <title>[22]括号生成</title>
      <link>https://oxygenbytes.github.io/leetcode/22%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</link>
      <pubDate>Sat, 27 Feb 2021 14:54:20 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/22%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</guid>
      <description>//数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 // // // // 示例 1： // // //输入：n = 3 //输出：[&amp;</description>
    </item>
    
    <item>
      <title>[543]二叉树的直径</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/543-ii%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</link>
      <pubDate>Sat, 27 Feb 2021 12:08:51 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/543-ii%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</guid>
      <description>//给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 // // //</description>
    </item>
    
    <item>
      <title>[236]二叉树的最近公共祖先</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</link>
      <pubDate>Sat, 27 Feb 2021 11:56:09 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/236%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</guid>
      <description>//给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 // // 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表</description>
    </item>
    
    <item>
      <title>[105]从前序与中序遍历序列构造二叉树</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 27 Feb 2021 11:45:39 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/105%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>//根据一棵树的前序遍历与中序遍历构造二叉树。 // // 注意: //你可以假设树中没有重复的元素。 // // 例如，给出 // // 前序遍历 preorder = [3,9,20,15,7] //中序遍历 inorder = [9,3,15,20,7]</description>
    </item>
    
    <item>
      <title>[101]对称二叉树</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/101-ii%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sat, 27 Feb 2021 11:32:32 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/101-ii%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>//给定一个二叉树，检查它是否是镜像对称的。 // // // // 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 // // 1 // / \ // 2 2 // / \ / \ //3 4 4 3 // // // // // 但是下面这个 [1,2,2,null,3,null,3] 则不</description>
    </item>
    
    <item>
      <title>[148]排序链表</title>
      <link>https://oxygenbytes.github.io/leetcode/list/148%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 27 Feb 2021 10:22:35 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/148%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>//给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。 // // 进阶： // // // 你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</description>
    </item>
    
    <item>
      <title>[141]环形链表</title>
      <link>https://oxygenbytes.github.io/leetcode/list/141-ii%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 27 Feb 2021 09:51:50 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/141-ii%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>//给定一个链表，判断链表中是否有环。 // // 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们</description>
    </item>
    
    <item>
      <title>[142]环形链表 II</title>
      <link>https://oxygenbytes.github.io/leetcode/list/142%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii/</link>
      <pubDate>Sat, 27 Feb 2021 09:35:11 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/142%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8-ii/</guid>
      <description>//给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 // // 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链</description>
    </item>
    
    <item>
      <title>[160]相交链表</title>
      <link>https://oxygenbytes.github.io/leetcode/list/160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 26 Feb 2021 23:22:11 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/160%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</guid>
      <description>//编写一个程序，找到两个单链表相交的起始节点。 // // 如下面的两个链表： // // // // 在节点 c1 开始相交。 // // // // 示例 1： // // // // 输入：interse</description>
    </item>
    
    <item>
      <title>[92]反转链表 II</title>
      <link>https://oxygenbytes.github.io/leetcode/list/92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-ii/</link>
      <pubDate>Fri, 26 Feb 2021 22:55:34 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/92%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-ii/</guid>
      <description>//反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。 // // 说明: //1 ≤ m ≤ n ≤ 链表长度。 // // 示例: // // 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, m = 2, n = 4 //输出: 1-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;5-&amp;gt;NULL // Related Topics 链表</description>
    </item>
    
    <item>
      <title>[24]两两交换链表中的节点</title>
      <link>https://oxygenbytes.github.io/leetcode/list/24%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Fri, 26 Feb 2021 22:38:38 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/24%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>//给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。 // // 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。 // // // // 示例</description>
    </item>
    
    <item>
      <title>[61]旋转链表</title>
      <link>https://oxygenbytes.github.io/leetcode/list/61-ii%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Fri, 26 Feb 2021 22:24:19 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/61-ii%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>//给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 // // 示例 1: // // 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, k = 2 //输出: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL //解释: //向右旋转 1</description>
    </item>
    
    <item>
      <title>[83]删除排序链表中的重复元素</title>
      <link>https://oxygenbytes.github.io/leetcode/list/83%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</link>
      <pubDate>Fri, 26 Feb 2021 20:33:53 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/83%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</guid>
      <description>//给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。 // // 示例 1: // // 输入: 1-&amp;gt;1-&amp;gt;2 //输出: 1-&amp;gt;2 // // // 示例 2: // // 输入: 1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;3 //输出: 1-&amp;gt;2-&amp;gt;3 // Related</description>
    </item>
    
    <item>
      <title>[237]删除链表中的节点</title>
      <link>https://oxygenbytes.github.io/leetcode/list/237%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</link>
      <pubDate>Fri, 26 Feb 2021 20:27:21 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/237%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9/</guid>
      <description>//请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点。传入函数的唯一参数为 要被删除的节点 。 // // // // 现有一个链表 -- head = [4,5,1,</description>
    </item>
    
    <item>
      <title>[19]删除链表的倒数第 N 个结点</title>
      <link>https://oxygenbytes.github.io/leetcode/list/19-ii%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9/</link>
      <pubDate>Fri, 26 Feb 2021 20:15:55 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/19-ii%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9/</guid>
      <description>//给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 // // 进阶：你能尝试使用一趟扫描实现吗？ // // // // 示例 1： // // //输入：hea</description>
    </item>
    
    <item>
      <title>[278]第一个错误的版本</title>
      <link>https://oxygenbytes.github.io/leetcode/278%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</link>
      <pubDate>Fri, 26 Feb 2021 19:57:01 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/278%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%94%99%E8%AF%AF%E7%9A%84%E7%89%88%E6%9C%AC/</guid>
      <description>//你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以</description>
    </item>
    
    <item>
      <title>[33]搜索旋转排序数组</title>
      <link>https://oxygenbytes.github.io/leetcode/33%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</link>
      <pubDate>Fri, 26 Feb 2021 19:39:27 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/33%E6%90%9C%E7%B4%A2%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84/</guid>
      <description>//整数数组 nums 按升序排列，数组中的值 互不相同 。 // // 在传递给函数之前，nums 在预先未知的某个下标 k（0 &amp;lt;= k &amp;lt; nums.length）上进行了</description>
    </item>
    
    <item>
      <title>[153]寻找旋转排序数组中的最小值</title>
      <link>https://oxygenbytes.github.io/leetcode/153%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</link>
      <pubDate>Fri, 26 Feb 2021 15:40:53 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/153%E5%AF%BB%E6%89%BE%E6%97%8B%E8%BD%AC%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC/</guid>
      <description>//假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。 // // 请找出其中最小的元素。 // // // // 示例 1： // // //输入：n</description>
    </item>
    
    <item>
      <title>[74]搜索二维矩阵</title>
      <link>https://oxygenbytes.github.io/leetcode/74%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Fri, 26 Feb 2021 15:31:50 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/74%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5/</guid>
      <description>//编写一个高效的算法来判断 m x n 矩阵中，是否存在一个目标值。该矩阵具有如下特性： // // // 每行中的整数从左到右按升序排列。 // 每行的第一个整数大</description>
    </item>
    
    <item>
      <title>[69]x 的平方根</title>
      <link>https://oxygenbytes.github.io/leetcode/69x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</link>
      <pubDate>Fri, 26 Feb 2021 13:41:49 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/69x-%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9/</guid>
      <description>//实现 int sqrt(int x) 函数。 // // 计算并返回 x 的平方根，其中 x 是非负整数。 // // 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 // // 示例 1: //</description>
    </item>
    
    <item>
      <title>[35]搜索插入位置</title>
      <link>https://oxygenbytes.github.io/leetcode/35%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Fri, 26 Feb 2021 13:41:41 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/35%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</guid>
      <description>//给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 // // 你可以假设数</description>
    </item>
    
    <item>
      <title>[34]在排序数组中查找元素的第一个和最后一个位置</title>
      <link>https://oxygenbytes.github.io/leetcode/34%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</link>
      <pubDate>Fri, 26 Feb 2021 13:41:40 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/34%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE/</guid>
      <description>//给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。 // // 如果数组中不存在目标值</description>
    </item>
    
    <item>
      <title>[17]电话号码的字母组合</title>
      <link>https://oxygenbytes.github.io/leetcode/17-ii%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</link>
      <pubDate>Fri, 26 Feb 2021 13:27:27 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/17-ii%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</guid>
      <description>//给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 // // 给出数字到字母的映射如下（与电话按键相同）。注意 1</description>
    </item>
    
    <item>
      <title>[18]四数之和</title>
      <link>https://oxygenbytes.github.io/leetcode/18%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Fri, 26 Feb 2021 12:51:31 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/18%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>//给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + // d 的值与 target 相等？找出所有</description>
    </item>
    
    <item>
      <title>[468]验证IP地址</title>
      <link>https://oxygenbytes.github.io/leetcode/468%E9%AA%8C%E8%AF%81ip%E5%9C%B0%E5%9D%80/</link>
      <pubDate>Wed, 24 Feb 2021 12:01:34 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/468%E9%AA%8C%E8%AF%81ip%E5%9C%B0%E5%9D%80/</guid>
      <description>//编写一个函数来验证输入的字符串是否是有效的 IPv4 或 IPv6 地址。 // // // 如果是有效的 IPv4 地址，返回 &amp;#34;IPv4&amp;#34; ； // 如果是有效的 IPv6 地址，返回 &amp;#34;IPv6&amp;#34; ； // 如果不是上述类型</description>
    </item>
    
    <item>
      <title>[1143]最长公共子序列</title>
      <link>https://oxygenbytes.github.io/leetcode/1143%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Wed, 24 Feb 2021 11:42:27 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/1143%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>//给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列的长度。 // // 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改</description>
    </item>
    
    <item>
      <title>[64]最小路径和</title>
      <link>https://oxygenbytes.github.io/leetcode/64%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</link>
      <pubDate>Wed, 24 Feb 2021 11:34:06 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/64%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</guid>
      <description>//给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 // // 说明：每次只能向下或者向右移动一步</description>
    </item>
    
    <item>
      <title>[25]K 个一组翻转链表</title>
      <link>https://oxygenbytes.github.io/leetcode/list/25k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Wed, 24 Feb 2021 11:13:31 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/25k-%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>//给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 // // k 是一个正整数，它的值小于或等于链表的长度。 // // 如果节点总数不是 k 的整数</description>
    </item>
    
    <item>
      <title>[415]字符串相加</title>
      <link>https://oxygenbytes.github.io/leetcode/415%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Tue, 23 Feb 2021 22:36:11 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/415%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</guid>
      <description>//给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。 // // // // 提示： // // // num1 和num2 的长度都小于 5100 // num1 和num2 都只包含数字 0-9 // num1 和</description>
    </item>
    
    <item>
      <title>[206]反转链表</title>
      <link>https://oxygenbytes.github.io/leetcode/list/206-ii%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Tue, 23 Feb 2021 22:33:19 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/206-ii%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>//反转一个单链表。 // // 示例: // // 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL //输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL // // 进阶: //你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ // Related Topics 链表 // 👍 1519</description>
    </item>
    
    <item>
      <title>[169]多数元素</title>
      <link>https://oxygenbytes.github.io/leetcode/169%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</link>
      <pubDate>Tue, 23 Feb 2021 22:12:54 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/169%E5%A4%9A%E6%95%B0%E5%85%83%E7%B4%A0/</guid>
      <description>//给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素。 // // 你可以假设数组是非空的，并且给定的数组总是</description>
    </item>
    
    <item>
      <title>[20]有效的括号</title>
      <link>https://oxygenbytes.github.io/leetcode/stack/20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</link>
      <pubDate>Tue, 23 Feb 2021 21:59:02 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/stack/20%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/</guid>
      <description>//给定一个只包括 &amp;#39;(&amp;#39;，&amp;#39;)&amp;#39;，&amp;#39;{&amp;#39;，&amp;#39;}&amp;#39;，&amp;#39;[&amp;#39;，&amp;</description>
    </item>
    
    <item>
      <title>[17]电话号码的字母组合</title>
      <link>https://oxygenbytes.github.io/leetcode/17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</link>
      <pubDate>Tue, 23 Feb 2021 10:25:30 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/17%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/</guid>
      <description>//给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 // // 给出数字到字母的映射如下（与电话按键相同）。注意 1</description>
    </item>
    
    <item>
      <title>[226]翻转二叉树</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/226%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Tue, 23 Feb 2021 10:10:03 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/226%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>//翻转一棵二叉树。 // // 示例： // // 输入： // // 4 // / \ // 2 7 // / \ / \ //1 3 6 9 // // 输出： // // 4 // / \ // 7 2 // / \ / \ //9 6 3 1 // // 备注: //这个</description>
    </item>
    
    <item>
      <title>[120]三角形最小路径和</title>
      <link>https://oxygenbytes.github.io/leetcode/120%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</link>
      <pubDate>Mon, 22 Feb 2021 17:19:50 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/120%E4%B8%89%E8%A7%92%E5%BD%A2%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C/</guid>
      <description>//给定一个三角形 triangle ，找出自顶向下的最小路径和。 // // 每一步只能移动到下一行中相邻的结点上。相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者</description>
    </item>
    
    <item>
      <title>[115]不同的子序列</title>
      <link>https://oxygenbytes.github.io/leetcode/115%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/</link>
      <pubDate>Mon, 22 Feb 2021 17:19:43 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/115%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AD%90%E5%BA%8F%E5%88%97/</guid>
      <description>//给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。 // // 字符串的一个 子序列 是指，通过删除一些（也可以不删除）字符且不干扰剩余</description>
    </item>
    
    <item>
      <title>[91]解码方法</title>
      <link>https://oxygenbytes.github.io/leetcode/91%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</link>
      <pubDate>Mon, 22 Feb 2021 17:19:33 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/91%E8%A7%A3%E7%A0%81%E6%96%B9%E6%B3%95/</guid>
      <description>//一条包含字母 A-Z 的消息通过以下映射进行了 编码 ： // // //&amp;#39;A&amp;#39; -&amp;gt; 1 //&amp;#39;B&amp;#39; -&amp;gt; 2 //... //&amp;#39;Z&amp;#39; -&amp;gt; 26 // // // 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回</description>
    </item>
    
    <item>
      <title>[82]删除排序链表中的重复元素 II</title>
      <link>https://oxygenbytes.github.io/leetcode/list/82%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii/</link>
      <pubDate>Mon, 22 Feb 2021 17:19:22 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/82%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0-ii/</guid>
      <description>//给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现 的数字。 // // 示例 1: // // 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5 //输出: 1-&amp;gt;2-&amp;gt;5 // // // 示例 2: // // 输入</description>
    </item>
    
    <item>
      <title>[61]旋转链表</title>
      <link>https://oxygenbytes.github.io/leetcode/list/61%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 22 Feb 2021 17:19:12 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/61%E6%97%8B%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>//给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。 // // 示例 1: // // 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL, k = 2 //输出: 4-&amp;gt;5-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;NULL //解释: //向右旋转 1</description>
    </item>
    
    <item>
      <title>[72]编辑距离</title>
      <link>https://oxygenbytes.github.io/leetcode/72%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Mon, 22 Feb 2021 17:19:02 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/72%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/</guid>
      <description>//给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。 // // 你可以对一个单词进行如下三种操作： // // // 插入一个字符 // 删除一个</description>
    </item>
    
    <item>
      <title>[23]合并K个升序链表</title>
      <link>https://oxygenbytes.github.io/leetcode/list/23%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 22 Feb 2021 17:18:56 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/23%E5%90%88%E5%B9%B6k%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>//给你一个链表数组，每个链表都已经按升序排列。 // // 请你将所有链表合并到一个升序链表中，返回合并后的链表。 // // // // 示例 1： // // 输入：list</description>
    </item>
    
    <item>
      <title>[19]删除链表的倒数第 N 个结点</title>
      <link>https://oxygenbytes.github.io/leetcode/list/19%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9/</link>
      <pubDate>Mon, 22 Feb 2021 17:18:53 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/19%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-n-%E4%B8%AA%E7%BB%93%E7%82%B9/</guid>
      <description>//给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 // // 进阶：你能尝试使用一趟扫描实现吗？ // // // // 示例 1： // // //输入：hea</description>
    </item>
    
    <item>
      <title>[5]最长回文子串</title>
      <link>https://oxygenbytes.github.io/leetcode/5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Mon, 22 Feb 2021 17:18:48 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/5%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</guid>
      <description>//给你一个字符串 s，找到 s 中最长的回文子串。 // // // // 示例 1： // // //输入：s = &amp;#34;babad&amp;#34; //输出：&amp;#34;bab&amp;#34; //解释：&amp;#34;a</description>
    </item>
    
    <item>
      <title>[101]对称二叉树</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Mon, 22 Feb 2021 17:14:13 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/101%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>//给定一个二叉树，检查它是否是镜像对称的。 // // // // 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 // // 1 // / \ // 2 2 // / \ / \ //3 4 4 3 // // // // // 但是下面这个 [1,2,2,null,3,null,3] 则不</description>
    </item>
    
    <item>
      <title>[46]全排列</title>
      <link>https://oxygenbytes.github.io/leetcode/46%E5%85%A8%E6%8E%92%E5%88%97/</link>
      <pubDate>Mon, 22 Feb 2021 16:18:01 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/46%E5%85%A8%E6%8E%92%E5%88%97/</guid>
      <description>//给定一个 没有重复 数字的序列，返回其所有可能的全排列。 // // 示例: // // 输入: [1,2,3] //输出: //[ // [1,2,3], // [1,3,2], // [2,1,3], // [2,3,1], // [3,1,2], // [3,2,1] //] // Related Topics 回溯算法 // 👍 1142 👎 0</description>
    </item>
    
    <item>
      <title>[78]子集</title>
      <link>https://oxygenbytes.github.io/leetcode/78%E5%AD%90%E9%9B%86/</link>
      <pubDate>Mon, 22 Feb 2021 16:17:47 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/78%E5%AD%90%E9%9B%86/</guid>
      <description>//给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 // // 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 // // //</description>
    </item>
    
    <item>
      <title>[77]组合</title>
      <link>https://oxygenbytes.github.io/leetcode/77%E7%BB%84%E5%90%88/</link>
      <pubDate>Mon, 22 Feb 2021 16:17:43 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/77%E7%BB%84%E5%90%88/</guid>
      <description>//给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。 // // 示例: // // 输入: n = 4, k = 2 //输出: //[ // [2,4], // [3,4], // [2,3], // [1,2], // [1,3], // [1,4], //] // Related Topics 回溯</description>
    </item>
    
    <item>
      <title>[283]移动零</title>
      <link>https://oxygenbytes.github.io/leetcode/283%E7%A7%BB%E5%8A%A8%E9%9B%B6/</link>
      <pubDate>Mon, 22 Feb 2021 10:43:13 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/283%E7%A7%BB%E5%8A%A8%E9%9B%B6/</guid>
      <description>//给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 // // 示例: // // 输入: [0,1,0,3,12] //输出: [1,3,12,0,0] // // 说明: // //</description>
    </item>
    
    <item>
      <title>[215]数组中的第K个最大元素</title>
      <link>https://oxygenbytes.github.io/leetcode/215%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</link>
      <pubDate>Mon, 22 Feb 2021 10:40:03 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/215%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E7%AC%ACk%E4%B8%AA%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0/</guid>
      <description>//在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 // // 示例 1: // // 输入: [3,2,1,5,6,4] 和</description>
    </item>
    
    <item>
      <title>[8]字符串转换整数 (atoi)</title>
      <link>https://oxygenbytes.github.io/leetcode/8%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/</link>
      <pubDate>Mon, 22 Feb 2021 09:56:20 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/8%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0-atoi/</guid>
      <description>//请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。 // // 函数 myAtoi(string s) 的算法如下： // // // 读入字符串并丢弃无用的</description>
    </item>
    
    <item>
      <title>[7]整数反转</title>
      <link>https://oxygenbytes.github.io/leetcode/7%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</link>
      <pubDate>Mon, 22 Feb 2021 09:46:04 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/7%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</guid>
      <description>//给你一个 32 位的有符号整数 x ，返回 x 中每位上的数字反转后的结果。 // // 如果反转后整数超过 32 位的有符号整数的范围 [−231, 231 − 1] ，就返回 0。</description>
    </item>
    
    <item>
      <title>[15]三数之和</title>
      <link>https://oxygenbytes.github.io/leetcode/15%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Mon, 22 Feb 2021 09:01:42 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/15%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>//给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重 //复的三元组。 // //</description>
    </item>
    
    <item>
      <title>[144]二叉树的前序遍历</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/144%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Mon, 22 Feb 2021 08:51:19 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/144%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>//给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 // // // // 示例 1： // // //输入：root = [1,null,2,3] //输出：[1,2,3] // // // 示例 2： // // //输</description>
    </item>
    
    <item>
      <title>[206]反转链表</title>
      <link>https://oxygenbytes.github.io/leetcode/list/206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sun, 21 Feb 2021 22:36:27 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/206%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</guid>
      <description>//反转一个单链表。 // // 示例: // // 输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL //输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL // // 进阶: //你可以迭代或递归地反转链表。你能否用两种方法解决这道题？ // Related Topics 链表 // 👍 1518</description>
    </item>
    
    <item>
      <title>[191]位1的个数</title>
      <link>https://oxygenbytes.github.io/leetcode/191%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</link>
      <pubDate>Sun, 21 Feb 2021 22:34:05 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/191%E4%BD%8D1%E7%9A%84%E4%B8%AA%E6%95%B0/</guid>
      <description>//编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 &amp;#39;1&amp;#39; 的个数（也被称为汉明重量）。 // // // // 提示： // // //</description>
    </item>
    
    <item>
      <title>[111]二叉树的最小深度</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/111%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Sun, 21 Feb 2021 22:26:17 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/111%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6/</guid>
      <description>//给定一个二叉树，找出其最小深度。 // // 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 // // 说明：叶子节点是指没有子节点的节点。 // //</description>
    </item>
    
    <item>
      <title>[104]二叉树的最大深度</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</link>
      <pubDate>Sun, 21 Feb 2021 22:15:34 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/104%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</guid>
      <description>//给定一个二叉树，找出其最大深度。 // // 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 // // 说明: 叶子节点是指没有子节点的节点。 // //</description>
    </item>
    
    <item>
      <title>[102]二叉树的层序遍历</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 21 Feb 2021 22:15:25 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>//给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 // // // // 示例： //二叉树：[3,9,20,null</description>
    </item>
    
    <item>
      <title>[94]二叉树的中序遍历</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</link>
      <pubDate>Sun, 21 Feb 2021 22:02:35 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86/</guid>
      <description>//给定一个二叉树的根节点 root ，返回它的 中序 遍历。 // // // // 示例 1： // // //输入：root = [1,null,2,3] //输出：[1,3,2] // // // 示例 2： // // //输入</description>
    </item>
    
    <item>
      <title>[617]合并二叉树</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/617%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 21 Feb 2021 21:47:00 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/617%E5%90%88%E5%B9%B6%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>//给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 // // 你需要将他们合并为一个新的二叉树。合并的规则是</description>
    </item>
    
    <item>
      <title>[62]不同路径</title>
      <link>https://oxygenbytes.github.io/leetcode/62%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sun, 21 Feb 2021 21:20:49 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/62%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</guid>
      <description>//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 // // 机器人每次只能向下或者向右移动一步。机器人试图达到网格的</description>
    </item>
    
    <item>
      <title>[62]不同路径 II</title>
      <link>https://oxygenbytes.github.io/leetcode/63%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-ii/</link>
      <pubDate>Sun, 21 Feb 2021 21:20:49 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/63%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84-ii/</guid>
      <description>//一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 // // 机器人每次只能向下或者向右移动一步。机器人试图达到网格的</description>
    </item>
    
    <item>
      <title>[3]无重复字符的最长子串</title>
      <link>https://oxygenbytes.github.io/leetcode/3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</link>
      <pubDate>Sun, 21 Feb 2021 20:29:29 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/3%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</guid>
      <description>//给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 // // // // 示例 1: // // //输入: s = &amp;#34;abcabcbb&amp;#34; //输出: 3 //解释: 因为无重复字符的最长</description>
    </item>
    
    <item>
      <title>[687]最长同值路径</title>
      <link>https://oxygenbytes.github.io/leetcode/687%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Sun, 21 Feb 2021 19:54:43 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/687%E6%9C%80%E9%95%BF%E5%90%8C%E5%80%BC%E8%B7%AF%E5%BE%84/</guid>
      <description>//给定一个二叉树，找到最长的路径，这个路径中的每个节点具有相同值。 这条路径可以经过也可以不经过根节点。 // // 注意：两个节点之间的路径长度由它</description>
    </item>
    
    <item>
      <title>[543]二叉树的直径</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/543%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</link>
      <pubDate>Sun, 21 Feb 2021 19:45:41 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/543%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84/</guid>
      <description>//给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 // // //</description>
    </item>
    
    <item>
      <title>[110]平衡二叉树</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</link>
      <pubDate>Sun, 21 Feb 2021 19:34:59 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/110%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</guid>
      <description>//给定一个二叉树，判断它是否是高度平衡的二叉树。 // // 本题中，一棵高度平衡二叉树定义为： // // // 一个二叉树每个节点 的左右两个子树的高度差的绝对</description>
    </item>
    
    <item>
      <title>[98]验证二叉搜索树</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</link>
      <pubDate>Sat, 20 Feb 2021 11:51:32 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/98%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</guid>
      <description>//给定一个二叉树，判断其是否是一个有效的二叉搜索树。 // // 假设一个二叉搜索树具有如下特征： // // // 节点的左子树只包含小于当前节点的数。 // 节点的</description>
    </item>
    
    <item>
      <title>[2]两数相加</title>
      <link>https://oxygenbytes.github.io/leetcode/list/2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</link>
      <pubDate>Sat, 20 Feb 2021 11:22:10 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/2%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</guid>
      <description>//给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 // // 请你将两个数相加，并以相</description>
    </item>
    
    <item>
      <title>[1]两数之和</title>
      <link>https://oxygenbytes.github.io/leetcode/hashmap/1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</link>
      <pubDate>Sat, 20 Feb 2021 11:22:07 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/hashmap/1%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</guid>
      <description>//给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 // // 你可以假设每种输入只</description>
    </item>
    
    <item>
      <title>[21]合并两个有序链表</title>
      <link>https://oxygenbytes.github.io/leetcode/list/21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 20 Feb 2021 11:15:25 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/21%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</guid>
      <description>//将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 // // // // 示例 1： // // //输入：l1 = [1,2,4], l2 = [1,3,4]</description>
    </item>
    
    <item>
      <title>[70]爬楼梯</title>
      <link>https://oxygenbytes.github.io/leetcode/70%E7%88%AC%E6%A5%BC%E6%A2%AF/</link>
      <pubDate>Sat, 20 Feb 2021 11:09:41 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/70%E7%88%AC%E6%A5%BC%E6%A2%AF/</guid>
      <description>//假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 // // 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ // // 注意：给定 n 是一个正整数</description>
    </item>
    
    <item>
      <title>[100]相同的树</title>
      <link>https://oxygenbytes.github.io/leetcode/tree/100%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</link>
      <pubDate>Sat, 20 Feb 2021 11:05:40 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/tree/100%E7%9B%B8%E5%90%8C%E7%9A%84%E6%A0%91/</guid>
      <description>//给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 // // 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。</description>
    </item>
    
    <item>
      <title>[141]环形链表</title>
      <link>https://oxygenbytes.github.io/leetcode/list/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Sat, 20 Feb 2021 10:52:12 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/list/141%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8/</guid>
      <description>//给定一个链表，判断链表中是否有环。 // // 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们</description>
    </item>
    
    <item>
      <title>[53]最大子序和</title>
      <link>https://oxygenbytes.github.io/leetcode/53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</link>
      <pubDate>Sat, 20 Feb 2021 08:29:45 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/53%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</guid>
      <description>//给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 // // // // 示例 1： // // //输入：nums = [-2,1,-3,4,-1,2,1,-5,4] /</description>
    </item>
    
    <item>
      <title>[14]最长公共前缀</title>
      <link>https://oxygenbytes.github.io/leetcode/14%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</link>
      <pubDate>Fri, 19 Feb 2021 23:04:38 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/14%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80/</guid>
      <description>//编写一个函数来查找字符串数组中的最长公共前缀。 // // 如果不存在公共前缀，返回空字符串 &amp;#34;&amp;#34;。 // // // // 示例 1： // // //输入：s</description>
    </item>
    
    <item>
      <title>[1760]袋子里最少数目的球</title>
      <link>https://oxygenbytes.github.io/leetcode/binarysearch/1760%E8%A2%8B%E5%AD%90%E9%87%8C%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E7%90%83/</link>
      <pubDate>Fri, 19 Feb 2021 22:06:02 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/binarysearch/1760%E8%A2%8B%E5%AD%90%E9%87%8C%E6%9C%80%E5%B0%91%E6%95%B0%E7%9B%AE%E7%9A%84%E7%90%83/</guid>
      <description>//给你一个整数数组 nums ，其中 nums[i] 表示第 i 个袋子里球的数目。同时给你一个整数 maxOperations 。 // // 你可以进行如下操作至多 maxOperations 次： // // // 选择任意一个袋子，并将袋子</description>
    </item>
    
    <item>
      <title>关于博客的Leetcode代码的格式和生成</title>
      <link>https://oxygenbytes.github.io/leetcode/leetcodeformat/</link>
      <pubDate>Sat, 22 Aug 2020 21:13:42 +0800</pubDate>
      
      <guid>https://oxygenbytes.github.io/leetcode/leetcodeformat/</guid>
      <description>刷题时生成C++文件 我以前经常在Vscode中刷leetcode题目，但这种方式的代码不够规范，也比较耗时，因为主力语言是 C++ ,所以现在在 Clion 中</description>
    </item>
    
  </channel>
</rss>
